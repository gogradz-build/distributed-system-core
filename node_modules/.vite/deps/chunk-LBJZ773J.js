import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/moment/dist/moment.js
var moment_exports = {};
__export(moment_exports, {
  default: () => moment_default
});
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
function isValid(m) {
  var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m);
    parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m)) {
    m._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
function copyConfig(to2, from2) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
function invalidDate() {
  return this._invalidDate;
}
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function addParseToken(token2, callback) {
  var i, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
  void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n, x) {
  return (n % x + x) % x;
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
function localeMonths(m, format2) {
  if (!m) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate(y, m, d, h, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h, M, s, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
function localeWeekdays(m, format2) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale2, split;
  while (i < names.length) {
    split = normalizeLocale(names[i]).split("-");
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
function configFromISO(config) {
  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
    return h * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
function defaults(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w.W, 1);
    weekday = defaults(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
    week = defaults(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
function createDuration(input, key) {
  var duration = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0; i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
function localeData() {
  return this._locale;
}
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
function localeEras(m, format2) {
  var i, l, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    erasName = regexEscape(eras[i].name);
    erasAbbr = regexEscape(eras[i].abbr);
    erasNarrow = regexEscape(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
function get$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1(format2, index, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index != null) {
    return get$1(format2, (index + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
function weeks() {
  return absFloor(this.days() / 7);
}
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var hookCallback, some, momentProperties, updateInProgress, deprecations, keys, defaultCalendar, formattingTokens, localFormattingTokens, formatFunctions, formatTokenFunctions, defaultLongDateFormat, defaultInvalidDate, defaultOrdinal, defaultDayOfMonthOrdinalParse, defaultRelativeTime, aliases, priorities, match1, match2, match3, match4, match6, match1to2, match3to4, match5to6, match1to3, match1to4, match1to6, matchUnsigned, matchSigned, matchOffset, matchShortOffset, matchTimestamp, matchWord, match1to2NoLeadingZero, match1to2HasZero, regexes, tokens, YEAR, MONTH, DATE, HOUR, MINUTE, SECOND, MILLISECOND, WEEK, WEEKDAY, getSetYear, indexOf, defaultLocaleMonths, defaultLocaleMonthsShort, MONTHS_IN_FORMAT, defaultMonthsShortRegex, defaultMonthsRegex, defaultLocaleWeek, defaultLocaleWeekdays, defaultLocaleWeekdaysShort, defaultLocaleWeekdaysMin, defaultWeekdaysRegex, defaultWeekdaysShortRegex, defaultWeekdaysMinRegex, defaultLocaleMeridiemParse, getSetHour, baseConfig, locales, localeFamilies, globalLocale, extendedIsoRegex, basicIsoRegex, tzRegex, isoDates, isoTimes, aspNetJsonRegex, rfc2822, obsOffsets, prototypeMin, prototypeMax, now, ordering, chunkOffset, aspNetRegex, isoRegex, add, subtract, lang, MS_PER_SECOND, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_400_YEARS, getSetDayOfMonth, getSetMinute, getSetSecond, token, getSetMillisecond, proto, proto$1, mathAbs, asMilliseconds, asSeconds, asMinutes, asHours, asDays, asWeeks, asMonths, asQuarters, asYears, valueOf$1, milliseconds, seconds, minutes, hours, days, months, years, round, thresholds, abs$1, proto$2, moment_default;
var init_moment = __esm({
  "node_modules/moment/dist/moment.js"() {
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    momentProperties = hooks.momentProperties = [];
    updateInProgress = false;
    deprecations = {};
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    formatFunctions = {};
    formatTokenFunctions = {};
    defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    defaultInvalidDate = "Invalid date";
    defaultOrdinal = "%d";
    defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    match1 = /\d/;
    match2 = /\d\d/;
    match3 = /\d{3}/;
    match4 = /\d{4}/;
    match6 = /[+-]?\d{6}/;
    match1to2 = /\d\d?/;
    match3to4 = /\d\d\d\d?/;
    match5to6 = /\d\d\d\d\d\d?/;
    match1to3 = /\d{1,3}/;
    match1to4 = /\d{1,4}/;
    match1to6 = /[+-]?\d{1,6}/;
    matchUnsigned = /\d+/;
    matchSigned = /[+-]?\d+/;
    matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    match1to2NoLeadingZero = /^[1-9]\d?/;
    match1to2HasZero = /^([1-9]\d|\d)/;
    regexes = {};
    tokens = {};
    YEAR = 0;
    MONTH = 1;
    DATE = 2;
    HOUR = 3;
    MINUTE = 4;
    SECOND = 5;
    MILLISECOND = 6;
    WEEK = 7;
    WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    getSetYear = makeGetSet("FullYear", true);
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    );
    defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    defaultMonthsShortRegex = matchWord;
    defaultMonthsRegex = matchWord;
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    defaultWeekdaysRegex = matchWord;
    defaultWeekdaysShortRegex = matchWord;
    defaultWeekdaysMinRegex = matchWord;
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    meridiem("a", true);
    meridiem("A", false);
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    getSetHour = makeGetSet("Hours", true);
    baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    locales = {};
    localeFamilies = {};
    extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ];
    isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ];
    aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
    obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    chunkOffset = /([\+\-]|\d\d)/gi;
    hooks.updateOffset = function() {
    };
    aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
    isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    add = createAdder(1, "add");
    subtract = createAdder(-1, "subtract");
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    MS_PER_SECOND = 1e3;
    MS_PER_MINUTE = 60 * MS_PER_SECOND;
    MS_PER_HOUR = 60 * MS_PER_MINUTE;
    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    mathAbs = Math.abs;
    asMilliseconds = makeAs("ms");
    asSeconds = makeAs("s");
    asMinutes = makeAs("m");
    asHours = makeAs("h");
    asDays = makeAs("d");
    asWeeks = makeAs("w");
    asMonths = makeAs("M");
    asQuarters = makeAs("Q");
    asYears = makeAs("y");
    valueOf$1 = asMilliseconds;
    milliseconds = makeGetter("milliseconds");
    seconds = makeGetter("seconds");
    minutes = makeGetter("minutes");
    hours = makeGetter("hours");
    days = makeGetter("days");
    months = makeGetter("months");
    years = makeGetter("years");
    round = Math.round;
    thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    abs$1 = Math.abs;
    proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    moment_default = hooks;
  }
});

// node_modules/admin-lte/plugins/chart.js/Chart.min.js
var require_Chart_min = __commonJS({
  "node_modules/admin-lte/plugins/chart.js/Chart.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e(function() {
        try {
          return init_moment(), __toCommonJS(moment_exports);
        } catch (t2) {
        }
      }()) : "function" == typeof define && define.amd ? define(["require"], function(t2) {
        return e(function() {
          try {
            return t2("moment");
          } catch (t3) {
          }
        }());
      }) : (t = t || self).Chart = e(t.moment);
    }(exports, function(t) {
      "use strict";
      t = t && t.hasOwnProperty("default") ? t.default : t;
      var e = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, n = function(t2, e2) {
        return t2(e2 = { exports: {} }, e2.exports), e2.exports;
      }(function(t2) {
        var n2 = {};
        for (var i2 in e) e.hasOwnProperty(i2) && (n2[e[i2]] = i2);
        var a2 = t2.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        for (var r2 in a2) if (a2.hasOwnProperty(r2)) {
          if (!("channels" in a2[r2])) throw new Error("missing channels property: " + r2);
          if (!("labels" in a2[r2])) throw new Error("missing channel labels property: " + r2);
          if (a2[r2].labels.length !== a2[r2].channels) throw new Error("channel and label counts mismatch: " + r2);
          var o2 = a2[r2].channels, s2 = a2[r2].labels;
          delete a2[r2].channels, delete a2[r2].labels, Object.defineProperty(a2[r2], "channels", { value: o2 }), Object.defineProperty(a2[r2], "labels", { value: s2 });
        }
        a2.rgb.hsl = function(t3) {
          var e2, n3, i3 = t3[0] / 255, a3 = t3[1] / 255, r3 = t3[2] / 255, o3 = Math.min(i3, a3, r3), s3 = Math.max(i3, a3, r3), l2 = s3 - o3;
          return s3 === o3 ? e2 = 0 : i3 === s3 ? e2 = (a3 - r3) / l2 : a3 === s3 ? e2 = 2 + (r3 - i3) / l2 : r3 === s3 && (e2 = 4 + (i3 - a3) / l2), (e2 = Math.min(60 * e2, 360)) < 0 && (e2 += 360), n3 = (o3 + s3) / 2, [e2, 100 * (s3 === o3 ? 0 : n3 <= 0.5 ? l2 / (s3 + o3) : l2 / (2 - s3 - o3)), 100 * n3];
        }, a2.rgb.hsv = function(t3) {
          var e2, n3, i3, a3, r3, o3 = t3[0] / 255, s3 = t3[1] / 255, l2 = t3[2] / 255, u2 = Math.max(o3, s3, l2), d2 = u2 - Math.min(o3, s3, l2), h2 = function(t4) {
            return (u2 - t4) / 6 / d2 + 0.5;
          };
          return 0 === d2 ? a3 = r3 = 0 : (r3 = d2 / u2, e2 = h2(o3), n3 = h2(s3), i3 = h2(l2), o3 === u2 ? a3 = i3 - n3 : s3 === u2 ? a3 = 1 / 3 + e2 - i3 : l2 === u2 && (a3 = 2 / 3 + n3 - e2), a3 < 0 ? a3 += 1 : a3 > 1 && (a3 -= 1)), [360 * a3, 100 * r3, 100 * u2];
        }, a2.rgb.hwb = function(t3) {
          var e2 = t3[0], n3 = t3[1], i3 = t3[2];
          return [a2.rgb.hsl(t3)[0], 100 * (1 / 255 * Math.min(e2, Math.min(n3, i3))), 100 * (i3 = 1 - 1 / 255 * Math.max(e2, Math.max(n3, i3)))];
        }, a2.rgb.cmyk = function(t3) {
          var e2, n3 = t3[0] / 255, i3 = t3[1] / 255, a3 = t3[2] / 255;
          return [100 * ((1 - n3 - (e2 = Math.min(1 - n3, 1 - i3, 1 - a3))) / (1 - e2) || 0), 100 * ((1 - i3 - e2) / (1 - e2) || 0), 100 * ((1 - a3 - e2) / (1 - e2) || 0), 100 * e2];
        }, a2.rgb.keyword = function(t3) {
          var i3 = n2[t3];
          if (i3) return i3;
          var a3, r3, o3, s3 = 1 / 0;
          for (var l2 in e) if (e.hasOwnProperty(l2)) {
            var u2 = e[l2], d2 = (r3 = t3, o3 = u2, Math.pow(r3[0] - o3[0], 2) + Math.pow(r3[1] - o3[1], 2) + Math.pow(r3[2] - o3[2], 2));
            d2 < s3 && (s3 = d2, a3 = l2);
          }
          return a3;
        }, a2.keyword.rgb = function(t3) {
          return e[t3];
        }, a2.rgb.xyz = function(t3) {
          var e2 = t3[0] / 255, n3 = t3[1] / 255, i3 = t3[2] / 255;
          return [100 * (0.4124 * (e2 = e2 > 0.04045 ? Math.pow((e2 + 0.055) / 1.055, 2.4) : e2 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (i3 = i3 > 0.04045 ? Math.pow((i3 + 0.055) / 1.055, 2.4) : i3 / 12.92)), 100 * (0.2126 * e2 + 0.7152 * n3 + 0.0722 * i3), 100 * (0.0193 * e2 + 0.1192 * n3 + 0.9505 * i3)];
        }, a2.rgb.lab = function(t3) {
          var e2 = a2.rgb.xyz(t3), n3 = e2[0], i3 = e2[1], r3 = e2[2];
          return i3 /= 100, r3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116) - 16, 500 * (n3 - i3), 200 * (i3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
        }, a2.hsl.rgb = function(t3) {
          var e2, n3, i3, a3, r3, o3 = t3[0] / 360, s3 = t3[1] / 100, l2 = t3[2] / 100;
          if (0 === s3) return [r3 = 255 * l2, r3, r3];
          e2 = 2 * l2 - (n3 = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3), a3 = [0, 0, 0];
          for (var u2 = 0; u2 < 3; u2++) (i3 = o3 + 1 / 3 * -(u2 - 1)) < 0 && i3++, i3 > 1 && i3--, r3 = 6 * i3 < 1 ? e2 + 6 * (n3 - e2) * i3 : 2 * i3 < 1 ? n3 : 3 * i3 < 2 ? e2 + (n3 - e2) * (2 / 3 - i3) * 6 : e2, a3[u2] = 255 * r3;
          return a3;
        }, a2.hsl.hsv = function(t3) {
          var e2 = t3[0], n3 = t3[1] / 100, i3 = t3[2] / 100, a3 = n3, r3 = Math.max(i3, 0.01);
          return n3 *= (i3 *= 2) <= 1 ? i3 : 2 - i3, a3 *= r3 <= 1 ? r3 : 2 - r3, [e2, 100 * (0 === i3 ? 2 * a3 / (r3 + a3) : 2 * n3 / (i3 + n3)), 100 * ((i3 + n3) / 2)];
        }, a2.hsv.rgb = function(t3) {
          var e2 = t3[0] / 60, n3 = t3[1] / 100, i3 = t3[2] / 100, a3 = Math.floor(e2) % 6, r3 = e2 - Math.floor(e2), o3 = 255 * i3 * (1 - n3), s3 = 255 * i3 * (1 - n3 * r3), l2 = 255 * i3 * (1 - n3 * (1 - r3));
          switch (i3 *= 255, a3) {
            case 0:
              return [i3, l2, o3];
            case 1:
              return [s3, i3, o3];
            case 2:
              return [o3, i3, l2];
            case 3:
              return [o3, s3, i3];
            case 4:
              return [l2, o3, i3];
            case 5:
              return [i3, o3, s3];
          }
        }, a2.hsv.hsl = function(t3) {
          var e2, n3, i3, a3 = t3[0], r3 = t3[1] / 100, o3 = t3[2] / 100, s3 = Math.max(o3, 0.01);
          return i3 = (2 - r3) * o3, n3 = r3 * s3, [a3, 100 * (n3 = (n3 /= (e2 = (2 - r3) * s3) <= 1 ? e2 : 2 - e2) || 0), 100 * (i3 /= 2)];
        }, a2.hwb.rgb = function(t3) {
          var e2, n3, i3, a3, r3, o3, s3, l2 = t3[0] / 360, u2 = t3[1] / 100, d2 = t3[2] / 100, h2 = u2 + d2;
          switch (h2 > 1 && (u2 /= h2, d2 /= h2), i3 = 6 * l2 - (e2 = Math.floor(6 * l2)), 0 != (1 & e2) && (i3 = 1 - i3), a3 = u2 + i3 * ((n3 = 1 - d2) - u2), e2) {
            default:
            case 6:
            case 0:
              r3 = n3, o3 = a3, s3 = u2;
              break;
            case 1:
              r3 = a3, o3 = n3, s3 = u2;
              break;
            case 2:
              r3 = u2, o3 = n3, s3 = a3;
              break;
            case 3:
              r3 = u2, o3 = a3, s3 = n3;
              break;
            case 4:
              r3 = a3, o3 = u2, s3 = n3;
              break;
            case 5:
              r3 = n3, o3 = u2, s3 = a3;
          }
          return [255 * r3, 255 * o3, 255 * s3];
        }, a2.cmyk.rgb = function(t3) {
          var e2 = t3[0] / 100, n3 = t3[1] / 100, i3 = t3[2] / 100, a3 = t3[3] / 100;
          return [255 * (1 - Math.min(1, e2 * (1 - a3) + a3)), 255 * (1 - Math.min(1, n3 * (1 - a3) + a3)), 255 * (1 - Math.min(1, i3 * (1 - a3) + a3))];
        }, a2.xyz.rgb = function(t3) {
          var e2, n3, i3, a3 = t3[0] / 100, r3 = t3[1] / 100, o3 = t3[2] / 100;
          return n3 = -0.9689 * a3 + 1.8758 * r3 + 0.0415 * o3, i3 = 0.0557 * a3 + -0.204 * r3 + 1.057 * o3, e2 = (e2 = 3.2406 * a3 + -1.5372 * r3 + -0.4986 * o3) > 31308e-7 ? 1.055 * Math.pow(e2, 1 / 2.4) - 0.055 : 12.92 * e2, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, i3 = i3 > 31308e-7 ? 1.055 * Math.pow(i3, 1 / 2.4) - 0.055 : 12.92 * i3, [255 * (e2 = Math.min(Math.max(0, e2), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (i3 = Math.min(Math.max(0, i3), 1))];
        }, a2.xyz.lab = function(t3) {
          var e2 = t3[0], n3 = t3[1], i3 = t3[2];
          return n3 /= 100, i3 /= 108.883, e2 = (e2 /= 95.047) > 8856e-6 ? Math.pow(e2, 1 / 3) : 7.787 * e2 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (e2 - n3), 200 * (n3 - (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116))];
        }, a2.lab.xyz = function(t3) {
          var e2, n3, i3, a3 = t3[0];
          e2 = t3[1] / 500 + (n3 = (a3 + 16) / 116), i3 = n3 - t3[2] / 200;
          var r3 = Math.pow(n3, 3), o3 = Math.pow(e2, 3), s3 = Math.pow(i3, 3);
          return n3 = r3 > 8856e-6 ? r3 : (n3 - 16 / 116) / 7.787, e2 = o3 > 8856e-6 ? o3 : (e2 - 16 / 116) / 7.787, i3 = s3 > 8856e-6 ? s3 : (i3 - 16 / 116) / 7.787, [e2 *= 95.047, n3 *= 100, i3 *= 108.883];
        }, a2.lab.lch = function(t3) {
          var e2, n3 = t3[0], i3 = t3[1], a3 = t3[2];
          return (e2 = 360 * Math.atan2(a3, i3) / 2 / Math.PI) < 0 && (e2 += 360), [n3, Math.sqrt(i3 * i3 + a3 * a3), e2];
        }, a2.lch.lab = function(t3) {
          var e2, n3 = t3[0], i3 = t3[1];
          return e2 = t3[2] / 360 * 2 * Math.PI, [n3, i3 * Math.cos(e2), i3 * Math.sin(e2)];
        }, a2.rgb.ansi16 = function(t3) {
          var e2 = t3[0], n3 = t3[1], i3 = t3[2], r3 = 1 in arguments ? arguments[1] : a2.rgb.hsv(t3)[2];
          if (0 === (r3 = Math.round(r3 / 50))) return 30;
          var o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(e2 / 255));
          return 2 === r3 && (o3 += 60), o3;
        }, a2.hsv.ansi16 = function(t3) {
          return a2.rgb.ansi16(a2.hsv.rgb(t3), t3[2]);
        }, a2.rgb.ansi256 = function(t3) {
          var e2 = t3[0], n3 = t3[1], i3 = t3[2];
          return e2 === n3 && n3 === i3 ? e2 < 8 ? 16 : e2 > 248 ? 231 : Math.round((e2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e2 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(i3 / 255 * 5);
        }, a2.ansi16.rgb = function(t3) {
          var e2 = t3 % 10;
          if (0 === e2 || 7 === e2) return t3 > 50 && (e2 += 3.5), [e2 = e2 / 10.5 * 255, e2, e2];
          var n3 = 0.5 * (1 + ~~(t3 > 50));
          return [(1 & e2) * n3 * 255, (e2 >> 1 & 1) * n3 * 255, (e2 >> 2 & 1) * n3 * 255];
        }, a2.ansi256.rgb = function(t3) {
          if (t3 >= 232) {
            var e2 = 10 * (t3 - 232) + 8;
            return [e2, e2, e2];
          }
          var n3;
          return t3 -= 16, [Math.floor(t3 / 36) / 5 * 255, Math.floor((n3 = t3 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
        }, a2.rgb.hex = function(t3) {
          var e2 = (((255 & Math.round(t3[0])) << 16) + ((255 & Math.round(t3[1])) << 8) + (255 & Math.round(t3[2]))).toString(16).toUpperCase();
          return "000000".substring(e2.length) + e2;
        }, a2.hex.rgb = function(t3) {
          var e2 = t3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!e2) return [0, 0, 0];
          var n3 = e2[0];
          3 === e2[0].length && (n3 = n3.split("").map(function(t4) {
            return t4 + t4;
          }).join(""));
          var i3 = parseInt(n3, 16);
          return [i3 >> 16 & 255, i3 >> 8 & 255, 255 & i3];
        }, a2.rgb.hcg = function(t3) {
          var e2, n3 = t3[0] / 255, i3 = t3[1] / 255, a3 = t3[2] / 255, r3 = Math.max(Math.max(n3, i3), a3), o3 = Math.min(Math.min(n3, i3), a3), s3 = r3 - o3;
          return e2 = s3 <= 0 ? 0 : r3 === n3 ? (i3 - a3) / s3 % 6 : r3 === i3 ? 2 + (a3 - n3) / s3 : 4 + (n3 - i3) / s3 + 4, e2 /= 6, [360 * (e2 %= 1), 100 * s3, 100 * (s3 < 1 ? o3 / (1 - s3) : 0)];
        }, a2.hsl.hcg = function(t3) {
          var e2 = t3[1] / 100, n3 = t3[2] / 100, i3 = 1, a3 = 0;
          return (i3 = n3 < 0.5 ? 2 * e2 * n3 : 2 * e2 * (1 - n3)) < 1 && (a3 = (n3 - 0.5 * i3) / (1 - i3)), [t3[0], 100 * i3, 100 * a3];
        }, a2.hsv.hcg = function(t3) {
          var e2 = t3[1] / 100, n3 = t3[2] / 100, i3 = e2 * n3, a3 = 0;
          return i3 < 1 && (a3 = (n3 - i3) / (1 - i3)), [t3[0], 100 * i3, 100 * a3];
        }, a2.hcg.rgb = function(t3) {
          var e2 = t3[0] / 360, n3 = t3[1] / 100, i3 = t3[2] / 100;
          if (0 === n3) return [255 * i3, 255 * i3, 255 * i3];
          var a3, r3 = [0, 0, 0], o3 = e2 % 1 * 6, s3 = o3 % 1, l2 = 1 - s3;
          switch (Math.floor(o3)) {
            case 0:
              r3[0] = 1, r3[1] = s3, r3[2] = 0;
              break;
            case 1:
              r3[0] = l2, r3[1] = 1, r3[2] = 0;
              break;
            case 2:
              r3[0] = 0, r3[1] = 1, r3[2] = s3;
              break;
            case 3:
              r3[0] = 0, r3[1] = l2, r3[2] = 1;
              break;
            case 4:
              r3[0] = s3, r3[1] = 0, r3[2] = 1;
              break;
            default:
              r3[0] = 1, r3[1] = 0, r3[2] = l2;
          }
          return a3 = (1 - n3) * i3, [255 * (n3 * r3[0] + a3), 255 * (n3 * r3[1] + a3), 255 * (n3 * r3[2] + a3)];
        }, a2.hcg.hsv = function(t3) {
          var e2 = t3[1] / 100, n3 = e2 + t3[2] / 100 * (1 - e2), i3 = 0;
          return n3 > 0 && (i3 = e2 / n3), [t3[0], 100 * i3, 100 * n3];
        }, a2.hcg.hsl = function(t3) {
          var e2 = t3[1] / 100, n3 = t3[2] / 100 * (1 - e2) + 0.5 * e2, i3 = 0;
          return n3 > 0 && n3 < 0.5 ? i3 = e2 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (i3 = e2 / (2 * (1 - n3))), [t3[0], 100 * i3, 100 * n3];
        }, a2.hcg.hwb = function(t3) {
          var e2 = t3[1] / 100, n3 = e2 + t3[2] / 100 * (1 - e2);
          return [t3[0], 100 * (n3 - e2), 100 * (1 - n3)];
        }, a2.hwb.hcg = function(t3) {
          var e2 = t3[1] / 100, n3 = 1 - t3[2] / 100, i3 = n3 - e2, a3 = 0;
          return i3 < 1 && (a3 = (n3 - i3) / (1 - i3)), [t3[0], 100 * i3, 100 * a3];
        }, a2.apple.rgb = function(t3) {
          return [t3[0] / 65535 * 255, t3[1] / 65535 * 255, t3[2] / 65535 * 255];
        }, a2.rgb.apple = function(t3) {
          return [t3[0] / 255 * 65535, t3[1] / 255 * 65535, t3[2] / 255 * 65535];
        }, a2.gray.rgb = function(t3) {
          return [t3[0] / 100 * 255, t3[0] / 100 * 255, t3[0] / 100 * 255];
        }, a2.gray.hsl = a2.gray.hsv = function(t3) {
          return [0, 0, t3[0]];
        }, a2.gray.hwb = function(t3) {
          return [0, 100, t3[0]];
        }, a2.gray.cmyk = function(t3) {
          return [0, 0, 0, t3[0]];
        }, a2.gray.lab = function(t3) {
          return [t3[0], 0, 0];
        }, a2.gray.hex = function(t3) {
          var e2 = 255 & Math.round(t3[0] / 100 * 255), n3 = ((e2 << 16) + (e2 << 8) + e2).toString(16).toUpperCase();
          return "000000".substring(n3.length) + n3;
        }, a2.rgb.gray = function(t3) {
          return [(t3[0] + t3[1] + t3[2]) / 3 / 255 * 100];
        };
      });
      n.rgb, n.hsl, n.hsv, n.hwb, n.cmyk, n.xyz, n.lab, n.lch, n.hex, n.keyword, n.ansi16, n.ansi256, n.hcg, n.apple, n.gray;
      function i(t2) {
        var e2 = function() {
          for (var t3 = {}, e3 = Object.keys(n), i3 = e3.length, a3 = 0; a3 < i3; a3++) t3[e3[a3]] = { distance: -1, parent: null };
          return t3;
        }(), i2 = [t2];
        for (e2[t2].distance = 0; i2.length; ) for (var a2 = i2.pop(), r2 = Object.keys(n[a2]), o2 = r2.length, s2 = 0; s2 < o2; s2++) {
          var l2 = r2[s2], u2 = e2[l2];
          -1 === u2.distance && (u2.distance = e2[a2].distance + 1, u2.parent = a2, i2.unshift(l2));
        }
        return e2;
      }
      function a(t2, e2) {
        return function(n2) {
          return e2(t2(n2));
        };
      }
      function r(t2, e2) {
        for (var i2 = [e2[t2].parent, t2], r2 = n[e2[t2].parent][t2], o2 = e2[t2].parent; e2[o2].parent; ) i2.unshift(e2[o2].parent), r2 = a(n[e2[o2].parent][o2], r2), o2 = e2[o2].parent;
        return r2.conversion = i2, r2;
      }
      var o = {};
      Object.keys(n).forEach(function(t2) {
        o[t2] = {}, Object.defineProperty(o[t2], "channels", { value: n[t2].channels }), Object.defineProperty(o[t2], "labels", { value: n[t2].labels });
        var e2 = function(t3) {
          for (var e3 = i(t3), n2 = {}, a2 = Object.keys(e3), o2 = a2.length, s2 = 0; s2 < o2; s2++) {
            var l2 = a2[s2];
            null !== e3[l2].parent && (n2[l2] = r(l2, e3));
          }
          return n2;
        }(t2);
        Object.keys(e2).forEach(function(n2) {
          var i2 = e2[n2];
          o[t2][n2] = function(t3) {
            var e3 = function(e4) {
              if (null == e4) return e4;
              arguments.length > 1 && (e4 = Array.prototype.slice.call(arguments));
              var n3 = t3(e4);
              if ("object" == typeof n3) for (var i3 = n3.length, a2 = 0; a2 < i3; a2++) n3[a2] = Math.round(n3[a2]);
              return n3;
            };
            return "conversion" in t3 && (e3.conversion = t3.conversion), e3;
          }(i2), o[t2][n2].raw = function(t3) {
            var e3 = function(e4) {
              return null == e4 ? e4 : (arguments.length > 1 && (e4 = Array.prototype.slice.call(arguments)), t3(e4));
            };
            return "conversion" in t3 && (e3.conversion = t3.conversion), e3;
          }(i2);
        });
      });
      var s = o, l = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, u = { getRgba: d, getHsla: h, getRgb: function(t2) {
        var e2 = d(t2);
        return e2 && e2.slice(0, 3);
      }, getHsl: function(t2) {
        var e2 = h(t2);
        return e2 && e2.slice(0, 3);
      }, getHwb: c, getAlpha: function(t2) {
        var e2 = d(t2);
        if (e2) return e2[3];
        if (e2 = h(t2)) return e2[3];
        if (e2 = c(t2)) return e2[3];
      }, hexString: function(t2, e2) {
        e2 = void 0 !== e2 && 3 === t2.length ? e2 : t2[3];
        return "#" + v(t2[0]) + v(t2[1]) + v(t2[2]) + (e2 >= 0 && e2 < 1 ? v(Math.round(255 * e2)) : "");
      }, rgbString: function(t2, e2) {
        if (e2 < 1 || t2[3] && t2[3] < 1) return f(t2, e2);
        return "rgb(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ")";
      }, rgbaString: f, percentString: function(t2, e2) {
        if (e2 < 1 || t2[3] && t2[3] < 1) return g(t2, e2);
        var n2 = Math.round(t2[0] / 255 * 100), i2 = Math.round(t2[1] / 255 * 100), a2 = Math.round(t2[2] / 255 * 100);
        return "rgb(" + n2 + "%, " + i2 + "%, " + a2 + "%)";
      }, percentaString: g, hslString: function(t2, e2) {
        if (e2 < 1 || t2[3] && t2[3] < 1) return p(t2, e2);
        return "hsl(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%)";
      }, hslaString: p, hwbString: function(t2, e2) {
        void 0 === e2 && (e2 = void 0 !== t2[3] ? t2[3] : 1);
        return "hwb(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%" + (void 0 !== e2 && 1 !== e2 ? ", " + e2 : "") + ")";
      }, keyword: function(t2) {
        return b[t2.slice(0, 3)];
      } };
      function d(t2) {
        if (t2) {
          var e2 = [0, 0, 0], n2 = 1, i2 = t2.match(/^#([a-fA-F0-9]{3,4})$/i), a2 = "";
          if (i2) {
            a2 = (i2 = i2[1])[3];
            for (var r2 = 0; r2 < e2.length; r2++) e2[r2] = parseInt(i2[r2] + i2[r2], 16);
            a2 && (n2 = Math.round(parseInt(a2 + a2, 16) / 255 * 100) / 100);
          } else if (i2 = t2.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)) {
            a2 = i2[2], i2 = i2[1];
            for (r2 = 0; r2 < e2.length; r2++) e2[r2] = parseInt(i2.slice(2 * r2, 2 * r2 + 2), 16);
            a2 && (n2 = Math.round(parseInt(a2, 16) / 255 * 100) / 100);
          } else if (i2 = t2.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
            for (r2 = 0; r2 < e2.length; r2++) e2[r2] = parseInt(i2[r2 + 1]);
            n2 = parseFloat(i2[4]);
          } else if (i2 = t2.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
            for (r2 = 0; r2 < e2.length; r2++) e2[r2] = Math.round(2.55 * parseFloat(i2[r2 + 1]));
            n2 = parseFloat(i2[4]);
          } else if (i2 = t2.match(/(\w+)/)) {
            if ("transparent" == i2[1]) return [0, 0, 0, 0];
            if (!(e2 = l[i2[1]])) return;
          }
          for (r2 = 0; r2 < e2.length; r2++) e2[r2] = m(e2[r2], 0, 255);
          return n2 = n2 || 0 == n2 ? m(n2, 0, 1) : 1, e2[3] = n2, e2;
        }
      }
      function h(t2) {
        if (t2) {
          var e2 = t2.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
          if (e2) {
            var n2 = parseFloat(e2[4]);
            return [m(parseInt(e2[1]), 0, 360), m(parseFloat(e2[2]), 0, 100), m(parseFloat(e2[3]), 0, 100), m(isNaN(n2) ? 1 : n2, 0, 1)];
          }
        }
      }
      function c(t2) {
        if (t2) {
          var e2 = t2.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
          if (e2) {
            var n2 = parseFloat(e2[4]);
            return [m(parseInt(e2[1]), 0, 360), m(parseFloat(e2[2]), 0, 100), m(parseFloat(e2[3]), 0, 100), m(isNaN(n2) ? 1 : n2, 0, 1)];
          }
        }
      }
      function f(t2, e2) {
        return void 0 === e2 && (e2 = void 0 !== t2[3] ? t2[3] : 1), "rgba(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + e2 + ")";
      }
      function g(t2, e2) {
        return "rgba(" + Math.round(t2[0] / 255 * 100) + "%, " + Math.round(t2[1] / 255 * 100) + "%, " + Math.round(t2[2] / 255 * 100) + "%, " + (e2 || t2[3] || 1) + ")";
      }
      function p(t2, e2) {
        return void 0 === e2 && (e2 = void 0 !== t2[3] ? t2[3] : 1), "hsla(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%, " + e2 + ")";
      }
      function m(t2, e2, n2) {
        return Math.min(Math.max(e2, t2), n2);
      }
      function v(t2) {
        var e2 = t2.toString(16).toUpperCase();
        return e2.length < 2 ? "0" + e2 : e2;
      }
      var b = {};
      for (var x in l) b[l[x]] = x;
      var y = function(t2) {
        return t2 instanceof y ? t2 : this instanceof y ? (this.valid = false, this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 }, void ("string" == typeof t2 ? (e2 = u.getRgba(t2)) ? this.setValues("rgb", e2) : (e2 = u.getHsla(t2)) ? this.setValues("hsl", e2) : (e2 = u.getHwb(t2)) && this.setValues("hwb", e2) : "object" == typeof t2 && (void 0 !== (e2 = t2).r || void 0 !== e2.red ? this.setValues("rgb", e2) : void 0 !== e2.l || void 0 !== e2.lightness ? this.setValues("hsl", e2) : void 0 !== e2.v || void 0 !== e2.value ? this.setValues("hsv", e2) : void 0 !== e2.w || void 0 !== e2.whiteness ? this.setValues("hwb", e2) : void 0 === e2.c && void 0 === e2.cyan || this.setValues("cmyk", e2)))) : new y(t2);
        var e2;
      };
      y.prototype = { isValid: function() {
        return this.valid;
      }, rgb: function() {
        return this.setSpace("rgb", arguments);
      }, hsl: function() {
        return this.setSpace("hsl", arguments);
      }, hsv: function() {
        return this.setSpace("hsv", arguments);
      }, hwb: function() {
        return this.setSpace("hwb", arguments);
      }, cmyk: function() {
        return this.setSpace("cmyk", arguments);
      }, rgbArray: function() {
        return this.values.rgb;
      }, hslArray: function() {
        return this.values.hsl;
      }, hsvArray: function() {
        return this.values.hsv;
      }, hwbArray: function() {
        var t2 = this.values;
        return 1 !== t2.alpha ? t2.hwb.concat([t2.alpha]) : t2.hwb;
      }, cmykArray: function() {
        return this.values.cmyk;
      }, rgbaArray: function() {
        var t2 = this.values;
        return t2.rgb.concat([t2.alpha]);
      }, hslaArray: function() {
        var t2 = this.values;
        return t2.hsl.concat([t2.alpha]);
      }, alpha: function(t2) {
        return void 0 === t2 ? this.values.alpha : (this.setValues("alpha", t2), this);
      }, red: function(t2) {
        return this.setChannel("rgb", 0, t2);
      }, green: function(t2) {
        return this.setChannel("rgb", 1, t2);
      }, blue: function(t2) {
        return this.setChannel("rgb", 2, t2);
      }, hue: function(t2) {
        return t2 && (t2 = (t2 %= 360) < 0 ? 360 + t2 : t2), this.setChannel("hsl", 0, t2);
      }, saturation: function(t2) {
        return this.setChannel("hsl", 1, t2);
      }, lightness: function(t2) {
        return this.setChannel("hsl", 2, t2);
      }, saturationv: function(t2) {
        return this.setChannel("hsv", 1, t2);
      }, whiteness: function(t2) {
        return this.setChannel("hwb", 1, t2);
      }, blackness: function(t2) {
        return this.setChannel("hwb", 2, t2);
      }, value: function(t2) {
        return this.setChannel("hsv", 2, t2);
      }, cyan: function(t2) {
        return this.setChannel("cmyk", 0, t2);
      }, magenta: function(t2) {
        return this.setChannel("cmyk", 1, t2);
      }, yellow: function(t2) {
        return this.setChannel("cmyk", 2, t2);
      }, black: function(t2) {
        return this.setChannel("cmyk", 3, t2);
      }, hexString: function() {
        return u.hexString(this.values.rgb);
      }, rgbString: function() {
        return u.rgbString(this.values.rgb, this.values.alpha);
      }, rgbaString: function() {
        return u.rgbaString(this.values.rgb, this.values.alpha);
      }, percentString: function() {
        return u.percentString(this.values.rgb, this.values.alpha);
      }, hslString: function() {
        return u.hslString(this.values.hsl, this.values.alpha);
      }, hslaString: function() {
        return u.hslaString(this.values.hsl, this.values.alpha);
      }, hwbString: function() {
        return u.hwbString(this.values.hwb, this.values.alpha);
      }, keyword: function() {
        return u.keyword(this.values.rgb, this.values.alpha);
      }, rgbNumber: function() {
        var t2 = this.values.rgb;
        return t2[0] << 16 | t2[1] << 8 | t2[2];
      }, luminosity: function() {
        for (var t2 = this.values.rgb, e2 = [], n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2] / 255;
          e2[n2] = i2 <= 0.03928 ? i2 / 12.92 : Math.pow((i2 + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * e2[0] + 0.7152 * e2[1] + 0.0722 * e2[2];
      }, contrast: function(t2) {
        var e2 = this.luminosity(), n2 = t2.luminosity();
        return e2 > n2 ? (e2 + 0.05) / (n2 + 0.05) : (n2 + 0.05) / (e2 + 0.05);
      }, level: function(t2) {
        var e2 = this.contrast(t2);
        return e2 >= 7.1 ? "AAA" : e2 >= 4.5 ? "AA" : "";
      }, dark: function() {
        var t2 = this.values.rgb;
        return (299 * t2[0] + 587 * t2[1] + 114 * t2[2]) / 1e3 < 128;
      }, light: function() {
        return !this.dark();
      }, negate: function() {
        for (var t2 = [], e2 = 0; e2 < 3; e2++) t2[e2] = 255 - this.values.rgb[e2];
        return this.setValues("rgb", t2), this;
      }, lighten: function(t2) {
        var e2 = this.values.hsl;
        return e2[2] += e2[2] * t2, this.setValues("hsl", e2), this;
      }, darken: function(t2) {
        var e2 = this.values.hsl;
        return e2[2] -= e2[2] * t2, this.setValues("hsl", e2), this;
      }, saturate: function(t2) {
        var e2 = this.values.hsl;
        return e2[1] += e2[1] * t2, this.setValues("hsl", e2), this;
      }, desaturate: function(t2) {
        var e2 = this.values.hsl;
        return e2[1] -= e2[1] * t2, this.setValues("hsl", e2), this;
      }, whiten: function(t2) {
        var e2 = this.values.hwb;
        return e2[1] += e2[1] * t2, this.setValues("hwb", e2), this;
      }, blacken: function(t2) {
        var e2 = this.values.hwb;
        return e2[2] += e2[2] * t2, this.setValues("hwb", e2), this;
      }, greyscale: function() {
        var t2 = this.values.rgb, e2 = 0.3 * t2[0] + 0.59 * t2[1] + 0.11 * t2[2];
        return this.setValues("rgb", [e2, e2, e2]), this;
      }, clearer: function(t2) {
        var e2 = this.values.alpha;
        return this.setValues("alpha", e2 - e2 * t2), this;
      }, opaquer: function(t2) {
        var e2 = this.values.alpha;
        return this.setValues("alpha", e2 + e2 * t2), this;
      }, rotate: function(t2) {
        var e2 = this.values.hsl, n2 = (e2[0] + t2) % 360;
        return e2[0] = n2 < 0 ? 360 + n2 : n2, this.setValues("hsl", e2), this;
      }, mix: function(t2, e2) {
        var n2 = t2, i2 = void 0 === e2 ? 0.5 : e2, a2 = 2 * i2 - 1, r2 = this.alpha() - n2.alpha(), o2 = ((a2 * r2 == -1 ? a2 : (a2 + r2) / (1 + a2 * r2)) + 1) / 2, s2 = 1 - o2;
        return this.rgb(o2 * this.red() + s2 * n2.red(), o2 * this.green() + s2 * n2.green(), o2 * this.blue() + s2 * n2.blue()).alpha(this.alpha() * i2 + n2.alpha() * (1 - i2));
      }, toJSON: function() {
        return this.rgb();
      }, clone: function() {
        var t2, e2, n2 = new y(), i2 = this.values, a2 = n2.values;
        for (var r2 in i2) i2.hasOwnProperty(r2) && (t2 = i2[r2], "[object Array]" === (e2 = {}.toString.call(t2)) ? a2[r2] = t2.slice(0) : "[object Number]" === e2 ? a2[r2] = t2 : console.error("unexpected color value:", t2));
        return n2;
      } }, y.prototype.spaces = { rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"] }, y.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] }, y.prototype.getValues = function(t2) {
        for (var e2 = this.values, n2 = {}, i2 = 0; i2 < t2.length; i2++) n2[t2.charAt(i2)] = e2[t2][i2];
        return 1 !== e2.alpha && (n2.a = e2.alpha), n2;
      }, y.prototype.setValues = function(t2, e2) {
        var n2, i2, a2 = this.values, r2 = this.spaces, o2 = this.maxes, l2 = 1;
        if (this.valid = true, "alpha" === t2) l2 = e2;
        else if (e2.length) a2[t2] = e2.slice(0, t2.length), l2 = e2[t2.length];
        else if (void 0 !== e2[t2.charAt(0)]) {
          for (n2 = 0; n2 < t2.length; n2++) a2[t2][n2] = e2[t2.charAt(n2)];
          l2 = e2.a;
        } else if (void 0 !== e2[r2[t2][0]]) {
          var u2 = r2[t2];
          for (n2 = 0; n2 < t2.length; n2++) a2[t2][n2] = e2[u2[n2]];
          l2 = e2.alpha;
        }
        if (a2.alpha = Math.max(0, Math.min(1, void 0 === l2 ? a2.alpha : l2)), "alpha" === t2) return false;
        for (n2 = 0; n2 < t2.length; n2++) i2 = Math.max(0, Math.min(o2[t2][n2], a2[t2][n2])), a2[t2][n2] = Math.round(i2);
        for (var d2 in r2) d2 !== t2 && (a2[d2] = s[t2][d2](a2[t2]));
        return true;
      }, y.prototype.setSpace = function(t2, e2) {
        var n2 = e2[0];
        return void 0 === n2 ? this.getValues(t2) : ("number" == typeof n2 && (n2 = Array.prototype.slice.call(e2)), this.setValues(t2, n2), this);
      }, y.prototype.setChannel = function(t2, e2, n2) {
        var i2 = this.values[t2];
        return void 0 === n2 ? i2[e2] : n2 === i2[e2] ? this : (i2[e2] = n2, this.setValues(t2, i2), this);
      }, "undefined" != typeof window && (window.Color = y);
      var _ = y;
      function k(t2) {
        return -1 === ["__proto__", "prototype", "constructor"].indexOf(t2);
      }
      var w, M = { noop: function() {
      }, uid: (w = 0, function() {
        return w++;
      }), isNullOrUndef: function(t2) {
        return null == t2;
      }, isArray: function(t2) {
        if (Array.isArray && Array.isArray(t2)) return true;
        var e2 = Object.prototype.toString.call(t2);
        return "[object" === e2.substr(0, 7) && "Array]" === e2.substr(-6);
      }, isObject: function(t2) {
        return null !== t2 && "[object Object]" === Object.prototype.toString.call(t2);
      }, isFinite: function(t2) {
        return ("number" == typeof t2 || t2 instanceof Number) && isFinite(t2);
      }, valueOrDefault: function(t2, e2) {
        return void 0 === t2 ? e2 : t2;
      }, valueAtIndexOrDefault: function(t2, e2, n2) {
        return M.valueOrDefault(M.isArray(t2) ? t2[e2] : t2, n2);
      }, callback: function(t2, e2, n2) {
        if (t2 && "function" == typeof t2.call) return t2.apply(n2, e2);
      }, each: function(t2, e2, n2, i2) {
        var a2, r2, o2;
        if (M.isArray(t2)) if (r2 = t2.length, i2) for (a2 = r2 - 1; a2 >= 0; a2--) e2.call(n2, t2[a2], a2);
        else for (a2 = 0; a2 < r2; a2++) e2.call(n2, t2[a2], a2);
        else if (M.isObject(t2)) for (r2 = (o2 = Object.keys(t2)).length, a2 = 0; a2 < r2; a2++) e2.call(n2, t2[o2[a2]], o2[a2]);
      }, arrayEquals: function(t2, e2) {
        var n2, i2, a2, r2;
        if (!t2 || !e2 || t2.length !== e2.length) return false;
        for (n2 = 0, i2 = t2.length; n2 < i2; ++n2) if (a2 = t2[n2], r2 = e2[n2], a2 instanceof Array && r2 instanceof Array) {
          if (!M.arrayEquals(a2, r2)) return false;
        } else if (a2 !== r2) return false;
        return true;
      }, clone: function(t2) {
        if (M.isArray(t2)) return t2.map(M.clone);
        if (M.isObject(t2)) {
          for (var e2 = Object.create(t2), n2 = Object.keys(t2), i2 = n2.length, a2 = 0; a2 < i2; ++a2) e2[n2[a2]] = M.clone(t2[n2[a2]]);
          return e2;
        }
        return t2;
      }, _merger: function(t2, e2, n2, i2) {
        if (k(t2)) {
          var a2 = e2[t2], r2 = n2[t2];
          M.isObject(a2) && M.isObject(r2) ? M.merge(a2, r2, i2) : e2[t2] = M.clone(r2);
        }
      }, _mergerIf: function(t2, e2, n2) {
        if (k(t2)) {
          var i2 = e2[t2], a2 = n2[t2];
          M.isObject(i2) && M.isObject(a2) ? M.mergeIf(i2, a2) : e2.hasOwnProperty(t2) || (e2[t2] = M.clone(a2));
        }
      }, merge: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2 = M.isArray(e2) ? e2 : [e2], u2 = l2.length;
        if (!M.isObject(t2)) return t2;
        for (i2 = (n2 = n2 || {}).merger || M._merger, a2 = 0; a2 < u2; ++a2) if (e2 = l2[a2], M.isObject(e2)) for (s2 = 0, o2 = (r2 = Object.keys(e2)).length; s2 < o2; ++s2) i2(r2[s2], t2, e2, n2);
        return t2;
      }, mergeIf: function(t2, e2) {
        return M.merge(t2, e2, { merger: M._mergerIf });
      }, extend: Object.assign || function(t2) {
        return M.merge(t2, [].slice.call(arguments, 1), { merger: function(t3, e2, n2) {
          e2[t3] = n2[t3];
        } });
      }, inherits: function(t2) {
        var e2 = this, n2 = t2 && t2.hasOwnProperty("constructor") ? t2.constructor : function() {
          return e2.apply(this, arguments);
        }, i2 = function() {
          this.constructor = n2;
        };
        return i2.prototype = e2.prototype, n2.prototype = new i2(), n2.extend = M.inherits, t2 && M.extend(n2.prototype, t2), n2.__super__ = e2.prototype, n2;
      }, _deprecated: function(t2, e2, n2, i2) {
        void 0 !== e2 && console.warn(t2 + ': "' + n2 + '" is deprecated. Please use "' + i2 + '" instead');
      } }, S = M;
      M.callCallback = M.callback, M.indexOf = function(t2, e2, n2) {
        return Array.prototype.indexOf.call(t2, e2, n2);
      }, M.getValueOrDefault = M.valueOrDefault, M.getValueAtIndexOrDefault = M.valueAtIndexOrDefault;
      var C = { linear: function(t2) {
        return t2;
      }, easeInQuad: function(t2) {
        return t2 * t2;
      }, easeOutQuad: function(t2) {
        return -t2 * (t2 - 2);
      }, easeInOutQuad: function(t2) {
        return (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1);
      }, easeInCubic: function(t2) {
        return t2 * t2 * t2;
      }, easeOutCubic: function(t2) {
        return (t2 -= 1) * t2 * t2 + 1;
      }, easeInOutCubic: function(t2) {
        return (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2);
      }, easeInQuart: function(t2) {
        return t2 * t2 * t2 * t2;
      }, easeOutQuart: function(t2) {
        return -((t2 -= 1) * t2 * t2 * t2 - 1);
      }, easeInOutQuart: function(t2) {
        return (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2);
      }, easeInQuint: function(t2) {
        return t2 * t2 * t2 * t2 * t2;
      }, easeOutQuint: function(t2) {
        return (t2 -= 1) * t2 * t2 * t2 * t2 + 1;
      }, easeInOutQuint: function(t2) {
        return (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2);
      }, easeInSine: function(t2) {
        return 1 - Math.cos(t2 * (Math.PI / 2));
      }, easeOutSine: function(t2) {
        return Math.sin(t2 * (Math.PI / 2));
      }, easeInOutSine: function(t2) {
        return -0.5 * (Math.cos(Math.PI * t2) - 1);
      }, easeInExpo: function(t2) {
        return 0 === t2 ? 0 : Math.pow(2, 10 * (t2 - 1));
      }, easeOutExpo: function(t2) {
        return 1 === t2 ? 1 : 1 - Math.pow(2, -10 * t2);
      }, easeInOutExpo: function(t2) {
        return 0 === t2 ? 0 : 1 === t2 ? 1 : (t2 /= 0.5) < 1 ? 0.5 * Math.pow(2, 10 * (t2 - 1)) : 0.5 * (2 - Math.pow(2, -10 * --t2));
      }, easeInCirc: function(t2) {
        return t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1);
      }, easeOutCirc: function(t2) {
        return Math.sqrt(1 - (t2 -= 1) * t2);
      }, easeInOutCirc: function(t2) {
        return (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
      }, easeInElastic: function(t2) {
        var e2 = 1.70158, n2 = 0, i2 = 1;
        return 0 === t2 ? 0 : 1 === t2 ? 1 : (n2 || (n2 = 0.3), i2 < 1 ? (i2 = 1, e2 = n2 / 4) : e2 = n2 / (2 * Math.PI) * Math.asin(1 / i2), -i2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - e2) * (2 * Math.PI) / n2));
      }, easeOutElastic: function(t2) {
        var e2 = 1.70158, n2 = 0, i2 = 1;
        return 0 === t2 ? 0 : 1 === t2 ? 1 : (n2 || (n2 = 0.3), i2 < 1 ? (i2 = 1, e2 = n2 / 4) : e2 = n2 / (2 * Math.PI) * Math.asin(1 / i2), i2 * Math.pow(2, -10 * t2) * Math.sin((t2 - e2) * (2 * Math.PI) / n2) + 1);
      }, easeInOutElastic: function(t2) {
        var e2 = 1.70158, n2 = 0, i2 = 1;
        return 0 === t2 ? 0 : 2 == (t2 /= 0.5) ? 1 : (n2 || (n2 = 0.45), i2 < 1 ? (i2 = 1, e2 = n2 / 4) : e2 = n2 / (2 * Math.PI) * Math.asin(1 / i2), t2 < 1 ? i2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - e2) * (2 * Math.PI) / n2) * -0.5 : i2 * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 - e2) * (2 * Math.PI) / n2) * 0.5 + 1);
      }, easeInBack: function(t2) {
        var e2 = 1.70158;
        return t2 * t2 * ((e2 + 1) * t2 - e2);
      }, easeOutBack: function(t2) {
        var e2 = 1.70158;
        return (t2 -= 1) * t2 * ((e2 + 1) * t2 + e2) + 1;
      }, easeInOutBack: function(t2) {
        var e2 = 1.70158;
        return (t2 /= 0.5) < 1 ? t2 * t2 * ((1 + (e2 *= 1.525)) * t2 - e2) * 0.5 : 0.5 * ((t2 -= 2) * t2 * ((1 + (e2 *= 1.525)) * t2 + e2) + 2);
      }, easeInBounce: function(t2) {
        return 1 - C.easeOutBounce(1 - t2);
      }, easeOutBounce: function(t2) {
        return t2 < 1 / 2.75 ? 7.5625 * t2 * t2 : t2 < 2 / 2.75 ? 7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75 : t2 < 2.5 / 2.75 ? 7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375 : 7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375;
      }, easeInOutBounce: function(t2) {
        return t2 < 0.5 ? 0.5 * C.easeInBounce(2 * t2) : 0.5 * C.easeOutBounce(2 * t2 - 1) + 0.5;
      } }, P = { effects: C };
      S.easingEffects = C;
      var A = Math.PI, D = A / 180, T = 2 * A, I = A / 2, F = A / 4, O = 2 * A / 3, L = { clear: function(t2) {
        t2.ctx.clearRect(0, 0, t2.width, t2.height);
      }, roundedRect: function(t2, e2, n2, i2, a2, r2) {
        if (r2) {
          var o2 = Math.min(r2, a2 / 2, i2 / 2), s2 = e2 + o2, l2 = n2 + o2, u2 = e2 + i2 - o2, d2 = n2 + a2 - o2;
          t2.moveTo(e2, l2), s2 < u2 && l2 < d2 ? (t2.arc(s2, l2, o2, -A, -I), t2.arc(u2, l2, o2, -I, 0), t2.arc(u2, d2, o2, 0, I), t2.arc(s2, d2, o2, I, A)) : s2 < u2 ? (t2.moveTo(s2, n2), t2.arc(u2, l2, o2, -I, I), t2.arc(s2, l2, o2, I, A + I)) : l2 < d2 ? (t2.arc(s2, l2, o2, -A, 0), t2.arc(s2, d2, o2, 0, A)) : t2.arc(s2, l2, o2, -A, A), t2.closePath(), t2.moveTo(e2, n2);
        } else t2.rect(e2, n2, i2, a2);
      }, drawPoint: function(t2, e2, n2, i2, a2, r2) {
        var o2, s2, l2, u2, d2, h2 = (r2 || 0) * D;
        if (e2 && "object" == typeof e2 && ("[object HTMLImageElement]" === (o2 = e2.toString()) || "[object HTMLCanvasElement]" === o2)) return t2.save(), t2.translate(i2, a2), t2.rotate(h2), t2.drawImage(e2, -e2.width / 2, -e2.height / 2, e2.width, e2.height), void t2.restore();
        if (!(isNaN(n2) || n2 <= 0)) {
          switch (t2.beginPath(), e2) {
            default:
              t2.arc(i2, a2, n2, 0, T), t2.closePath();
              break;
            case "triangle":
              t2.moveTo(i2 + Math.sin(h2) * n2, a2 - Math.cos(h2) * n2), h2 += O, t2.lineTo(i2 + Math.sin(h2) * n2, a2 - Math.cos(h2) * n2), h2 += O, t2.lineTo(i2 + Math.sin(h2) * n2, a2 - Math.cos(h2) * n2), t2.closePath();
              break;
            case "rectRounded":
              u2 = n2 - (d2 = 0.516 * n2), s2 = Math.cos(h2 + F) * u2, l2 = Math.sin(h2 + F) * u2, t2.arc(i2 - s2, a2 - l2, d2, h2 - A, h2 - I), t2.arc(i2 + l2, a2 - s2, d2, h2 - I, h2), t2.arc(i2 + s2, a2 + l2, d2, h2, h2 + I), t2.arc(i2 - l2, a2 + s2, d2, h2 + I, h2 + A), t2.closePath();
              break;
            case "rect":
              if (!r2) {
                u2 = Math.SQRT1_2 * n2, t2.rect(i2 - u2, a2 - u2, 2 * u2, 2 * u2);
                break;
              }
              h2 += F;
            case "rectRot":
              s2 = Math.cos(h2) * n2, l2 = Math.sin(h2) * n2, t2.moveTo(i2 - s2, a2 - l2), t2.lineTo(i2 + l2, a2 - s2), t2.lineTo(i2 + s2, a2 + l2), t2.lineTo(i2 - l2, a2 + s2), t2.closePath();
              break;
            case "crossRot":
              h2 += F;
            case "cross":
              s2 = Math.cos(h2) * n2, l2 = Math.sin(h2) * n2, t2.moveTo(i2 - s2, a2 - l2), t2.lineTo(i2 + s2, a2 + l2), t2.moveTo(i2 + l2, a2 - s2), t2.lineTo(i2 - l2, a2 + s2);
              break;
            case "star":
              s2 = Math.cos(h2) * n2, l2 = Math.sin(h2) * n2, t2.moveTo(i2 - s2, a2 - l2), t2.lineTo(i2 + s2, a2 + l2), t2.moveTo(i2 + l2, a2 - s2), t2.lineTo(i2 - l2, a2 + s2), h2 += F, s2 = Math.cos(h2) * n2, l2 = Math.sin(h2) * n2, t2.moveTo(i2 - s2, a2 - l2), t2.lineTo(i2 + s2, a2 + l2), t2.moveTo(i2 + l2, a2 - s2), t2.lineTo(i2 - l2, a2 + s2);
              break;
            case "line":
              s2 = Math.cos(h2) * n2, l2 = Math.sin(h2) * n2, t2.moveTo(i2 - s2, a2 - l2), t2.lineTo(i2 + s2, a2 + l2);
              break;
            case "dash":
              t2.moveTo(i2, a2), t2.lineTo(i2 + Math.cos(h2) * n2, a2 + Math.sin(h2) * n2);
          }
          t2.fill(), t2.stroke();
        }
      }, _isPointInArea: function(t2, e2) {
        return t2.x > e2.left - 1e-6 && t2.x < e2.right + 1e-6 && t2.y > e2.top - 1e-6 && t2.y < e2.bottom + 1e-6;
      }, clipArea: function(t2, e2) {
        t2.save(), t2.beginPath(), t2.rect(e2.left, e2.top, e2.right - e2.left, e2.bottom - e2.top), t2.clip();
      }, unclipArea: function(t2) {
        t2.restore();
      }, lineTo: function(t2, e2, n2, i2) {
        var a2 = n2.steppedLine;
        if (a2) {
          if ("middle" === a2) {
            var r2 = (e2.x + n2.x) / 2;
            t2.lineTo(r2, i2 ? n2.y : e2.y), t2.lineTo(r2, i2 ? e2.y : n2.y);
          } else "after" === a2 && !i2 || "after" !== a2 && i2 ? t2.lineTo(e2.x, n2.y) : t2.lineTo(n2.x, e2.y);
          t2.lineTo(n2.x, n2.y);
        } else n2.tension ? t2.bezierCurveTo(i2 ? e2.controlPointPreviousX : e2.controlPointNextX, i2 ? e2.controlPointPreviousY : e2.controlPointNextY, i2 ? n2.controlPointNextX : n2.controlPointPreviousX, i2 ? n2.controlPointNextY : n2.controlPointPreviousY, n2.x, n2.y) : t2.lineTo(n2.x, n2.y);
      } }, R = L;
      S.clear = L.clear, S.drawRoundedRectangle = function(t2) {
        t2.beginPath(), L.roundedRect.apply(L, arguments);
      };
      var z = { _set: function(t2, e2) {
        return S.merge(this[t2] || (this[t2] = {}), e2);
      } };
      z._set("global", { defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", defaultLineHeight: 1.2, showLines: true });
      var N = z, B = S.valueOrDefault;
      var E = { toLineHeight: function(t2, e2) {
        var n2 = ("" + t2).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        if (!n2 || "normal" === n2[1]) return 1.2 * e2;
        switch (t2 = +n2[2], n2[3]) {
          case "px":
            return t2;
          case "%":
            t2 /= 100;
        }
        return e2 * t2;
      }, toPadding: function(t2) {
        var e2, n2, i2, a2;
        return S.isObject(t2) ? (e2 = +t2.top || 0, n2 = +t2.right || 0, i2 = +t2.bottom || 0, a2 = +t2.left || 0) : e2 = n2 = i2 = a2 = +t2 || 0, { top: e2, right: n2, bottom: i2, left: a2, height: e2 + i2, width: a2 + n2 };
      }, _parseFont: function(t2) {
        var e2 = N.global, n2 = B(t2.fontSize, e2.defaultFontSize), i2 = { family: B(t2.fontFamily, e2.defaultFontFamily), lineHeight: S.options.toLineHeight(B(t2.lineHeight, e2.defaultLineHeight), n2), size: n2, style: B(t2.fontStyle, e2.defaultFontStyle), weight: null, string: "" };
        return i2.string = function(t3) {
          return !t3 || S.isNullOrUndef(t3.size) || S.isNullOrUndef(t3.family) ? null : (t3.style ? t3.style + " " : "") + (t3.weight ? t3.weight + " " : "") + t3.size + "px " + t3.family;
        }(i2), i2;
      }, resolve: function(t2, e2, n2, i2) {
        var a2, r2, o2, s2 = true;
        for (a2 = 0, r2 = t2.length; a2 < r2; ++a2) if (void 0 !== (o2 = t2[a2]) && (void 0 !== e2 && "function" == typeof o2 && (o2 = o2(e2), s2 = false), void 0 !== n2 && S.isArray(o2) && (o2 = o2[n2], s2 = false), void 0 !== o2)) return i2 && !s2 && (i2.cacheable = false), o2;
      } }, W = { _factorize: function(t2) {
        var e2, n2 = [], i2 = Math.sqrt(t2);
        for (e2 = 1; e2 < i2; e2++) t2 % e2 == 0 && (n2.push(e2), n2.push(t2 / e2));
        return i2 === (0 | i2) && n2.push(i2), n2.sort(function(t3, e3) {
          return t3 - e3;
        }).pop(), n2;
      }, log10: Math.log10 || function(t2) {
        var e2 = Math.log(t2) * Math.LOG10E, n2 = Math.round(e2);
        return t2 === Math.pow(10, n2) ? n2 : e2;
      } }, V = W;
      S.log10 = W.log10;
      var H = S, j = P, q = R, U = E, Y = V, G = { getRtlAdapter: function(t2, e2, n2) {
        return t2 ? /* @__PURE__ */ function(t3, e3) {
          return { x: function(n3) {
            return t3 + t3 + e3 - n3;
          }, setWidth: function(t4) {
            e3 = t4;
          }, textAlign: function(t4) {
            return "center" === t4 ? t4 : "right" === t4 ? "left" : "right";
          }, xPlus: function(t4, e4) {
            return t4 - e4;
          }, leftForLtr: function(t4, e4) {
            return t4 - e4;
          } };
        }(e2, n2) : { x: function(t3) {
          return t3;
        }, setWidth: function(t3) {
        }, textAlign: function(t3) {
          return t3;
        }, xPlus: function(t3, e3) {
          return t3 + e3;
        }, leftForLtr: function(t3, e3) {
          return t3;
        } };
      }, overrideTextDirection: function(t2, e2) {
        var n2, i2;
        "ltr" !== e2 && "rtl" !== e2 || (i2 = [(n2 = t2.canvas.style).getPropertyValue("direction"), n2.getPropertyPriority("direction")], n2.setProperty("direction", e2, "important"), t2.prevTextDirection = i2);
      }, restoreTextDirection: function(t2) {
        var e2 = t2.prevTextDirection;
        void 0 !== e2 && (delete t2.prevTextDirection, t2.canvas.style.setProperty("direction", e2[0], e2[1]));
      } };
      H.easing = j, H.canvas = q, H.options = U, H.math = Y, H.rtl = G;
      var X = function(t2) {
        H.extend(this, t2), this.initialize.apply(this, arguments);
      };
      H.extend(X.prototype, { _type: void 0, initialize: function() {
        this.hidden = false;
      }, pivot: function() {
        var t2 = this;
        return t2._view || (t2._view = H.extend({}, t2._model)), t2._start = {}, t2;
      }, transition: function(t2) {
        var e2 = this, n2 = e2._model, i2 = e2._start, a2 = e2._view;
        return n2 && 1 !== t2 ? (a2 || (a2 = e2._view = {}), i2 || (i2 = e2._start = {}), function(t3, e3, n3, i3) {
          var a3, r2, o2, s2, l2, u2, d2, h2, c2, f2 = Object.keys(n3);
          for (a3 = 0, r2 = f2.length; a3 < r2; ++a3) if (u2 = n3[o2 = f2[a3]], e3.hasOwnProperty(o2) || (e3[o2] = u2), (s2 = e3[o2]) !== u2 && "_" !== o2[0]) {
            if (t3.hasOwnProperty(o2) || (t3[o2] = s2), (d2 = typeof u2) === typeof (l2 = t3[o2])) {
              if ("string" === d2) {
                if ((h2 = _(l2)).valid && (c2 = _(u2)).valid) {
                  e3[o2] = c2.mix(h2, i3).rgbString();
                  continue;
                }
              } else if (H.isFinite(l2) && H.isFinite(u2)) {
                e3[o2] = l2 + (u2 - l2) * i3;
                continue;
              }
            }
            e3[o2] = u2;
          }
        }(i2, a2, n2, t2), e2) : (e2._view = H.extend({}, n2), e2._start = null, e2);
      }, tooltipPosition: function() {
        return { x: this._model.x, y: this._model.y };
      }, hasValue: function() {
        return H.isNumber(this._model.x) && H.isNumber(this._model.y);
      } }), X.extend = H.inherits;
      var K = X, Z = K.extend({ chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null }), $ = Z;
      Object.defineProperty(Z.prototype, "animationObject", { get: function() {
        return this;
      } }), Object.defineProperty(Z.prototype, "chartInstance", { get: function() {
        return this.chart;
      }, set: function(t2) {
        this.chart = t2;
      } }), N._set("global", { animation: { duration: 1e3, easing: "easeOutQuart", onProgress: H.noop, onComplete: H.noop } });
      var J = { animations: [], request: null, addAnimation: function(t2, e2, n2, i2) {
        var a2, r2, o2 = this.animations;
        for (e2.chart = t2, e2.startTime = Date.now(), e2.duration = n2, i2 || (t2.animating = true), a2 = 0, r2 = o2.length; a2 < r2; ++a2) if (o2[a2].chart === t2) return void (o2[a2] = e2);
        o2.push(e2), 1 === o2.length && this.requestAnimationFrame();
      }, cancelAnimation: function(t2) {
        var e2 = H.findIndex(this.animations, function(e3) {
          return e3.chart === t2;
        });
        -1 !== e2 && (this.animations.splice(e2, 1), t2.animating = false);
      }, requestAnimationFrame: function() {
        var t2 = this;
        null === t2.request && (t2.request = H.requestAnimFrame.call(window, function() {
          t2.request = null, t2.startDigest();
        }));
      }, startDigest: function() {
        this.advance(), this.animations.length > 0 && this.requestAnimationFrame();
      }, advance: function() {
        for (var t2, e2, n2, i2, a2 = this.animations, r2 = 0; r2 < a2.length; ) e2 = (t2 = a2[r2]).chart, n2 = t2.numSteps, i2 = Math.floor((Date.now() - t2.startTime) / t2.duration * n2) + 1, t2.currentStep = Math.min(i2, n2), H.callback(t2.render, [e2, t2], e2), H.callback(t2.onAnimationProgress, [t2], e2), t2.currentStep >= n2 ? (H.callback(t2.onAnimationComplete, [t2], e2), e2.animating = false, a2.splice(r2, 1)) : ++r2;
      } }, Q = H.options.resolve, tt = ["push", "pop", "shift", "splice", "unshift"];
      function et(t2, e2) {
        var n2 = t2._chartjs;
        if (n2) {
          var i2 = n2.listeners, a2 = i2.indexOf(e2);
          -1 !== a2 && i2.splice(a2, 1), i2.length > 0 || (tt.forEach(function(e3) {
            delete t2[e3];
          }), delete t2._chartjs);
        }
      }
      var nt = function(t2, e2) {
        this.initialize(t2, e2);
      };
      H.extend(nt.prototype, { datasetElementType: null, dataElementType: null, _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth"], _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "pointStyle"], initialize: function(t2, e2) {
        var n2 = this;
        n2.chart = t2, n2.index = e2, n2.linkScales(), n2.addElements(), n2._type = n2.getMeta().type;
      }, updateIndex: function(t2) {
        this.index = t2;
      }, linkScales: function() {
        var t2 = this.getMeta(), e2 = this.chart, n2 = e2.scales, i2 = this.getDataset(), a2 = e2.options.scales;
        null !== t2.xAxisID && t2.xAxisID in n2 && !i2.xAxisID || (t2.xAxisID = i2.xAxisID || a2.xAxes[0].id), null !== t2.yAxisID && t2.yAxisID in n2 && !i2.yAxisID || (t2.yAxisID = i2.yAxisID || a2.yAxes[0].id);
      }, getDataset: function() {
        return this.chart.data.datasets[this.index];
      }, getMeta: function() {
        return this.chart.getDatasetMeta(this.index);
      }, getScaleForId: function(t2) {
        return this.chart.scales[t2];
      }, _getValueScaleId: function() {
        return this.getMeta().yAxisID;
      }, _getIndexScaleId: function() {
        return this.getMeta().xAxisID;
      }, _getValueScale: function() {
        return this.getScaleForId(this._getValueScaleId());
      }, _getIndexScale: function() {
        return this.getScaleForId(this._getIndexScaleId());
      }, reset: function() {
        this._update(true);
      }, destroy: function() {
        this._data && et(this._data, this);
      }, createMetaDataset: function() {
        var t2 = this.datasetElementType;
        return t2 && new t2({ _chart: this.chart, _datasetIndex: this.index });
      }, createMetaData: function(t2) {
        var e2 = this.dataElementType;
        return e2 && new e2({ _chart: this.chart, _datasetIndex: this.index, _index: t2 });
      }, addElements: function() {
        var t2, e2, n2 = this.getMeta(), i2 = this.getDataset().data || [], a2 = n2.data;
        for (t2 = 0, e2 = i2.length; t2 < e2; ++t2) a2[t2] = a2[t2] || this.createMetaData(t2);
        n2.dataset = n2.dataset || this.createMetaDataset();
      }, addElementAndReset: function(t2) {
        var e2 = this.createMetaData(t2);
        this.getMeta().data.splice(t2, 0, e2), this.updateElement(e2, t2, true);
      }, buildOrUpdateElements: function() {
        var t2, e2, n2 = this, i2 = n2.getDataset(), a2 = i2.data || (i2.data = []);
        n2._data !== a2 && (n2._data && et(n2._data, n2), a2 && Object.isExtensible(a2) && (e2 = n2, (t2 = a2)._chartjs ? t2._chartjs.listeners.push(e2) : (Object.defineProperty(t2, "_chartjs", { configurable: true, enumerable: false, value: { listeners: [e2] } }), tt.forEach(function(e3) {
          var n3 = "onData" + e3.charAt(0).toUpperCase() + e3.slice(1), i3 = t2[e3];
          Object.defineProperty(t2, e3, { configurable: true, enumerable: false, value: function() {
            var e4 = Array.prototype.slice.call(arguments), a3 = i3.apply(this, e4);
            return H.each(t2._chartjs.listeners, function(t3) {
              "function" == typeof t3[n3] && t3[n3].apply(t3, e4);
            }), a3;
          } });
        }))), n2._data = a2), n2.resyncElements();
      }, _configure: function() {
        this._config = H.merge(/* @__PURE__ */ Object.create(null), [this.chart.options.datasets[this._type], this.getDataset()], { merger: function(t2, e2, n2) {
          "_meta" !== t2 && "data" !== t2 && H._merger(t2, e2, n2);
        } });
      }, _update: function(t2) {
        this._configure(), this._cachedDataOpts = null, this.update(t2);
      }, update: H.noop, transition: function(t2) {
        for (var e2 = this.getMeta(), n2 = e2.data || [], i2 = n2.length, a2 = 0; a2 < i2; ++a2) n2[a2].transition(t2);
        e2.dataset && e2.dataset.transition(t2);
      }, draw: function() {
        var t2 = this.getMeta(), e2 = t2.data || [], n2 = e2.length, i2 = 0;
        for (t2.dataset && t2.dataset.draw(); i2 < n2; ++i2) e2[i2].draw();
      }, getStyle: function(t2) {
        var e2, n2 = this.getMeta(), i2 = n2.dataset;
        return this._configure(), i2 && void 0 === t2 ? e2 = this._resolveDatasetElementOptions(i2 || {}) : (t2 = t2 || 0, e2 = this._resolveDataElementOptions(n2.data[t2] || {}, t2)), false !== e2.fill && null !== e2.fill || (e2.backgroundColor = e2.borderColor), e2;
      }, _resolveDatasetElementOptions: function(t2, e2) {
        var n2, i2, a2, r2, o2 = this, s2 = o2.chart, l2 = o2._config, u2 = t2.custom || {}, d2 = s2.options.elements[o2.datasetElementType.prototype._type] || {}, h2 = o2._datasetElementOptions, c2 = {}, f2 = { chart: s2, dataset: o2.getDataset(), datasetIndex: o2.index, hover: e2 };
        for (n2 = 0, i2 = h2.length; n2 < i2; ++n2) a2 = h2[n2], r2 = e2 ? "hover" + a2.charAt(0).toUpperCase() + a2.slice(1) : a2, c2[a2] = Q([u2[r2], l2[r2], d2[r2]], f2);
        return c2;
      }, _resolveDataElementOptions: function(t2, e2) {
        var n2 = this, i2 = t2 && t2.custom, a2 = n2._cachedDataOpts;
        if (a2 && !i2) return a2;
        var r2, o2, s2, l2, u2 = n2.chart, d2 = n2._config, h2 = u2.options.elements[n2.dataElementType.prototype._type] || {}, c2 = n2._dataElementOptions, f2 = {}, g2 = { chart: u2, dataIndex: e2, dataset: n2.getDataset(), datasetIndex: n2.index }, p2 = { cacheable: !i2 };
        if (i2 = i2 || {}, H.isArray(c2)) for (o2 = 0, s2 = c2.length; o2 < s2; ++o2) f2[l2 = c2[o2]] = Q([i2[l2], d2[l2], h2[l2]], g2, e2, p2);
        else for (o2 = 0, s2 = (r2 = Object.keys(c2)).length; o2 < s2; ++o2) f2[l2 = r2[o2]] = Q([i2[l2], d2[c2[l2]], d2[l2], h2[l2]], g2, e2, p2);
        return p2.cacheable && (n2._cachedDataOpts = Object.freeze(f2)), f2;
      }, removeHoverStyle: function(t2) {
        H.merge(t2._model, t2.$previousStyle || {}), delete t2.$previousStyle;
      }, setHoverStyle: function(t2) {
        var e2 = this.chart.data.datasets[t2._datasetIndex], n2 = t2._index, i2 = t2.custom || {}, a2 = t2._model, r2 = H.getHoverColor;
        t2.$previousStyle = { backgroundColor: a2.backgroundColor, borderColor: a2.borderColor, borderWidth: a2.borderWidth }, a2.backgroundColor = Q([i2.hoverBackgroundColor, e2.hoverBackgroundColor, r2(a2.backgroundColor)], void 0, n2), a2.borderColor = Q([i2.hoverBorderColor, e2.hoverBorderColor, r2(a2.borderColor)], void 0, n2), a2.borderWidth = Q([i2.hoverBorderWidth, e2.hoverBorderWidth, a2.borderWidth], void 0, n2);
      }, _removeDatasetHoverStyle: function() {
        var t2 = this.getMeta().dataset;
        t2 && this.removeHoverStyle(t2);
      }, _setDatasetHoverStyle: function() {
        var t2, e2, n2, i2, a2, r2, o2 = this.getMeta().dataset, s2 = {};
        if (o2) {
          for (r2 = o2._model, a2 = this._resolveDatasetElementOptions(o2, true), t2 = 0, e2 = (i2 = Object.keys(a2)).length; t2 < e2; ++t2) s2[n2 = i2[t2]] = r2[n2], r2[n2] = a2[n2];
          o2.$previousStyle = s2;
        }
      }, resyncElements: function() {
        var t2 = this.getMeta(), e2 = this.getDataset().data, n2 = t2.data.length, i2 = e2.length;
        i2 < n2 ? t2.data.splice(i2, n2 - i2) : i2 > n2 && this.insertElements(n2, i2 - n2);
      }, insertElements: function(t2, e2) {
        for (var n2 = 0; n2 < e2; ++n2) this.addElementAndReset(t2 + n2);
      }, onDataPush: function() {
        var t2 = arguments.length;
        this.insertElements(this.getDataset().data.length - t2, t2);
      }, onDataPop: function() {
        this.getMeta().data.pop();
      }, onDataShift: function() {
        this.getMeta().data.shift();
      }, onDataSplice: function(t2, e2) {
        this.getMeta().data.splice(t2, e2), this.insertElements(t2, arguments.length - 2);
      }, onDataUnshift: function() {
        this.insertElements(0, arguments.length);
      } }), nt.extend = H.inherits;
      var it = nt, at = 2 * Math.PI;
      function rt(t2, e2) {
        var n2 = e2.startAngle, i2 = e2.endAngle, a2 = e2.pixelMargin, r2 = a2 / e2.outerRadius, o2 = e2.x, s2 = e2.y;
        t2.beginPath(), t2.arc(o2, s2, e2.outerRadius, n2 - r2, i2 + r2), e2.innerRadius > a2 ? (r2 = a2 / e2.innerRadius, t2.arc(o2, s2, e2.innerRadius - a2, i2 + r2, n2 - r2, true)) : t2.arc(o2, s2, a2, i2 + Math.PI / 2, n2 - Math.PI / 2), t2.closePath(), t2.clip();
      }
      function ot(t2, e2, n2) {
        var i2 = "inner" === e2.borderAlign;
        i2 ? (t2.lineWidth = 2 * e2.borderWidth, t2.lineJoin = "round") : (t2.lineWidth = e2.borderWidth, t2.lineJoin = "bevel"), n2.fullCircles && function(t3, e3, n3, i3) {
          var a2, r2 = n3.endAngle;
          for (i3 && (n3.endAngle = n3.startAngle + at, rt(t3, n3), n3.endAngle = r2, n3.endAngle === n3.startAngle && n3.fullCircles && (n3.endAngle += at, n3.fullCircles--)), t3.beginPath(), t3.arc(n3.x, n3.y, n3.innerRadius, n3.startAngle + at, n3.startAngle, true), a2 = 0; a2 < n3.fullCircles; ++a2) t3.stroke();
          for (t3.beginPath(), t3.arc(n3.x, n3.y, e3.outerRadius, n3.startAngle, n3.startAngle + at), a2 = 0; a2 < n3.fullCircles; ++a2) t3.stroke();
        }(t2, e2, n2, i2), i2 && rt(t2, n2), t2.beginPath(), t2.arc(n2.x, n2.y, e2.outerRadius, n2.startAngle, n2.endAngle), t2.arc(n2.x, n2.y, n2.innerRadius, n2.endAngle, n2.startAngle, true), t2.closePath(), t2.stroke();
      }
      N._set("global", { elements: { arc: { backgroundColor: N.global.defaultColor, borderColor: "#fff", borderWidth: 2, borderAlign: "center" } } });
      var st = K.extend({ _type: "arc", inLabelRange: function(t2) {
        var e2 = this._view;
        return !!e2 && Math.pow(t2 - e2.x, 2) < Math.pow(e2.radius + e2.hoverRadius, 2);
      }, inRange: function(t2, e2) {
        var n2 = this._view;
        if (n2) {
          for (var i2 = H.getAngleFromPoint(n2, { x: t2, y: e2 }), a2 = i2.angle, r2 = i2.distance, o2 = n2.startAngle, s2 = n2.endAngle; s2 < o2; ) s2 += at;
          for (; a2 > s2; ) a2 -= at;
          for (; a2 < o2; ) a2 += at;
          var l2 = a2 >= o2 && a2 <= s2, u2 = r2 >= n2.innerRadius && r2 <= n2.outerRadius;
          return l2 && u2;
        }
        return false;
      }, getCenterPoint: function() {
        var t2 = this._view, e2 = (t2.startAngle + t2.endAngle) / 2, n2 = (t2.innerRadius + t2.outerRadius) / 2;
        return { x: t2.x + Math.cos(e2) * n2, y: t2.y + Math.sin(e2) * n2 };
      }, getArea: function() {
        var t2 = this._view;
        return Math.PI * ((t2.endAngle - t2.startAngle) / (2 * Math.PI)) * (Math.pow(t2.outerRadius, 2) - Math.pow(t2.innerRadius, 2));
      }, tooltipPosition: function() {
        var t2 = this._view, e2 = t2.startAngle + (t2.endAngle - t2.startAngle) / 2, n2 = (t2.outerRadius - t2.innerRadius) / 2 + t2.innerRadius;
        return { x: t2.x + Math.cos(e2) * n2, y: t2.y + Math.sin(e2) * n2 };
      }, draw: function() {
        var t2, e2 = this._chart.ctx, n2 = this._view, i2 = "inner" === n2.borderAlign ? 0.33 : 0, a2 = { x: n2.x, y: n2.y, innerRadius: n2.innerRadius, outerRadius: Math.max(n2.outerRadius - i2, 0), pixelMargin: i2, startAngle: n2.startAngle, endAngle: n2.endAngle, fullCircles: Math.floor(n2.circumference / at) };
        if (e2.save(), e2.fillStyle = n2.backgroundColor, e2.strokeStyle = n2.borderColor, a2.fullCircles) {
          for (a2.endAngle = a2.startAngle + at, e2.beginPath(), e2.arc(a2.x, a2.y, a2.outerRadius, a2.startAngle, a2.endAngle), e2.arc(a2.x, a2.y, a2.innerRadius, a2.endAngle, a2.startAngle, true), e2.closePath(), t2 = 0; t2 < a2.fullCircles; ++t2) e2.fill();
          a2.endAngle = a2.startAngle + n2.circumference % at;
        }
        e2.beginPath(), e2.arc(a2.x, a2.y, a2.outerRadius, a2.startAngle, a2.endAngle), e2.arc(a2.x, a2.y, a2.innerRadius, a2.endAngle, a2.startAngle, true), e2.closePath(), e2.fill(), n2.borderWidth && ot(e2, n2, a2), e2.restore();
      } }), lt = H.valueOrDefault, ut = N.global.defaultColor;
      N._set("global", { elements: { line: { tension: 0.4, backgroundColor: ut, borderWidth: 3, borderColor: ut, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: true, fill: true } } });
      var dt = K.extend({ _type: "line", draw: function() {
        var t2, e2, n2, i2 = this, a2 = i2._view, r2 = i2._chart.ctx, o2 = a2.spanGaps, s2 = i2._children.slice(), l2 = N.global, u2 = l2.elements.line, d2 = -1, h2 = i2._loop;
        if (s2.length) {
          if (i2._loop) {
            for (t2 = 0; t2 < s2.length; ++t2) if (e2 = H.previousItem(s2, t2), !s2[t2]._view.skip && e2._view.skip) {
              s2 = s2.slice(t2).concat(s2.slice(0, t2)), h2 = o2;
              break;
            }
            h2 && s2.push(s2[0]);
          }
          for (r2.save(), r2.lineCap = a2.borderCapStyle || u2.borderCapStyle, r2.setLineDash && r2.setLineDash(a2.borderDash || u2.borderDash), r2.lineDashOffset = lt(a2.borderDashOffset, u2.borderDashOffset), r2.lineJoin = a2.borderJoinStyle || u2.borderJoinStyle, r2.lineWidth = lt(a2.borderWidth, u2.borderWidth), r2.strokeStyle = a2.borderColor || l2.defaultColor, r2.beginPath(), (n2 = s2[0]._view).skip || (r2.moveTo(n2.x, n2.y), d2 = 0), t2 = 1; t2 < s2.length; ++t2) n2 = s2[t2]._view, e2 = -1 === d2 ? H.previousItem(s2, t2) : s2[d2], n2.skip || (d2 !== t2 - 1 && !o2 || -1 === d2 ? r2.moveTo(n2.x, n2.y) : H.canvas.lineTo(r2, e2._view, n2), d2 = t2);
          h2 && r2.closePath(), r2.stroke(), r2.restore();
        }
      } }), ht = H.valueOrDefault, ct = N.global.defaultColor;
      function ft(t2) {
        var e2 = this._view;
        return !!e2 && Math.abs(t2 - e2.x) < e2.radius + e2.hitRadius;
      }
      N._set("global", { elements: { point: { radius: 3, pointStyle: "circle", backgroundColor: ct, borderColor: ct, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 } } });
      var gt = K.extend({ _type: "point", inRange: function(t2, e2) {
        var n2 = this._view;
        return !!n2 && Math.pow(t2 - n2.x, 2) + Math.pow(e2 - n2.y, 2) < Math.pow(n2.hitRadius + n2.radius, 2);
      }, inLabelRange: ft, inXRange: ft, inYRange: function(t2) {
        var e2 = this._view;
        return !!e2 && Math.abs(t2 - e2.y) < e2.radius + e2.hitRadius;
      }, getCenterPoint: function() {
        var t2 = this._view;
        return { x: t2.x, y: t2.y };
      }, getArea: function() {
        return Math.PI * Math.pow(this._view.radius, 2);
      }, tooltipPosition: function() {
        var t2 = this._view;
        return { x: t2.x, y: t2.y, padding: t2.radius + t2.borderWidth };
      }, draw: function(t2) {
        var e2 = this._view, n2 = this._chart.ctx, i2 = e2.pointStyle, a2 = e2.rotation, r2 = e2.radius, o2 = e2.x, s2 = e2.y, l2 = N.global, u2 = l2.defaultColor;
        e2.skip || (void 0 === t2 || H.canvas._isPointInArea(e2, t2)) && (n2.strokeStyle = e2.borderColor || u2, n2.lineWidth = ht(e2.borderWidth, l2.elements.point.borderWidth), n2.fillStyle = e2.backgroundColor || u2, H.canvas.drawPoint(n2, i2, r2, o2, s2, a2));
      } }), pt = N.global.defaultColor;
      function mt(t2) {
        return t2 && void 0 !== t2.width;
      }
      function vt(t2) {
        var e2, n2, i2, a2, r2;
        return mt(t2) ? (r2 = t2.width / 2, e2 = t2.x - r2, n2 = t2.x + r2, i2 = Math.min(t2.y, t2.base), a2 = Math.max(t2.y, t2.base)) : (r2 = t2.height / 2, e2 = Math.min(t2.x, t2.base), n2 = Math.max(t2.x, t2.base), i2 = t2.y - r2, a2 = t2.y + r2), { left: e2, top: i2, right: n2, bottom: a2 };
      }
      function bt(t2, e2, n2) {
        return t2 === e2 ? n2 : t2 === n2 ? e2 : t2;
      }
      function xt(t2, e2, n2) {
        var i2, a2, r2, o2, s2 = t2.borderWidth, l2 = function(t3) {
          var e3 = t3.borderSkipped, n3 = {};
          return e3 ? (t3.horizontal ? t3.base > t3.x && (e3 = bt(e3, "left", "right")) : t3.base < t3.y && (e3 = bt(e3, "bottom", "top")), n3[e3] = true, n3) : n3;
        }(t2);
        return H.isObject(s2) ? (i2 = +s2.top || 0, a2 = +s2.right || 0, r2 = +s2.bottom || 0, o2 = +s2.left || 0) : i2 = a2 = r2 = o2 = +s2 || 0, { t: l2.top || i2 < 0 ? 0 : i2 > n2 ? n2 : i2, r: l2.right || a2 < 0 ? 0 : a2 > e2 ? e2 : a2, b: l2.bottom || r2 < 0 ? 0 : r2 > n2 ? n2 : r2, l: l2.left || o2 < 0 ? 0 : o2 > e2 ? e2 : o2 };
      }
      function yt(t2, e2, n2) {
        var i2 = null === e2, a2 = null === n2, r2 = !(!t2 || i2 && a2) && vt(t2);
        return r2 && (i2 || e2 >= r2.left && e2 <= r2.right) && (a2 || n2 >= r2.top && n2 <= r2.bottom);
      }
      N._set("global", { elements: { rectangle: { backgroundColor: pt, borderColor: pt, borderSkipped: "bottom", borderWidth: 0 } } });
      var _t = K.extend({ _type: "rectangle", draw: function() {
        var t2 = this._chart.ctx, e2 = this._view, n2 = function(t3) {
          var e3 = vt(t3), n3 = e3.right - e3.left, i3 = e3.bottom - e3.top, a3 = xt(t3, n3 / 2, i3 / 2);
          return { outer: { x: e3.left, y: e3.top, w: n3, h: i3 }, inner: { x: e3.left + a3.l, y: e3.top + a3.t, w: n3 - a3.l - a3.r, h: i3 - a3.t - a3.b } };
        }(e2), i2 = n2.outer, a2 = n2.inner;
        t2.fillStyle = e2.backgroundColor, t2.fillRect(i2.x, i2.y, i2.w, i2.h), i2.w === a2.w && i2.h === a2.h || (t2.save(), t2.beginPath(), t2.rect(i2.x, i2.y, i2.w, i2.h), t2.clip(), t2.fillStyle = e2.borderColor, t2.rect(a2.x, a2.y, a2.w, a2.h), t2.fill("evenodd"), t2.restore());
      }, height: function() {
        var t2 = this._view;
        return t2.base - t2.y;
      }, inRange: function(t2, e2) {
        return yt(this._view, t2, e2);
      }, inLabelRange: function(t2, e2) {
        var n2 = this._view;
        return mt(n2) ? yt(n2, t2, null) : yt(n2, null, e2);
      }, inXRange: function(t2) {
        return yt(this._view, t2, null);
      }, inYRange: function(t2) {
        return yt(this._view, null, t2);
      }, getCenterPoint: function() {
        var t2, e2, n2 = this._view;
        return mt(n2) ? (t2 = n2.x, e2 = (n2.y + n2.base) / 2) : (t2 = (n2.x + n2.base) / 2, e2 = n2.y), { x: t2, y: e2 };
      }, getArea: function() {
        var t2 = this._view;
        return mt(t2) ? t2.width * Math.abs(t2.y - t2.base) : t2.height * Math.abs(t2.x - t2.base);
      }, tooltipPosition: function() {
        var t2 = this._view;
        return { x: t2.x, y: t2.y };
      } }), kt = {}, wt = st, Mt = dt, St = gt, Ct = _t;
      kt.Arc = wt, kt.Line = Mt, kt.Point = St, kt.Rectangle = Ct;
      var Pt = H._deprecated, At = H.valueOrDefault;
      function Dt(t2, e2, n2) {
        var i2, a2, r2 = n2.barThickness, o2 = e2.stackCount, s2 = e2.pixels[t2], l2 = H.isNullOrUndef(r2) ? function(t3, e3) {
          var n3, i3, a3, r3, o3 = t3._length;
          for (a3 = 1, r3 = e3.length; a3 < r3; ++a3) o3 = Math.min(o3, Math.abs(e3[a3] - e3[a3 - 1]));
          for (a3 = 0, r3 = t3.getTicks().length; a3 < r3; ++a3) i3 = t3.getPixelForTick(a3), o3 = a3 > 0 ? Math.min(o3, Math.abs(i3 - n3)) : o3, n3 = i3;
          return o3;
        }(e2.scale, e2.pixels) : -1;
        return H.isNullOrUndef(r2) ? (i2 = l2 * n2.categoryPercentage, a2 = n2.barPercentage) : (i2 = r2 * o2, a2 = 1), { chunk: i2 / o2, ratio: a2, start: s2 - i2 / 2 };
      }
      N._set("bar", { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", offset: true, gridLines: { offsetGridLines: true } }], yAxes: [{ type: "linear" }] } }), N._set("global", { datasets: { bar: { categoryPercentage: 0.8, barPercentage: 0.9 } } });
      var Tt = it.extend({ dataElementType: kt.Rectangle, _dataElementOptions: ["backgroundColor", "borderColor", "borderSkipped", "borderWidth", "barPercentage", "barThickness", "categoryPercentage", "maxBarThickness", "minBarLength"], initialize: function() {
        var t2, e2, n2 = this;
        it.prototype.initialize.apply(n2, arguments), (t2 = n2.getMeta()).stack = n2.getDataset().stack, t2.bar = true, e2 = n2._getIndexScale().options, Pt("bar chart", e2.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage"), Pt("bar chart", e2.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness"), Pt("bar chart", e2.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage"), Pt("bar chart", n2._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength"), Pt("bar chart", e2.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
      }, update: function(t2) {
        var e2, n2, i2 = this.getMeta().data;
        for (this._ruler = this.getRuler(), e2 = 0, n2 = i2.length; e2 < n2; ++e2) this.updateElement(i2[e2], e2, t2);
      }, updateElement: function(t2, e2, n2) {
        var i2 = this, a2 = i2.getMeta(), r2 = i2.getDataset(), o2 = i2._resolveDataElementOptions(t2, e2);
        t2._xScale = i2.getScaleForId(a2.xAxisID), t2._yScale = i2.getScaleForId(a2.yAxisID), t2._datasetIndex = i2.index, t2._index = e2, t2._model = { backgroundColor: o2.backgroundColor, borderColor: o2.borderColor, borderSkipped: o2.borderSkipped, borderWidth: o2.borderWidth, datasetLabel: r2.label, label: i2.chart.data.labels[e2] }, H.isArray(r2.data[e2]) && (t2._model.borderSkipped = null), i2._updateElementGeometry(t2, e2, n2, o2), t2.pivot();
      }, _updateElementGeometry: function(t2, e2, n2, i2) {
        var a2 = this, r2 = t2._model, o2 = a2._getValueScale(), s2 = o2.getBasePixel(), l2 = o2.isHorizontal(), u2 = a2._ruler || a2.getRuler(), d2 = a2.calculateBarValuePixels(a2.index, e2, i2), h2 = a2.calculateBarIndexPixels(a2.index, e2, u2, i2);
        r2.horizontal = l2, r2.base = n2 ? s2 : d2.base, r2.x = l2 ? n2 ? s2 : d2.head : h2.center, r2.y = l2 ? h2.center : n2 ? s2 : d2.head, r2.height = l2 ? h2.size : void 0, r2.width = l2 ? void 0 : h2.size;
      }, _getStacks: function(t2) {
        var e2, n2, i2 = this._getIndexScale(), a2 = i2._getMatchingVisibleMetas(this._type), r2 = i2.options.stacked, o2 = a2.length, s2 = [];
        for (e2 = 0; e2 < o2 && (n2 = a2[e2], (false === r2 || -1 === s2.indexOf(n2.stack) || void 0 === r2 && void 0 === n2.stack) && s2.push(n2.stack), n2.index !== t2); ++e2) ;
        return s2;
      }, getStackCount: function() {
        return this._getStacks().length;
      }, getStackIndex: function(t2, e2) {
        var n2 = this._getStacks(t2), i2 = void 0 !== e2 ? n2.indexOf(e2) : -1;
        return -1 === i2 ? n2.length - 1 : i2;
      }, getRuler: function() {
        var t2, e2, n2 = this._getIndexScale(), i2 = [];
        for (t2 = 0, e2 = this.getMeta().data.length; t2 < e2; ++t2) i2.push(n2.getPixelForValue(null, t2, this.index));
        return { pixels: i2, start: n2._startPixel, end: n2._endPixel, stackCount: this.getStackCount(), scale: n2 };
      }, calculateBarValuePixels: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2, u2, d2 = this.chart, h2 = this._getValueScale(), c2 = h2.isHorizontal(), f2 = d2.data.datasets, g2 = h2._getMatchingVisibleMetas(this._type), p2 = h2._parseValue(f2[t2].data[e2]), m2 = n2.minBarLength, v2 = h2.options.stacked, b2 = this.getMeta().stack, x2 = void 0 === p2.start ? 0 : p2.max >= 0 && p2.min >= 0 ? p2.min : p2.max, y2 = void 0 === p2.start ? p2.end : p2.max >= 0 && p2.min >= 0 ? p2.max - p2.min : p2.min - p2.max, _2 = g2.length;
        if (v2 || void 0 === v2 && void 0 !== b2) for (i2 = 0; i2 < _2 && (a2 = g2[i2]).index !== t2; ++i2) a2.stack === b2 && (r2 = void 0 === (u2 = h2._parseValue(f2[a2.index].data[e2])).start ? u2.end : u2.min >= 0 && u2.max >= 0 ? u2.max : u2.min, (p2.min < 0 && r2 < 0 || p2.max >= 0 && r2 > 0) && (x2 += r2));
        return o2 = h2.getPixelForValue(x2), l2 = (s2 = h2.getPixelForValue(x2 + y2)) - o2, void 0 !== m2 && Math.abs(l2) < m2 && (l2 = m2, s2 = y2 >= 0 && !c2 || y2 < 0 && c2 ? o2 - m2 : o2 + m2), { size: l2, base: o2, head: s2, center: s2 + l2 / 2 };
      }, calculateBarIndexPixels: function(t2, e2, n2, i2) {
        var a2 = "flex" === i2.barThickness ? function(t3, e3, n3) {
          var i3, a3 = e3.pixels, r3 = a3[t3], o3 = t3 > 0 ? a3[t3 - 1] : null, s3 = t3 < a3.length - 1 ? a3[t3 + 1] : null, l2 = n3.categoryPercentage;
          return null === o3 && (o3 = r3 - (null === s3 ? e3.end - e3.start : s3 - r3)), null === s3 && (s3 = r3 + r3 - o3), i3 = r3 - (r3 - Math.min(o3, s3)) / 2 * l2, { chunk: Math.abs(s3 - o3) / 2 * l2 / e3.stackCount, ratio: n3.barPercentage, start: i3 };
        }(e2, n2, i2) : Dt(e2, n2, i2), r2 = this.getStackIndex(t2, this.getMeta().stack), o2 = a2.start + a2.chunk * r2 + a2.chunk / 2, s2 = Math.min(At(i2.maxBarThickness, 1 / 0), a2.chunk * a2.ratio);
        return { base: o2 - s2 / 2, head: o2 + s2 / 2, center: o2, size: s2 };
      }, draw: function() {
        var t2 = this.chart, e2 = this._getValueScale(), n2 = this.getMeta().data, i2 = this.getDataset(), a2 = n2.length, r2 = 0;
        for (H.canvas.clipArea(t2.ctx, t2.chartArea); r2 < a2; ++r2) {
          var o2 = e2._parseValue(i2.data[r2]);
          isNaN(o2.min) || isNaN(o2.max) || n2[r2].draw();
        }
        H.canvas.unclipArea(t2.ctx);
      }, _resolveDataElementOptions: function() {
        var t2 = this, e2 = H.extend({}, it.prototype._resolveDataElementOptions.apply(t2, arguments)), n2 = t2._getIndexScale().options, i2 = t2._getValueScale().options;
        return e2.barPercentage = At(n2.barPercentage, e2.barPercentage), e2.barThickness = At(n2.barThickness, e2.barThickness), e2.categoryPercentage = At(n2.categoryPercentage, e2.categoryPercentage), e2.maxBarThickness = At(n2.maxBarThickness, e2.maxBarThickness), e2.minBarLength = At(i2.minBarLength, e2.minBarLength), e2;
      } }), It = H.valueOrDefault, Ft = H.options.resolve;
      N._set("bubble", { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title: function() {
        return "";
      }, label: function(t2, e2) {
        var n2 = e2.datasets[t2.datasetIndex].label || "", i2 = e2.datasets[t2.datasetIndex].data[t2.index];
        return n2 + ": (" + t2.xLabel + ", " + t2.yLabel + ", " + i2.r + ")";
      } } } });
      var Ot = it.extend({ dataElementType: kt.Point, _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"], update: function(t2) {
        var e2 = this, n2 = e2.getMeta().data;
        H.each(n2, function(n3, i2) {
          e2.updateElement(n3, i2, t2);
        });
      }, updateElement: function(t2, e2, n2) {
        var i2 = this, a2 = i2.getMeta(), r2 = t2.custom || {}, o2 = i2.getScaleForId(a2.xAxisID), s2 = i2.getScaleForId(a2.yAxisID), l2 = i2._resolveDataElementOptions(t2, e2), u2 = i2.getDataset().data[e2], d2 = i2.index, h2 = n2 ? o2.getPixelForDecimal(0.5) : o2.getPixelForValue("object" == typeof u2 ? u2 : NaN, e2, d2), c2 = n2 ? s2.getBasePixel() : s2.getPixelForValue(u2, e2, d2);
        t2._xScale = o2, t2._yScale = s2, t2._options = l2, t2._datasetIndex = d2, t2._index = e2, t2._model = { backgroundColor: l2.backgroundColor, borderColor: l2.borderColor, borderWidth: l2.borderWidth, hitRadius: l2.hitRadius, pointStyle: l2.pointStyle, rotation: l2.rotation, radius: n2 ? 0 : l2.radius, skip: r2.skip || isNaN(h2) || isNaN(c2), x: h2, y: c2 }, t2.pivot();
      }, setHoverStyle: function(t2) {
        var e2 = t2._model, n2 = t2._options, i2 = H.getHoverColor;
        t2.$previousStyle = { backgroundColor: e2.backgroundColor, borderColor: e2.borderColor, borderWidth: e2.borderWidth, radius: e2.radius }, e2.backgroundColor = It(n2.hoverBackgroundColor, i2(n2.backgroundColor)), e2.borderColor = It(n2.hoverBorderColor, i2(n2.borderColor)), e2.borderWidth = It(n2.hoverBorderWidth, n2.borderWidth), e2.radius = n2.radius + n2.hoverRadius;
      }, _resolveDataElementOptions: function(t2, e2) {
        var n2 = this, i2 = n2.chart, a2 = n2.getDataset(), r2 = t2.custom || {}, o2 = a2.data[e2] || {}, s2 = it.prototype._resolveDataElementOptions.apply(n2, arguments), l2 = { chart: i2, dataIndex: e2, dataset: a2, datasetIndex: n2.index };
        return n2._cachedDataOpts === s2 && (s2 = H.extend({}, s2)), s2.radius = Ft([r2.radius, o2.r, n2._config.radius, i2.options.elements.point.radius], l2, e2), s2;
      } }), Lt = H.valueOrDefault, Rt = Math.PI, zt = 2 * Rt, Nt = Rt / 2;
      N._set("doughnut", { animation: { animateRotate: true, animateScale: false }, hover: { mode: "single" }, legendCallback: function(t2) {
        var e2, n2, i2, a2 = document.createElement("ul"), r2 = t2.data, o2 = r2.datasets, s2 = r2.labels;
        if (a2.setAttribute("class", t2.id + "-legend"), o2.length) for (e2 = 0, n2 = o2[0].data.length; e2 < n2; ++e2) (i2 = a2.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = o2[0].backgroundColor[e2], s2[e2] && i2.appendChild(document.createTextNode(s2[e2]));
        return a2.outerHTML;
      }, legend: { labels: { generateLabels: function(t2) {
        var e2 = t2.data;
        return e2.labels.length && e2.datasets.length ? e2.labels.map(function(n2, i2) {
          var a2 = t2.getDatasetMeta(0), r2 = a2.controller.getStyle(i2);
          return { text: n2, fillStyle: r2.backgroundColor, strokeStyle: r2.borderColor, lineWidth: r2.borderWidth, hidden: isNaN(e2.datasets[0].data[i2]) || a2.data[i2].hidden, index: i2 };
        }) : [];
      } }, onClick: function(t2, e2) {
        var n2, i2, a2, r2 = e2.index, o2 = this.chart;
        for (n2 = 0, i2 = (o2.data.datasets || []).length; n2 < i2; ++n2) (a2 = o2.getDatasetMeta(n2)).data[r2] && (a2.data[r2].hidden = !a2.data[r2].hidden);
        o2.update();
      } }, cutoutPercentage: 50, rotation: -Nt, circumference: zt, tooltips: { callbacks: { title: function() {
        return "";
      }, label: function(t2, e2) {
        var n2 = e2.labels[t2.index], i2 = ": " + e2.datasets[t2.datasetIndex].data[t2.index];
        return H.isArray(n2) ? (n2 = n2.slice())[0] += i2 : n2 += i2, n2;
      } } } });
      var Bt = it.extend({ dataElementType: kt.Arc, linkScales: H.noop, _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"], getRingIndex: function(t2) {
        for (var e2 = 0, n2 = 0; n2 < t2; ++n2) this.chart.isDatasetVisible(n2) && ++e2;
        return e2;
      }, update: function(t2) {
        var e2, n2, i2, a2, r2 = this, o2 = r2.chart, s2 = o2.chartArea, l2 = o2.options, u2 = 1, d2 = 1, h2 = 0, c2 = 0, f2 = r2.getMeta(), g2 = f2.data, p2 = l2.cutoutPercentage / 100 || 0, m2 = l2.circumference, v2 = r2._getRingWeight(r2.index);
        if (m2 < zt) {
          var b2 = l2.rotation % zt, x2 = (b2 += b2 >= Rt ? -zt : b2 < -Rt ? zt : 0) + m2, y2 = Math.cos(b2), _2 = Math.sin(b2), k2 = Math.cos(x2), w2 = Math.sin(x2), M2 = b2 <= 0 && x2 >= 0 || x2 >= zt, S2 = b2 <= Nt && x2 >= Nt || x2 >= zt + Nt, C2 = b2 <= -Nt && x2 >= -Nt || x2 >= Rt + Nt, P2 = b2 === -Rt || x2 >= Rt ? -1 : Math.min(y2, y2 * p2, k2, k2 * p2), A2 = C2 ? -1 : Math.min(_2, _2 * p2, w2, w2 * p2), D2 = M2 ? 1 : Math.max(y2, y2 * p2, k2, k2 * p2), T2 = S2 ? 1 : Math.max(_2, _2 * p2, w2, w2 * p2);
          u2 = (D2 - P2) / 2, d2 = (T2 - A2) / 2, h2 = -(D2 + P2) / 2, c2 = -(T2 + A2) / 2;
        }
        for (i2 = 0, a2 = g2.length; i2 < a2; ++i2) g2[i2]._options = r2._resolveDataElementOptions(g2[i2], i2);
        for (o2.borderWidth = r2.getMaxBorderWidth(), e2 = (s2.right - s2.left - o2.borderWidth) / u2, n2 = (s2.bottom - s2.top - o2.borderWidth) / d2, o2.outerRadius = Math.max(Math.min(e2, n2) / 2, 0), o2.innerRadius = Math.max(o2.outerRadius * p2, 0), o2.radiusLength = (o2.outerRadius - o2.innerRadius) / (r2._getVisibleDatasetWeightTotal() || 1), o2.offsetX = h2 * o2.outerRadius, o2.offsetY = c2 * o2.outerRadius, f2.total = r2.calculateTotal(), r2.outerRadius = o2.outerRadius - o2.radiusLength * r2._getRingWeightOffset(r2.index), r2.innerRadius = Math.max(r2.outerRadius - o2.radiusLength * v2, 0), i2 = 0, a2 = g2.length; i2 < a2; ++i2) r2.updateElement(g2[i2], i2, t2);
      }, updateElement: function(t2, e2, n2) {
        var i2 = this, a2 = i2.chart, r2 = a2.chartArea, o2 = a2.options, s2 = o2.animation, l2 = (r2.left + r2.right) / 2, u2 = (r2.top + r2.bottom) / 2, d2 = o2.rotation, h2 = o2.rotation, c2 = i2.getDataset(), f2 = n2 && s2.animateRotate ? 0 : t2.hidden ? 0 : i2.calculateCircumference(c2.data[e2]) * (o2.circumference / zt), g2 = n2 && s2.animateScale ? 0 : i2.innerRadius, p2 = n2 && s2.animateScale ? 0 : i2.outerRadius, m2 = t2._options || {};
        H.extend(t2, { _datasetIndex: i2.index, _index: e2, _model: { backgroundColor: m2.backgroundColor, borderColor: m2.borderColor, borderWidth: m2.borderWidth, borderAlign: m2.borderAlign, x: l2 + a2.offsetX, y: u2 + a2.offsetY, startAngle: d2, endAngle: h2, circumference: f2, outerRadius: p2, innerRadius: g2, label: H.valueAtIndexOrDefault(c2.label, e2, a2.data.labels[e2]) } });
        var v2 = t2._model;
        n2 && s2.animateRotate || (v2.startAngle = 0 === e2 ? o2.rotation : i2.getMeta().data[e2 - 1]._model.endAngle, v2.endAngle = v2.startAngle + v2.circumference), t2.pivot();
      }, calculateTotal: function() {
        var t2, e2 = this.getDataset(), n2 = this.getMeta(), i2 = 0;
        return H.each(n2.data, function(n3, a2) {
          t2 = e2.data[a2], isNaN(t2) || n3.hidden || (i2 += Math.abs(t2));
        }), i2;
      }, calculateCircumference: function(t2) {
        var e2 = this.getMeta().total;
        return e2 > 0 && !isNaN(t2) ? zt * (Math.abs(t2) / e2) : 0;
      }, getMaxBorderWidth: function(t2) {
        var e2, n2, i2, a2, r2, o2, s2, l2, u2 = 0, d2 = this.chart;
        if (!t2) {
          for (e2 = 0, n2 = d2.data.datasets.length; e2 < n2; ++e2) if (d2.isDatasetVisible(e2)) {
            t2 = (i2 = d2.getDatasetMeta(e2)).data, e2 !== this.index && (r2 = i2.controller);
            break;
          }
        }
        if (!t2) return 0;
        for (e2 = 0, n2 = t2.length; e2 < n2; ++e2) a2 = t2[e2], r2 ? (r2._configure(), o2 = r2._resolveDataElementOptions(a2, e2)) : o2 = a2._options, "inner" !== o2.borderAlign && (s2 = o2.borderWidth, u2 = (l2 = o2.hoverBorderWidth) > (u2 = s2 > u2 ? s2 : u2) ? l2 : u2);
        return u2;
      }, setHoverStyle: function(t2) {
        var e2 = t2._model, n2 = t2._options, i2 = H.getHoverColor;
        t2.$previousStyle = { backgroundColor: e2.backgroundColor, borderColor: e2.borderColor, borderWidth: e2.borderWidth }, e2.backgroundColor = Lt(n2.hoverBackgroundColor, i2(n2.backgroundColor)), e2.borderColor = Lt(n2.hoverBorderColor, i2(n2.borderColor)), e2.borderWidth = Lt(n2.hoverBorderWidth, n2.borderWidth);
      }, _getRingWeightOffset: function(t2) {
        for (var e2 = 0, n2 = 0; n2 < t2; ++n2) this.chart.isDatasetVisible(n2) && (e2 += this._getRingWeight(n2));
        return e2;
      }, _getRingWeight: function(t2) {
        return Math.max(Lt(this.chart.data.datasets[t2].weight, 1), 0);
      }, _getVisibleDatasetWeightTotal: function() {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      } });
      N._set("horizontalBar", { hover: { mode: "index", axis: "y" }, scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ type: "category", position: "left", offset: true, gridLines: { offsetGridLines: true } }] }, elements: { rectangle: { borderSkipped: "left" } }, tooltips: { mode: "index", axis: "y" } }), N._set("global", { datasets: { horizontalBar: { categoryPercentage: 0.8, barPercentage: 0.9 } } });
      var Et = Tt.extend({ _getValueScaleId: function() {
        return this.getMeta().xAxisID;
      }, _getIndexScaleId: function() {
        return this.getMeta().yAxisID;
      } }), Wt = H.valueOrDefault, Vt = H.options.resolve, Ht = H.canvas._isPointInArea;
      function jt(t2, e2) {
        var n2 = t2 && t2.options.ticks || {}, i2 = n2.reverse, a2 = void 0 === n2.min ? e2 : 0, r2 = void 0 === n2.max ? e2 : 0;
        return { start: i2 ? r2 : a2, end: i2 ? a2 : r2 };
      }
      function qt(t2, e2, n2) {
        var i2 = n2 / 2, a2 = jt(t2, i2), r2 = jt(e2, i2);
        return { top: r2.end, right: a2.end, bottom: r2.start, left: a2.start };
      }
      function Ut(t2) {
        var e2, n2, i2, a2;
        return H.isObject(t2) ? (e2 = t2.top, n2 = t2.right, i2 = t2.bottom, a2 = t2.left) : e2 = n2 = i2 = a2 = t2, { top: e2, right: n2, bottom: i2, left: a2 };
      }
      N._set("line", { showLines: true, spanGaps: false, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } });
      var Yt = it.extend({ datasetElementType: kt.Line, dataElementType: kt.Point, _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth", "cubicInterpolationMode", "fill"], _dataElementOptions: { backgroundColor: "pointBackgroundColor", borderColor: "pointBorderColor", borderWidth: "pointBorderWidth", hitRadius: "pointHitRadius", hoverBackgroundColor: "pointHoverBackgroundColor", hoverBorderColor: "pointHoverBorderColor", hoverBorderWidth: "pointHoverBorderWidth", hoverRadius: "pointHoverRadius", pointStyle: "pointStyle", radius: "pointRadius", rotation: "pointRotation" }, update: function(t2) {
        var e2, n2, i2 = this, a2 = i2.getMeta(), r2 = a2.dataset, o2 = a2.data || [], s2 = i2.chart.options, l2 = i2._config, u2 = i2._showLine = Wt(l2.showLine, s2.showLines);
        for (i2._xScale = i2.getScaleForId(a2.xAxisID), i2._yScale = i2.getScaleForId(a2.yAxisID), u2 && (void 0 !== l2.tension && void 0 === l2.lineTension && (l2.lineTension = l2.tension), r2._scale = i2._yScale, r2._datasetIndex = i2.index, r2._children = o2, r2._model = i2._resolveDatasetElementOptions(r2), r2.pivot()), e2 = 0, n2 = o2.length; e2 < n2; ++e2) i2.updateElement(o2[e2], e2, t2);
        for (u2 && 0 !== r2._model.tension && i2.updateBezierControlPoints(), e2 = 0, n2 = o2.length; e2 < n2; ++e2) o2[e2].pivot();
      }, updateElement: function(t2, e2, n2) {
        var i2, a2, r2 = this, o2 = r2.getMeta(), s2 = t2.custom || {}, l2 = r2.getDataset(), u2 = r2.index, d2 = l2.data[e2], h2 = r2._xScale, c2 = r2._yScale, f2 = o2.dataset._model, g2 = r2._resolveDataElementOptions(t2, e2);
        i2 = h2.getPixelForValue("object" == typeof d2 ? d2 : NaN, e2, u2), a2 = n2 ? c2.getBasePixel() : r2.calculatePointY(d2, e2, u2), t2._xScale = h2, t2._yScale = c2, t2._options = g2, t2._datasetIndex = u2, t2._index = e2, t2._model = { x: i2, y: a2, skip: s2.skip || isNaN(i2) || isNaN(a2), radius: g2.radius, pointStyle: g2.pointStyle, rotation: g2.rotation, backgroundColor: g2.backgroundColor, borderColor: g2.borderColor, borderWidth: g2.borderWidth, tension: Wt(s2.tension, f2 ? f2.tension : 0), steppedLine: !!f2 && f2.steppedLine, hitRadius: g2.hitRadius };
      }, _resolveDatasetElementOptions: function(t2) {
        var e2 = this, n2 = e2._config, i2 = t2.custom || {}, a2 = e2.chart.options, r2 = a2.elements.line, o2 = it.prototype._resolveDatasetElementOptions.apply(e2, arguments);
        return o2.spanGaps = Wt(n2.spanGaps, a2.spanGaps), o2.tension = Wt(n2.lineTension, r2.tension), o2.steppedLine = Vt([i2.steppedLine, n2.steppedLine, r2.stepped]), o2.clip = Ut(Wt(n2.clip, qt(e2._xScale, e2._yScale, o2.borderWidth))), o2;
      }, calculatePointY: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2, u2, d2 = this.chart, h2 = this._yScale, c2 = 0, f2 = 0;
        if (h2.options.stacked) {
          for (s2 = +h2.getRightValue(t2), u2 = (l2 = d2._getSortedVisibleDatasetMetas()).length, i2 = 0; i2 < u2 && (r2 = l2[i2]).index !== n2; ++i2) a2 = d2.data.datasets[r2.index], "line" === r2.type && r2.yAxisID === h2.id && ((o2 = +h2.getRightValue(a2.data[e2])) < 0 ? f2 += o2 || 0 : c2 += o2 || 0);
          return s2 < 0 ? h2.getPixelForValue(f2 + s2) : h2.getPixelForValue(c2 + s2);
        }
        return h2.getPixelForValue(t2);
      }, updateBezierControlPoints: function() {
        var t2, e2, n2, i2, a2 = this.chart, r2 = this.getMeta(), o2 = r2.dataset._model, s2 = a2.chartArea, l2 = r2.data || [];
        function u2(t3, e3, n3) {
          return Math.max(Math.min(t3, n3), e3);
        }
        if (o2.spanGaps && (l2 = l2.filter(function(t3) {
          return !t3._model.skip;
        })), "monotone" === o2.cubicInterpolationMode) H.splineCurveMonotone(l2);
        else for (t2 = 0, e2 = l2.length; t2 < e2; ++t2) n2 = l2[t2]._model, i2 = H.splineCurve(H.previousItem(l2, t2)._model, n2, H.nextItem(l2, t2)._model, o2.tension), n2.controlPointPreviousX = i2.previous.x, n2.controlPointPreviousY = i2.previous.y, n2.controlPointNextX = i2.next.x, n2.controlPointNextY = i2.next.y;
        if (a2.options.elements.line.capBezierPoints) for (t2 = 0, e2 = l2.length; t2 < e2; ++t2) n2 = l2[t2]._model, Ht(n2, s2) && (t2 > 0 && Ht(l2[t2 - 1]._model, s2) && (n2.controlPointPreviousX = u2(n2.controlPointPreviousX, s2.left, s2.right), n2.controlPointPreviousY = u2(n2.controlPointPreviousY, s2.top, s2.bottom)), t2 < l2.length - 1 && Ht(l2[t2 + 1]._model, s2) && (n2.controlPointNextX = u2(n2.controlPointNextX, s2.left, s2.right), n2.controlPointNextY = u2(n2.controlPointNextY, s2.top, s2.bottom)));
      }, draw: function() {
        var t2, e2 = this.chart, n2 = this.getMeta(), i2 = n2.data || [], a2 = e2.chartArea, r2 = e2.canvas, o2 = 0, s2 = i2.length;
        for (this._showLine && (t2 = n2.dataset._model.clip, H.canvas.clipArea(e2.ctx, { left: false === t2.left ? 0 : a2.left - t2.left, right: false === t2.right ? r2.width : a2.right + t2.right, top: false === t2.top ? 0 : a2.top - t2.top, bottom: false === t2.bottom ? r2.height : a2.bottom + t2.bottom }), n2.dataset.draw(), H.canvas.unclipArea(e2.ctx)); o2 < s2; ++o2) i2[o2].draw(a2);
      }, setHoverStyle: function(t2) {
        var e2 = t2._model, n2 = t2._options, i2 = H.getHoverColor;
        t2.$previousStyle = { backgroundColor: e2.backgroundColor, borderColor: e2.borderColor, borderWidth: e2.borderWidth, radius: e2.radius }, e2.backgroundColor = Wt(n2.hoverBackgroundColor, i2(n2.backgroundColor)), e2.borderColor = Wt(n2.hoverBorderColor, i2(n2.borderColor)), e2.borderWidth = Wt(n2.hoverBorderWidth, n2.borderWidth), e2.radius = Wt(n2.hoverRadius, n2.radius);
      } }), Gt = H.options.resolve;
      N._set("polarArea", { scale: { type: "radialLinear", angleLines: { display: false }, gridLines: { circular: true }, pointLabels: { display: false }, ticks: { beginAtZero: true } }, animation: { animateRotate: true, animateScale: true }, startAngle: -0.5 * Math.PI, legendCallback: function(t2) {
        var e2, n2, i2, a2 = document.createElement("ul"), r2 = t2.data, o2 = r2.datasets, s2 = r2.labels;
        if (a2.setAttribute("class", t2.id + "-legend"), o2.length) for (e2 = 0, n2 = o2[0].data.length; e2 < n2; ++e2) (i2 = a2.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = o2[0].backgroundColor[e2], s2[e2] && i2.appendChild(document.createTextNode(s2[e2]));
        return a2.outerHTML;
      }, legend: { labels: { generateLabels: function(t2) {
        var e2 = t2.data;
        return e2.labels.length && e2.datasets.length ? e2.labels.map(function(n2, i2) {
          var a2 = t2.getDatasetMeta(0), r2 = a2.controller.getStyle(i2);
          return { text: n2, fillStyle: r2.backgroundColor, strokeStyle: r2.borderColor, lineWidth: r2.borderWidth, hidden: isNaN(e2.datasets[0].data[i2]) || a2.data[i2].hidden, index: i2 };
        }) : [];
      } }, onClick: function(t2, e2) {
        var n2, i2, a2, r2 = e2.index, o2 = this.chart;
        for (n2 = 0, i2 = (o2.data.datasets || []).length; n2 < i2; ++n2) (a2 = o2.getDatasetMeta(n2)).data[r2].hidden = !a2.data[r2].hidden;
        o2.update();
      } }, tooltips: { callbacks: { title: function() {
        return "";
      }, label: function(t2, e2) {
        return e2.labels[t2.index] + ": " + t2.yLabel;
      } } } });
      var Xt = it.extend({ dataElementType: kt.Arc, linkScales: H.noop, _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"], _getIndexScaleId: function() {
        return this.chart.scale.id;
      }, _getValueScaleId: function() {
        return this.chart.scale.id;
      }, update: function(t2) {
        var e2, n2, i2, a2 = this, r2 = a2.getDataset(), o2 = a2.getMeta(), s2 = a2.chart.options.startAngle || 0, l2 = a2._starts = [], u2 = a2._angles = [], d2 = o2.data;
        for (a2._updateRadius(), o2.count = a2.countVisibleElements(), e2 = 0, n2 = r2.data.length; e2 < n2; e2++) l2[e2] = s2, i2 = a2._computeAngle(e2), u2[e2] = i2, s2 += i2;
        for (e2 = 0, n2 = d2.length; e2 < n2; ++e2) d2[e2]._options = a2._resolveDataElementOptions(d2[e2], e2), a2.updateElement(d2[e2], e2, t2);
      }, _updateRadius: function() {
        var t2 = this, e2 = t2.chart, n2 = e2.chartArea, i2 = e2.options, a2 = Math.min(n2.right - n2.left, n2.bottom - n2.top);
        e2.outerRadius = Math.max(a2 / 2, 0), e2.innerRadius = Math.max(i2.cutoutPercentage ? e2.outerRadius / 100 * i2.cutoutPercentage : 1, 0), e2.radiusLength = (e2.outerRadius - e2.innerRadius) / e2.getVisibleDatasetCount(), t2.outerRadius = e2.outerRadius - e2.radiusLength * t2.index, t2.innerRadius = t2.outerRadius - e2.radiusLength;
      }, updateElement: function(t2, e2, n2) {
        var i2 = this, a2 = i2.chart, r2 = i2.getDataset(), o2 = a2.options, s2 = o2.animation, l2 = a2.scale, u2 = a2.data.labels, d2 = l2.xCenter, h2 = l2.yCenter, c2 = o2.startAngle, f2 = t2.hidden ? 0 : l2.getDistanceFromCenterForValue(r2.data[e2]), g2 = i2._starts[e2], p2 = g2 + (t2.hidden ? 0 : i2._angles[e2]), m2 = s2.animateScale ? 0 : l2.getDistanceFromCenterForValue(r2.data[e2]), v2 = t2._options || {};
        H.extend(t2, { _datasetIndex: i2.index, _index: e2, _scale: l2, _model: { backgroundColor: v2.backgroundColor, borderColor: v2.borderColor, borderWidth: v2.borderWidth, borderAlign: v2.borderAlign, x: d2, y: h2, innerRadius: 0, outerRadius: n2 ? m2 : f2, startAngle: n2 && s2.animateRotate ? c2 : g2, endAngle: n2 && s2.animateRotate ? c2 : p2, label: H.valueAtIndexOrDefault(u2, e2, u2[e2]) } }), t2.pivot();
      }, countVisibleElements: function() {
        var t2 = this.getDataset(), e2 = this.getMeta(), n2 = 0;
        return H.each(e2.data, function(e3, i2) {
          isNaN(t2.data[i2]) || e3.hidden || n2++;
        }), n2;
      }, setHoverStyle: function(t2) {
        var e2 = t2._model, n2 = t2._options, i2 = H.getHoverColor, a2 = H.valueOrDefault;
        t2.$previousStyle = { backgroundColor: e2.backgroundColor, borderColor: e2.borderColor, borderWidth: e2.borderWidth }, e2.backgroundColor = a2(n2.hoverBackgroundColor, i2(n2.backgroundColor)), e2.borderColor = a2(n2.hoverBorderColor, i2(n2.borderColor)), e2.borderWidth = a2(n2.hoverBorderWidth, n2.borderWidth);
      }, _computeAngle: function(t2) {
        var e2 = this, n2 = this.getMeta().count, i2 = e2.getDataset(), a2 = e2.getMeta();
        if (isNaN(i2.data[t2]) || a2.data[t2].hidden) return 0;
        var r2 = { chart: e2.chart, dataIndex: t2, dataset: i2, datasetIndex: e2.index };
        return Gt([e2.chart.options.elements.arc.angle, 2 * Math.PI / n2], r2, t2);
      } });
      N._set("pie", H.clone(N.doughnut)), N._set("pie", { cutoutPercentage: 0 });
      var Kt = Bt, Zt = H.valueOrDefault;
      N._set("radar", { spanGaps: false, scale: { type: "radialLinear" }, elements: { line: { fill: "start", tension: 0 } } });
      var $t = it.extend({ datasetElementType: kt.Line, dataElementType: kt.Point, linkScales: H.noop, _datasetElementOptions: ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"], _dataElementOptions: { backgroundColor: "pointBackgroundColor", borderColor: "pointBorderColor", borderWidth: "pointBorderWidth", hitRadius: "pointHitRadius", hoverBackgroundColor: "pointHoverBackgroundColor", hoverBorderColor: "pointHoverBorderColor", hoverBorderWidth: "pointHoverBorderWidth", hoverRadius: "pointHoverRadius", pointStyle: "pointStyle", radius: "pointRadius", rotation: "pointRotation" }, _getIndexScaleId: function() {
        return this.chart.scale.id;
      }, _getValueScaleId: function() {
        return this.chart.scale.id;
      }, update: function(t2) {
        var e2, n2, i2 = this, a2 = i2.getMeta(), r2 = a2.dataset, o2 = a2.data || [], s2 = i2.chart.scale, l2 = i2._config;
        for (void 0 !== l2.tension && void 0 === l2.lineTension && (l2.lineTension = l2.tension), r2._scale = s2, r2._datasetIndex = i2.index, r2._children = o2, r2._loop = true, r2._model = i2._resolveDatasetElementOptions(r2), r2.pivot(), e2 = 0, n2 = o2.length; e2 < n2; ++e2) i2.updateElement(o2[e2], e2, t2);
        for (i2.updateBezierControlPoints(), e2 = 0, n2 = o2.length; e2 < n2; ++e2) o2[e2].pivot();
      }, updateElement: function(t2, e2, n2) {
        var i2 = this, a2 = t2.custom || {}, r2 = i2.getDataset(), o2 = i2.chart.scale, s2 = o2.getPointPositionForValue(e2, r2.data[e2]), l2 = i2._resolveDataElementOptions(t2, e2), u2 = i2.getMeta().dataset._model, d2 = n2 ? o2.xCenter : s2.x, h2 = n2 ? o2.yCenter : s2.y;
        t2._scale = o2, t2._options = l2, t2._datasetIndex = i2.index, t2._index = e2, t2._model = { x: d2, y: h2, skip: a2.skip || isNaN(d2) || isNaN(h2), radius: l2.radius, pointStyle: l2.pointStyle, rotation: l2.rotation, backgroundColor: l2.backgroundColor, borderColor: l2.borderColor, borderWidth: l2.borderWidth, tension: Zt(a2.tension, u2 ? u2.tension : 0), hitRadius: l2.hitRadius };
      }, _resolveDatasetElementOptions: function() {
        var t2 = this, e2 = t2._config, n2 = t2.chart.options, i2 = it.prototype._resolveDatasetElementOptions.apply(t2, arguments);
        return i2.spanGaps = Zt(e2.spanGaps, n2.spanGaps), i2.tension = Zt(e2.lineTension, n2.elements.line.tension), i2;
      }, updateBezierControlPoints: function() {
        var t2, e2, n2, i2, a2 = this.getMeta(), r2 = this.chart.chartArea, o2 = a2.data || [];
        function s2(t3, e3, n3) {
          return Math.max(Math.min(t3, n3), e3);
        }
        for (a2.dataset._model.spanGaps && (o2 = o2.filter(function(t3) {
          return !t3._model.skip;
        })), t2 = 0, e2 = o2.length; t2 < e2; ++t2) n2 = o2[t2]._model, i2 = H.splineCurve(H.previousItem(o2, t2, true)._model, n2, H.nextItem(o2, t2, true)._model, n2.tension), n2.controlPointPreviousX = s2(i2.previous.x, r2.left, r2.right), n2.controlPointPreviousY = s2(i2.previous.y, r2.top, r2.bottom), n2.controlPointNextX = s2(i2.next.x, r2.left, r2.right), n2.controlPointNextY = s2(i2.next.y, r2.top, r2.bottom);
      }, setHoverStyle: function(t2) {
        var e2 = t2._model, n2 = t2._options, i2 = H.getHoverColor;
        t2.$previousStyle = { backgroundColor: e2.backgroundColor, borderColor: e2.borderColor, borderWidth: e2.borderWidth, radius: e2.radius }, e2.backgroundColor = Zt(n2.hoverBackgroundColor, i2(n2.backgroundColor)), e2.borderColor = Zt(n2.hoverBorderColor, i2(n2.borderColor)), e2.borderWidth = Zt(n2.hoverBorderWidth, n2.borderWidth), e2.radius = Zt(n2.hoverRadius, n2.radius);
      } });
      N._set("scatter", { hover: { mode: "single" }, scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] }, tooltips: { callbacks: { title: function() {
        return "";
      }, label: function(t2) {
        return "(" + t2.xLabel + ", " + t2.yLabel + ")";
      } } } }), N._set("global", { datasets: { scatter: { showLine: false } } });
      var Jt = { bar: Tt, bubble: Ot, doughnut: Bt, horizontalBar: Et, line: Yt, polarArea: Xt, pie: Kt, radar: $t, scatter: Yt };
      function Qt(t2, e2) {
        return t2.native ? { x: t2.x, y: t2.y } : H.getRelativePosition(t2, e2);
      }
      function te(t2, e2) {
        var n2, i2, a2, r2, o2, s2, l2 = t2._getSortedVisibleDatasetMetas();
        for (i2 = 0, r2 = l2.length; i2 < r2; ++i2) for (a2 = 0, o2 = (n2 = l2[i2].data).length; a2 < o2; ++a2) (s2 = n2[a2])._view.skip || e2(s2);
      }
      function ee(t2, e2) {
        var n2 = [];
        return te(t2, function(t3) {
          t3.inRange(e2.x, e2.y) && n2.push(t3);
        }), n2;
      }
      function ne(t2, e2, n2, i2) {
        var a2 = Number.POSITIVE_INFINITY, r2 = [];
        return te(t2, function(t3) {
          if (!n2 || t3.inRange(e2.x, e2.y)) {
            var o2 = t3.getCenterPoint(), s2 = i2(e2, o2);
            s2 < a2 ? (r2 = [t3], a2 = s2) : s2 === a2 && r2.push(t3);
          }
        }), r2;
      }
      function ie(t2) {
        var e2 = -1 !== t2.indexOf("x"), n2 = -1 !== t2.indexOf("y");
        return function(t3, i2) {
          var a2 = e2 ? Math.abs(t3.x - i2.x) : 0, r2 = n2 ? Math.abs(t3.y - i2.y) : 0;
          return Math.sqrt(Math.pow(a2, 2) + Math.pow(r2, 2));
        };
      }
      function ae(t2, e2, n2) {
        var i2 = Qt(e2, t2);
        n2.axis = n2.axis || "x";
        var a2 = ie(n2.axis), r2 = n2.intersect ? ee(t2, i2) : ne(t2, i2, false, a2), o2 = [];
        return r2.length ? (t2._getSortedVisibleDatasetMetas().forEach(function(t3) {
          var e3 = t3.data[r2[0]._index];
          e3 && !e3._view.skip && o2.push(e3);
        }), o2) : [];
      }
      var re = { modes: { single: function(t2, e2) {
        var n2 = Qt(e2, t2), i2 = [];
        return te(t2, function(t3) {
          if (t3.inRange(n2.x, n2.y)) return i2.push(t3), i2;
        }), i2.slice(0, 1);
      }, label: ae, index: ae, dataset: function(t2, e2, n2) {
        var i2 = Qt(e2, t2);
        n2.axis = n2.axis || "xy";
        var a2 = ie(n2.axis), r2 = n2.intersect ? ee(t2, i2) : ne(t2, i2, false, a2);
        return r2.length > 0 && (r2 = t2.getDatasetMeta(r2[0]._datasetIndex).data), r2;
      }, "x-axis": function(t2, e2) {
        return ae(t2, e2, { intersect: false });
      }, point: function(t2, e2) {
        return ee(t2, Qt(e2, t2));
      }, nearest: function(t2, e2, n2) {
        var i2 = Qt(e2, t2);
        n2.axis = n2.axis || "xy";
        var a2 = ie(n2.axis);
        return ne(t2, i2, n2.intersect, a2);
      }, x: function(t2, e2, n2) {
        var i2 = Qt(e2, t2), a2 = [], r2 = false;
        return te(t2, function(t3) {
          t3.inXRange(i2.x) && a2.push(t3), t3.inRange(i2.x, i2.y) && (r2 = true);
        }), n2.intersect && !r2 && (a2 = []), a2;
      }, y: function(t2, e2, n2) {
        var i2 = Qt(e2, t2), a2 = [], r2 = false;
        return te(t2, function(t3) {
          t3.inYRange(i2.y) && a2.push(t3), t3.inRange(i2.x, i2.y) && (r2 = true);
        }), n2.intersect && !r2 && (a2 = []), a2;
      } } }, oe = H.extend;
      function se(t2, e2) {
        return H.where(t2, function(t3) {
          return t3.pos === e2;
        });
      }
      function le(t2, e2) {
        return t2.sort(function(t3, n2) {
          var i2 = e2 ? n2 : t3, a2 = e2 ? t3 : n2;
          return i2.weight === a2.weight ? i2.index - a2.index : i2.weight - a2.weight;
        });
      }
      function ue(t2, e2, n2, i2) {
        return Math.max(t2[n2], e2[n2]) + Math.max(t2[i2], e2[i2]);
      }
      function de(t2, e2, n2) {
        var i2, a2, r2 = n2.box, o2 = t2.maxPadding;
        if (n2.size && (t2[n2.pos] -= n2.size), n2.size = n2.horizontal ? r2.height : r2.width, t2[n2.pos] += n2.size, r2.getPadding) {
          var s2 = r2.getPadding();
          o2.top = Math.max(o2.top, s2.top), o2.left = Math.max(o2.left, s2.left), o2.bottom = Math.max(o2.bottom, s2.bottom), o2.right = Math.max(o2.right, s2.right);
        }
        if (i2 = e2.outerWidth - ue(o2, t2, "left", "right"), a2 = e2.outerHeight - ue(o2, t2, "top", "bottom"), i2 !== t2.w || a2 !== t2.h) {
          t2.w = i2, t2.h = a2;
          var l2 = n2.horizontal ? [i2, t2.w] : [a2, t2.h];
          return !(l2[0] === l2[1] || isNaN(l2[0]) && isNaN(l2[1]));
        }
      }
      function he(t2, e2) {
        var n2 = e2.maxPadding;
        function i2(t3) {
          var i3 = { left: 0, top: 0, right: 0, bottom: 0 };
          return t3.forEach(function(t4) {
            i3[t4] = Math.max(e2[t4], n2[t4]);
          }), i3;
        }
        return i2(t2 ? ["left", "right"] : ["top", "bottom"]);
      }
      function ce(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2, u2 = [];
        for (i2 = 0, a2 = t2.length; i2 < a2; ++i2) (o2 = (r2 = t2[i2]).box).update(r2.width || e2.w, r2.height || e2.h, he(r2.horizontal, e2)), de(e2, n2, r2) && (l2 = true, u2.length && (s2 = true)), o2.fullWidth || u2.push(r2);
        return s2 && ce(u2, e2, n2) || l2;
      }
      function fe(t2, e2, n2) {
        var i2, a2, r2, o2, s2 = n2.padding, l2 = e2.x, u2 = e2.y;
        for (i2 = 0, a2 = t2.length; i2 < a2; ++i2) o2 = (r2 = t2[i2]).box, r2.horizontal ? (o2.left = o2.fullWidth ? s2.left : e2.left, o2.right = o2.fullWidth ? n2.outerWidth - s2.right : e2.left + e2.w, o2.top = u2, o2.bottom = u2 + o2.height, o2.width = o2.right - o2.left, u2 = o2.bottom) : (o2.left = l2, o2.right = l2 + o2.width, o2.top = e2.top, o2.bottom = e2.top + e2.h, o2.height = o2.bottom - o2.top, l2 = o2.right);
        e2.x = l2, e2.y = u2;
      }
      N._set("global", { layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } } });
      var ge, pe = { defaults: {}, addBox: function(t2, e2) {
        t2.boxes || (t2.boxes = []), e2.fullWidth = e2.fullWidth || false, e2.position = e2.position || "top", e2.weight = e2.weight || 0, e2._layers = e2._layers || function() {
          return [{ z: 0, draw: function() {
            e2.draw.apply(e2, arguments);
          } }];
        }, t2.boxes.push(e2);
      }, removeBox: function(t2, e2) {
        var n2 = t2.boxes ? t2.boxes.indexOf(e2) : -1;
        -1 !== n2 && t2.boxes.splice(n2, 1);
      }, configure: function(t2, e2, n2) {
        for (var i2, a2 = ["fullWidth", "position", "weight"], r2 = a2.length, o2 = 0; o2 < r2; ++o2) i2 = a2[o2], n2.hasOwnProperty(i2) && (e2[i2] = n2[i2]);
      }, update: function(t2, e2, n2) {
        if (t2) {
          var i2 = t2.options.layout || {}, a2 = H.options.toPadding(i2.padding), r2 = e2 - a2.width, o2 = n2 - a2.height, s2 = function(t3) {
            var e3 = function(t4) {
              var e4, n4, i4, a4 = [];
              for (e4 = 0, n4 = (t4 || []).length; e4 < n4; ++e4) i4 = t4[e4], a4.push({ index: e4, box: i4, pos: i4.position, horizontal: i4.isHorizontal(), weight: i4.weight });
              return a4;
            }(t3), n3 = le(se(e3, "left"), true), i3 = le(se(e3, "right")), a3 = le(se(e3, "top"), true), r3 = le(se(e3, "bottom"));
            return { leftAndTop: n3.concat(a3), rightAndBottom: i3.concat(r3), chartArea: se(e3, "chartArea"), vertical: n3.concat(i3), horizontal: a3.concat(r3) };
          }(t2.boxes), l2 = s2.vertical, u2 = s2.horizontal, d2 = Object.freeze({ outerWidth: e2, outerHeight: n2, padding: a2, availableWidth: r2, vBoxMaxWidth: r2 / 2 / l2.length, hBoxMaxHeight: o2 / 2 }), h2 = oe({ maxPadding: oe({}, a2), w: r2, h: o2, x: a2.left, y: a2.top }, a2);
          !function(t3, e3) {
            var n3, i3, a3;
            for (n3 = 0, i3 = t3.length; n3 < i3; ++n3) (a3 = t3[n3]).width = a3.horizontal ? a3.box.fullWidth && e3.availableWidth : e3.vBoxMaxWidth, a3.height = a3.horizontal && e3.hBoxMaxHeight;
          }(l2.concat(u2), d2), ce(l2, h2, d2), ce(u2, h2, d2) && ce(l2, h2, d2), function(t3) {
            var e3 = t3.maxPadding;
            function n3(n4) {
              var i3 = Math.max(e3[n4] - t3[n4], 0);
              return t3[n4] += i3, i3;
            }
            t3.y += n3("top"), t3.x += n3("left"), n3("right"), n3("bottom");
          }(h2), fe(s2.leftAndTop, h2, d2), h2.x += h2.w, h2.y += h2.h, fe(s2.rightAndBottom, h2, d2), t2.chartArea = { left: h2.left, top: h2.top, right: h2.left + h2.w, bottom: h2.top + h2.h }, H.each(s2.chartArea, function(e3) {
            var n3 = e3.box;
            oe(n3, t2.chartArea), n3.update(h2.w, h2.h);
          });
        }
      } }, me = (ge = Object.freeze({ __proto__: null, default: "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}" })) && ge.default || ge, ve = "$chartjs", be = "chartjs-size-monitor", xe = "chartjs-render-monitor", ye = "chartjs-render-animation", _e = ["animationstart", "webkitAnimationStart"], ke = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" };
      function we(t2, e2) {
        var n2 = H.getStyle(t2, e2), i2 = n2 && n2.match(/^(\d+)(\.\d+)?px$/);
        return i2 ? Number(i2[1]) : void 0;
      }
      var Me = !!function() {
        var t2 = false;
        try {
          var e2 = Object.defineProperty({}, "passive", { get: function() {
            t2 = true;
          } });
          window.addEventListener("e", null, e2);
        } catch (t3) {
        }
        return t2;
      }() && { passive: true };
      function Se(t2, e2, n2) {
        t2.addEventListener(e2, n2, Me);
      }
      function Ce(t2, e2, n2) {
        t2.removeEventListener(e2, n2, Me);
      }
      function Pe(t2, e2, n2, i2, a2) {
        return { type: t2, chart: e2, native: a2 || null, x: void 0 !== n2 ? n2 : null, y: void 0 !== i2 ? i2 : null };
      }
      function Ae(t2) {
        var e2 = document.createElement("div");
        return e2.className = t2 || "", e2;
      }
      function De(t2, e2, n2) {
        var i2, a2, r2, o2, s2 = t2[ve] || (t2[ve] = {}), l2 = s2.resizer = function(t3) {
          var e3 = Ae(be), n3 = Ae(be + "-expand"), i3 = Ae(be + "-shrink");
          n3.appendChild(Ae()), i3.appendChild(Ae()), e3.appendChild(n3), e3.appendChild(i3), e3._reset = function() {
            n3.scrollLeft = 1e6, n3.scrollTop = 1e6, i3.scrollLeft = 1e6, i3.scrollTop = 1e6;
          };
          var a3 = function() {
            e3._reset(), t3();
          };
          return Se(n3, "scroll", a3.bind(n3, "expand")), Se(i3, "scroll", a3.bind(i3, "shrink")), e3;
        }((i2 = function() {
          if (s2.resizer) {
            var i3 = n2.options.maintainAspectRatio && t2.parentNode, a3 = i3 ? i3.clientWidth : 0;
            e2(Pe("resize", n2)), i3 && i3.clientWidth < a3 && n2.canvas && e2(Pe("resize", n2));
          }
        }, r2 = false, o2 = [], function() {
          o2 = Array.prototype.slice.call(arguments), a2 = a2 || this, r2 || (r2 = true, H.requestAnimFrame.call(window, function() {
            r2 = false, i2.apply(a2, o2);
          }));
        }));
        !function(t3, e3) {
          var n3 = t3[ve] || (t3[ve] = {}), i3 = n3.renderProxy = function(t4) {
            t4.animationName === ye && e3();
          };
          H.each(_e, function(e4) {
            Se(t3, e4, i3);
          }), n3.reflow = !!t3.offsetParent, t3.classList.add(xe);
        }(t2, function() {
          if (s2.resizer) {
            var e3 = t2.parentNode;
            e3 && e3 !== l2.parentNode && e3.insertBefore(l2, e3.firstChild), l2._reset();
          }
        });
      }
      function Te(t2) {
        var e2 = t2[ve] || {}, n2 = e2.resizer;
        delete e2.resizer, function(t3) {
          var e3 = t3[ve] || {}, n3 = e3.renderProxy;
          n3 && (H.each(_e, function(e4) {
            Ce(t3, e4, n3);
          }), delete e3.renderProxy), t3.classList.remove(xe);
        }(t2), n2 && n2.parentNode && n2.parentNode.removeChild(n2);
      }
      var Ie = { disableCSSInjection: false, _enabled: "undefined" != typeof window && "undefined" != typeof document, _ensureLoaded: function(t2) {
        if (!this.disableCSSInjection) {
          var e2 = t2.getRootNode ? t2.getRootNode() : document;
          !function(t3, e3) {
            var n2 = t3[ve] || (t3[ve] = {});
            if (!n2.containsStyles) {
              n2.containsStyles = true, e3 = "/* Chart.js */\n" + e3;
              var i2 = document.createElement("style");
              i2.setAttribute("type", "text/css"), i2.appendChild(document.createTextNode(e3)), t3.appendChild(i2);
            }
          }(e2.host ? e2 : document.head, me);
        }
      }, acquireContext: function(t2, e2) {
        "string" == typeof t2 ? t2 = document.getElementById(t2) : t2.length && (t2 = t2[0]), t2 && t2.canvas && (t2 = t2.canvas);
        var n2 = t2 && t2.getContext && t2.getContext("2d");
        return n2 && n2.canvas === t2 ? (this._ensureLoaded(t2), function(t3, e3) {
          var n3 = t3.style, i2 = t3.getAttribute("height"), a2 = t3.getAttribute("width");
          if (t3[ve] = { initial: { height: i2, width: a2, style: { display: n3.display, height: n3.height, width: n3.width } } }, n3.display = n3.display || "block", null === a2 || "" === a2) {
            var r2 = we(t3, "width");
            void 0 !== r2 && (t3.width = r2);
          }
          if (null === i2 || "" === i2) if ("" === t3.style.height) t3.height = t3.width / (e3.options.aspectRatio || 2);
          else {
            var o2 = we(t3, "height");
            void 0 !== r2 && (t3.height = o2);
          }
        }(t2, e2), n2) : null;
      }, releaseContext: function(t2) {
        var e2 = t2.canvas;
        if (e2[ve]) {
          var n2 = e2[ve].initial;
          ["height", "width"].forEach(function(t3) {
            var i2 = n2[t3];
            H.isNullOrUndef(i2) ? e2.removeAttribute(t3) : e2.setAttribute(t3, i2);
          }), H.each(n2.style || {}, function(t3, n3) {
            e2.style[n3] = t3;
          }), e2.width = e2.width, delete e2[ve];
        }
      }, addEventListener: function(t2, e2, n2) {
        var i2 = t2.canvas;
        if ("resize" !== e2) {
          var a2 = n2[ve] || (n2[ve] = {});
          Se(i2, e2, (a2.proxies || (a2.proxies = {}))[t2.id + "_" + e2] = function(e3) {
            n2(function(t3, e4) {
              var n3 = ke[t3.type] || t3.type, i3 = H.getRelativePosition(t3, e4);
              return Pe(n3, e4, i3.x, i3.y, t3);
            }(e3, t2));
          });
        } else De(i2, n2, t2);
      }, removeEventListener: function(t2, e2, n2) {
        var i2 = t2.canvas;
        if ("resize" !== e2) {
          var a2 = ((n2[ve] || {}).proxies || {})[t2.id + "_" + e2];
          a2 && Ce(i2, e2, a2);
        } else Te(i2);
      } };
      H.addEvent = Se, H.removeEvent = Ce;
      var Fe = Ie._enabled ? Ie : { acquireContext: function(t2) {
        return t2 && t2.canvas && (t2 = t2.canvas), t2 && t2.getContext("2d") || null;
      } }, Oe = H.extend({ initialize: function() {
      }, acquireContext: function() {
      }, releaseContext: function() {
      }, addEventListener: function() {
      }, removeEventListener: function() {
      } }, Fe);
      N._set("global", { plugins: {} });
      var Le = { _plugins: [], _cacheId: 0, register: function(t2) {
        var e2 = this._plugins;
        [].concat(t2).forEach(function(t3) {
          -1 === e2.indexOf(t3) && e2.push(t3);
        }), this._cacheId++;
      }, unregister: function(t2) {
        var e2 = this._plugins;
        [].concat(t2).forEach(function(t3) {
          var n2 = e2.indexOf(t3);
          -1 !== n2 && e2.splice(n2, 1);
        }), this._cacheId++;
      }, clear: function() {
        this._plugins = [], this._cacheId++;
      }, count: function() {
        return this._plugins.length;
      }, getAll: function() {
        return this._plugins;
      }, notify: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2 = this.descriptors(t2), u2 = l2.length;
        for (i2 = 0; i2 < u2; ++i2) if ("function" == typeof (s2 = (r2 = (a2 = l2[i2]).plugin)[e2]) && ((o2 = [t2].concat(n2 || [])).push(a2.options), false === s2.apply(r2, o2))) return false;
        return true;
      }, descriptors: function(t2) {
        var e2 = t2.$plugins || (t2.$plugins = {});
        if (e2.id === this._cacheId) return e2.descriptors;
        var n2 = [], i2 = [], a2 = t2 && t2.config || {}, r2 = a2.options && a2.options.plugins || {};
        return this._plugins.concat(a2.plugins || []).forEach(function(t3) {
          if (-1 === n2.indexOf(t3)) {
            var e3 = t3.id, a3 = r2[e3];
            false !== a3 && (true === a3 && (a3 = H.clone(N.global.plugins[e3])), n2.push(t3), i2.push({ plugin: t3, options: a3 || {} }));
          }
        }), e2.descriptors = i2, e2.id = this._cacheId, i2;
      }, _invalidate: function(t2) {
        delete t2.$plugins;
      } }, Re = { constructors: {}, defaults: {}, registerScaleType: function(t2, e2, n2) {
        this.constructors[t2] = e2, this.defaults[t2] = H.clone(n2);
      }, getScaleConstructor: function(t2) {
        return this.constructors.hasOwnProperty(t2) ? this.constructors[t2] : void 0;
      }, getScaleDefaults: function(t2) {
        return this.defaults.hasOwnProperty(t2) ? H.merge(/* @__PURE__ */ Object.create(null), [N.scale, this.defaults[t2]]) : {};
      }, updateScaleDefaults: function(t2, e2) {
        this.defaults.hasOwnProperty(t2) && (this.defaults[t2] = H.extend(this.defaults[t2], e2));
      }, addScalesToLayout: function(t2) {
        H.each(t2.scales, function(e2) {
          e2.fullWidth = e2.options.fullWidth, e2.position = e2.options.position, e2.weight = e2.options.weight, pe.addBox(t2, e2);
        });
      } }, ze = H.valueOrDefault, Ne = H.rtl.getRtlAdapter;
      N._set("global", { tooltips: { enabled: true, custom: null, mode: "nearest", position: "average", intersect: true, backgroundColor: "rgba(0,0,0,0.8)", titleFontStyle: "bold", titleSpacing: 2, titleMarginBottom: 6, titleFontColor: "#fff", titleAlign: "left", bodySpacing: 2, bodyFontColor: "#fff", bodyAlign: "left", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor: "#fff", footerAlign: "left", yPadding: 6, xPadding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, multiKeyBackground: "#fff", displayColors: true, borderColor: "rgba(0,0,0,0)", borderWidth: 0, callbacks: { beforeTitle: H.noop, title: function(t2, e2) {
        var n2 = "", i2 = e2.labels, a2 = i2 ? i2.length : 0;
        if (t2.length > 0) {
          var r2 = t2[0];
          r2.label ? n2 = r2.label : r2.xLabel ? n2 = r2.xLabel : a2 > 0 && r2.index < a2 && (n2 = i2[r2.index]);
        }
        return n2;
      }, afterTitle: H.noop, beforeBody: H.noop, beforeLabel: H.noop, label: function(t2, e2) {
        var n2 = e2.datasets[t2.datasetIndex].label || "";
        return n2 && (n2 += ": "), H.isNullOrUndef(t2.value) ? n2 += t2.yLabel : n2 += t2.value, n2;
      }, labelColor: function(t2, e2) {
        var n2 = e2.getDatasetMeta(t2.datasetIndex).data[t2.index]._view;
        return { borderColor: n2.borderColor, backgroundColor: n2.backgroundColor };
      }, labelTextColor: function() {
        return this._options.bodyFontColor;
      }, afterLabel: H.noop, afterBody: H.noop, beforeFooter: H.noop, footer: H.noop, afterFooter: H.noop } } });
      var Be = { average: function(t2) {
        if (!t2.length) return false;
        var e2, n2, i2 = 0, a2 = 0, r2 = 0;
        for (e2 = 0, n2 = t2.length; e2 < n2; ++e2) {
          var o2 = t2[e2];
          if (o2 && o2.hasValue()) {
            var s2 = o2.tooltipPosition();
            i2 += s2.x, a2 += s2.y, ++r2;
          }
        }
        return { x: i2 / r2, y: a2 / r2 };
      }, nearest: function(t2, e2) {
        var n2, i2, a2, r2 = e2.x, o2 = e2.y, s2 = Number.POSITIVE_INFINITY;
        for (n2 = 0, i2 = t2.length; n2 < i2; ++n2) {
          var l2 = t2[n2];
          if (l2 && l2.hasValue()) {
            var u2 = l2.getCenterPoint(), d2 = H.distanceBetweenPoints(e2, u2);
            d2 < s2 && (s2 = d2, a2 = l2);
          }
        }
        if (a2) {
          var h2 = a2.tooltipPosition();
          r2 = h2.x, o2 = h2.y;
        }
        return { x: r2, y: o2 };
      } };
      function Ee(t2, e2) {
        return e2 && (H.isArray(e2) ? Array.prototype.push.apply(t2, e2) : t2.push(e2)), t2;
      }
      function We(t2) {
        return ("string" == typeof t2 || t2 instanceof String) && t2.indexOf("\n") > -1 ? t2.split("\n") : t2;
      }
      function Ve(t2) {
        var e2 = N.global;
        return { xPadding: t2.xPadding, yPadding: t2.yPadding, xAlign: t2.xAlign, yAlign: t2.yAlign, rtl: t2.rtl, textDirection: t2.textDirection, bodyFontColor: t2.bodyFontColor, _bodyFontFamily: ze(t2.bodyFontFamily, e2.defaultFontFamily), _bodyFontStyle: ze(t2.bodyFontStyle, e2.defaultFontStyle), _bodyAlign: t2.bodyAlign, bodyFontSize: ze(t2.bodyFontSize, e2.defaultFontSize), bodySpacing: t2.bodySpacing, titleFontColor: t2.titleFontColor, _titleFontFamily: ze(t2.titleFontFamily, e2.defaultFontFamily), _titleFontStyle: ze(t2.titleFontStyle, e2.defaultFontStyle), titleFontSize: ze(t2.titleFontSize, e2.defaultFontSize), _titleAlign: t2.titleAlign, titleSpacing: t2.titleSpacing, titleMarginBottom: t2.titleMarginBottom, footerFontColor: t2.footerFontColor, _footerFontFamily: ze(t2.footerFontFamily, e2.defaultFontFamily), _footerFontStyle: ze(t2.footerFontStyle, e2.defaultFontStyle), footerFontSize: ze(t2.footerFontSize, e2.defaultFontSize), _footerAlign: t2.footerAlign, footerSpacing: t2.footerSpacing, footerMarginTop: t2.footerMarginTop, caretSize: t2.caretSize, cornerRadius: t2.cornerRadius, backgroundColor: t2.backgroundColor, opacity: 0, legendColorBackground: t2.multiKeyBackground, displayColors: t2.displayColors, borderColor: t2.borderColor, borderWidth: t2.borderWidth };
      }
      function He(t2, e2) {
        return "center" === e2 ? t2.x + t2.width / 2 : "right" === e2 ? t2.x + t2.width - t2.xPadding : t2.x + t2.xPadding;
      }
      function je(t2) {
        return Ee([], We(t2));
      }
      var qe = K.extend({ initialize: function() {
        this._model = Ve(this._options), this._lastActive = [];
      }, getTitle: function() {
        var t2 = this, e2 = t2._options, n2 = e2.callbacks, i2 = n2.beforeTitle.apply(t2, arguments), a2 = n2.title.apply(t2, arguments), r2 = n2.afterTitle.apply(t2, arguments), o2 = [];
        return o2 = Ee(o2, We(i2)), o2 = Ee(o2, We(a2)), o2 = Ee(o2, We(r2));
      }, getBeforeBody: function() {
        return je(this._options.callbacks.beforeBody.apply(this, arguments));
      }, getBody: function(t2, e2) {
        var n2 = this, i2 = n2._options.callbacks, a2 = [];
        return H.each(t2, function(t3) {
          var r2 = { before: [], lines: [], after: [] };
          Ee(r2.before, We(i2.beforeLabel.call(n2, t3, e2))), Ee(r2.lines, i2.label.call(n2, t3, e2)), Ee(r2.after, We(i2.afterLabel.call(n2, t3, e2))), a2.push(r2);
        }), a2;
      }, getAfterBody: function() {
        return je(this._options.callbacks.afterBody.apply(this, arguments));
      }, getFooter: function() {
        var t2 = this, e2 = t2._options.callbacks, n2 = e2.beforeFooter.apply(t2, arguments), i2 = e2.footer.apply(t2, arguments), a2 = e2.afterFooter.apply(t2, arguments), r2 = [];
        return r2 = Ee(r2, We(n2)), r2 = Ee(r2, We(i2)), r2 = Ee(r2, We(a2));
      }, update: function(t2) {
        var e2, n2, i2, a2, r2, o2, s2, l2, u2, d2, h2 = this, c2 = h2._options, f2 = h2._model, g2 = h2._model = Ve(c2), p2 = h2._active, m2 = h2._data, v2 = { xAlign: f2.xAlign, yAlign: f2.yAlign }, b2 = { x: f2.x, y: f2.y }, x2 = { width: f2.width, height: f2.height }, y2 = { x: f2.caretX, y: f2.caretY };
        if (p2.length) {
          g2.opacity = 1;
          var _2 = [], k2 = [];
          y2 = Be[c2.position].call(h2, p2, h2._eventPosition);
          var w2 = [];
          for (e2 = 0, n2 = p2.length; e2 < n2; ++e2) w2.push((i2 = p2[e2], a2 = void 0, r2 = void 0, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, d2 = void 0, a2 = i2._xScale, r2 = i2._yScale || i2._scale, o2 = i2._index, s2 = i2._datasetIndex, l2 = i2._chart.getDatasetMeta(s2).controller, u2 = l2._getIndexScale(), d2 = l2._getValueScale(), { xLabel: a2 ? a2.getLabelForIndex(o2, s2) : "", yLabel: r2 ? r2.getLabelForIndex(o2, s2) : "", label: u2 ? "" + u2.getLabelForIndex(o2, s2) : "", value: d2 ? "" + d2.getLabelForIndex(o2, s2) : "", index: o2, datasetIndex: s2, x: i2._model.x, y: i2._model.y }));
          c2.filter && (w2 = w2.filter(function(t3) {
            return c2.filter(t3, m2);
          })), c2.itemSort && (w2 = w2.sort(function(t3, e3) {
            return c2.itemSort(t3, e3, m2);
          })), H.each(w2, function(t3) {
            _2.push(c2.callbacks.labelColor.call(h2, t3, h2._chart)), k2.push(c2.callbacks.labelTextColor.call(h2, t3, h2._chart));
          }), g2.title = h2.getTitle(w2, m2), g2.beforeBody = h2.getBeforeBody(w2, m2), g2.body = h2.getBody(w2, m2), g2.afterBody = h2.getAfterBody(w2, m2), g2.footer = h2.getFooter(w2, m2), g2.x = y2.x, g2.y = y2.y, g2.caretPadding = c2.caretPadding, g2.labelColors = _2, g2.labelTextColors = k2, g2.dataPoints = w2, x2 = function(t3, e3) {
            var n3 = t3._chart.ctx, i3 = 2 * e3.yPadding, a3 = 0, r3 = e3.body, o3 = r3.reduce(function(t4, e4) {
              return t4 + e4.before.length + e4.lines.length + e4.after.length;
            }, 0);
            o3 += e3.beforeBody.length + e3.afterBody.length;
            var s3 = e3.title.length, l3 = e3.footer.length, u3 = e3.titleFontSize, d3 = e3.bodyFontSize, h3 = e3.footerFontSize;
            i3 += s3 * u3, i3 += s3 ? (s3 - 1) * e3.titleSpacing : 0, i3 += s3 ? e3.titleMarginBottom : 0, i3 += o3 * d3, i3 += o3 ? (o3 - 1) * e3.bodySpacing : 0, i3 += l3 ? e3.footerMarginTop : 0, i3 += l3 * h3, i3 += l3 ? (l3 - 1) * e3.footerSpacing : 0;
            var c3 = 0, f3 = function(t4) {
              a3 = Math.max(a3, n3.measureText(t4).width + c3);
            };
            return n3.font = H.fontString(u3, e3._titleFontStyle, e3._titleFontFamily), H.each(e3.title, f3), n3.font = H.fontString(d3, e3._bodyFontStyle, e3._bodyFontFamily), H.each(e3.beforeBody.concat(e3.afterBody), f3), c3 = e3.displayColors ? d3 + 2 : 0, H.each(r3, function(t4) {
              H.each(t4.before, f3), H.each(t4.lines, f3), H.each(t4.after, f3);
            }), c3 = 0, n3.font = H.fontString(h3, e3._footerFontStyle, e3._footerFontFamily), H.each(e3.footer, f3), { width: a3 += 2 * e3.xPadding, height: i3 };
          }(this, g2), b2 = function(t3, e3, n3, i3) {
            var a3 = t3.x, r3 = t3.y, o3 = t3.caretSize, s3 = t3.caretPadding, l3 = t3.cornerRadius, u3 = n3.xAlign, d3 = n3.yAlign, h3 = o3 + s3, c3 = l3 + s3;
            return "right" === u3 ? a3 -= e3.width : "center" === u3 && ((a3 -= e3.width / 2) + e3.width > i3.width && (a3 = i3.width - e3.width), a3 < 0 && (a3 = 0)), "top" === d3 ? r3 += h3 : r3 -= "bottom" === d3 ? e3.height + h3 : e3.height / 2, "center" === d3 ? "left" === u3 ? a3 += h3 : "right" === u3 && (a3 -= h3) : "left" === u3 ? a3 -= c3 : "right" === u3 && (a3 += c3), { x: a3, y: r3 };
          }(g2, x2, v2 = function(t3, e3) {
            var n3, i3, a3, r3, o3, s3 = t3._model, l3 = t3._chart, u3 = t3._chart.chartArea, d3 = "center", h3 = "center";
            s3.y < e3.height ? h3 = "top" : s3.y > l3.height - e3.height && (h3 = "bottom");
            var c3 = (u3.left + u3.right) / 2, f3 = (u3.top + u3.bottom) / 2;
            "center" === h3 ? (n3 = function(t4) {
              return t4 <= c3;
            }, i3 = function(t4) {
              return t4 > c3;
            }) : (n3 = function(t4) {
              return t4 <= e3.width / 2;
            }, i3 = function(t4) {
              return t4 >= l3.width - e3.width / 2;
            }), a3 = function(t4) {
              return t4 + e3.width + s3.caretSize + s3.caretPadding > l3.width;
            }, r3 = function(t4) {
              return t4 - e3.width - s3.caretSize - s3.caretPadding < 0;
            }, o3 = function(t4) {
              return t4 <= f3 ? "top" : "bottom";
            }, n3(s3.x) ? (d3 = "left", a3(s3.x) && (d3 = "center", h3 = o3(s3.y))) : i3(s3.x) && (d3 = "right", r3(s3.x) && (d3 = "center", h3 = o3(s3.y)));
            var g3 = t3._options;
            return { xAlign: g3.xAlign ? g3.xAlign : d3, yAlign: g3.yAlign ? g3.yAlign : h3 };
          }(this, x2), h2._chart);
        } else g2.opacity = 0;
        return g2.xAlign = v2.xAlign, g2.yAlign = v2.yAlign, g2.x = b2.x, g2.y = b2.y, g2.width = x2.width, g2.height = x2.height, g2.caretX = y2.x, g2.caretY = y2.y, h2._model = g2, t2 && c2.custom && c2.custom.call(h2, g2), h2;
      }, drawCaret: function(t2, e2) {
        var n2 = this._chart.ctx, i2 = this._view, a2 = this.getCaretPosition(t2, e2, i2);
        n2.lineTo(a2.x1, a2.y1), n2.lineTo(a2.x2, a2.y2), n2.lineTo(a2.x3, a2.y3);
      }, getCaretPosition: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2, u2 = n2.caretSize, d2 = n2.cornerRadius, h2 = n2.xAlign, c2 = n2.yAlign, f2 = t2.x, g2 = t2.y, p2 = e2.width, m2 = e2.height;
        if ("center" === c2) s2 = g2 + m2 / 2, "left" === h2 ? (a2 = (i2 = f2) - u2, r2 = i2, o2 = s2 + u2, l2 = s2 - u2) : (a2 = (i2 = f2 + p2) + u2, r2 = i2, o2 = s2 - u2, l2 = s2 + u2);
        else if ("left" === h2 ? (i2 = (a2 = f2 + d2 + u2) - u2, r2 = a2 + u2) : "right" === h2 ? (i2 = (a2 = f2 + p2 - d2 - u2) - u2, r2 = a2 + u2) : (i2 = (a2 = n2.caretX) - u2, r2 = a2 + u2), "top" === c2) s2 = (o2 = g2) - u2, l2 = o2;
        else {
          s2 = (o2 = g2 + m2) + u2, l2 = o2;
          var v2 = r2;
          r2 = i2, i2 = v2;
        }
        return { x1: i2, x2: a2, x3: r2, y1: o2, y2: s2, y3: l2 };
      }, drawTitle: function(t2, e2, n2) {
        var i2, a2, r2, o2 = e2.title, s2 = o2.length;
        if (s2) {
          var l2 = Ne(e2.rtl, e2.x, e2.width);
          for (t2.x = He(e2, e2._titleAlign), n2.textAlign = l2.textAlign(e2._titleAlign), n2.textBaseline = "middle", i2 = e2.titleFontSize, a2 = e2.titleSpacing, n2.fillStyle = e2.titleFontColor, n2.font = H.fontString(i2, e2._titleFontStyle, e2._titleFontFamily), r2 = 0; r2 < s2; ++r2) n2.fillText(o2[r2], l2.x(t2.x), t2.y + i2 / 2), t2.y += i2 + a2, r2 + 1 === s2 && (t2.y += e2.titleMarginBottom - a2);
        }
      }, drawBody: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2, u2, d2, h2 = e2.bodyFontSize, c2 = e2.bodySpacing, f2 = e2._bodyAlign, g2 = e2.body, p2 = e2.displayColors, m2 = 0, v2 = p2 ? He(e2, "left") : 0, b2 = Ne(e2.rtl, e2.x, e2.width), x2 = function(e3) {
          n2.fillText(e3, b2.x(t2.x + m2), t2.y + h2 / 2), t2.y += h2 + c2;
        }, y2 = b2.textAlign(f2);
        for (n2.textAlign = f2, n2.textBaseline = "middle", n2.font = H.fontString(h2, e2._bodyFontStyle, e2._bodyFontFamily), t2.x = He(e2, y2), n2.fillStyle = e2.bodyFontColor, H.each(e2.beforeBody, x2), m2 = p2 && "right" !== y2 ? "center" === f2 ? h2 / 2 + 1 : h2 + 2 : 0, s2 = 0, u2 = g2.length; s2 < u2; ++s2) {
          for (i2 = g2[s2], a2 = e2.labelTextColors[s2], r2 = e2.labelColors[s2], n2.fillStyle = a2, H.each(i2.before, x2), l2 = 0, d2 = (o2 = i2.lines).length; l2 < d2; ++l2) {
            if (p2) {
              var _2 = b2.x(v2);
              n2.fillStyle = e2.legendColorBackground, n2.fillRect(b2.leftForLtr(_2, h2), t2.y, h2, h2), n2.lineWidth = 1, n2.strokeStyle = r2.borderColor, n2.strokeRect(b2.leftForLtr(_2, h2), t2.y, h2, h2), n2.fillStyle = r2.backgroundColor, n2.fillRect(b2.leftForLtr(b2.xPlus(_2, 1), h2 - 2), t2.y + 1, h2 - 2, h2 - 2), n2.fillStyle = a2;
            }
            x2(o2[l2]);
          }
          H.each(i2.after, x2);
        }
        m2 = 0, H.each(e2.afterBody, x2), t2.y -= c2;
      }, drawFooter: function(t2, e2, n2) {
        var i2, a2, r2 = e2.footer, o2 = r2.length;
        if (o2) {
          var s2 = Ne(e2.rtl, e2.x, e2.width);
          for (t2.x = He(e2, e2._footerAlign), t2.y += e2.footerMarginTop, n2.textAlign = s2.textAlign(e2._footerAlign), n2.textBaseline = "middle", i2 = e2.footerFontSize, n2.fillStyle = e2.footerFontColor, n2.font = H.fontString(i2, e2._footerFontStyle, e2._footerFontFamily), a2 = 0; a2 < o2; ++a2) n2.fillText(r2[a2], s2.x(t2.x), t2.y + i2 / 2), t2.y += i2 + e2.footerSpacing;
        }
      }, drawBackground: function(t2, e2, n2, i2) {
        n2.fillStyle = e2.backgroundColor, n2.strokeStyle = e2.borderColor, n2.lineWidth = e2.borderWidth;
        var a2 = e2.xAlign, r2 = e2.yAlign, o2 = t2.x, s2 = t2.y, l2 = i2.width, u2 = i2.height, d2 = e2.cornerRadius;
        n2.beginPath(), n2.moveTo(o2 + d2, s2), "top" === r2 && this.drawCaret(t2, i2), n2.lineTo(o2 + l2 - d2, s2), n2.quadraticCurveTo(o2 + l2, s2, o2 + l2, s2 + d2), "center" === r2 && "right" === a2 && this.drawCaret(t2, i2), n2.lineTo(o2 + l2, s2 + u2 - d2), n2.quadraticCurveTo(o2 + l2, s2 + u2, o2 + l2 - d2, s2 + u2), "bottom" === r2 && this.drawCaret(t2, i2), n2.lineTo(o2 + d2, s2 + u2), n2.quadraticCurveTo(o2, s2 + u2, o2, s2 + u2 - d2), "center" === r2 && "left" === a2 && this.drawCaret(t2, i2), n2.lineTo(o2, s2 + d2), n2.quadraticCurveTo(o2, s2, o2 + d2, s2), n2.closePath(), n2.fill(), e2.borderWidth > 0 && n2.stroke();
      }, draw: function() {
        var t2 = this._chart.ctx, e2 = this._view;
        if (0 !== e2.opacity) {
          var n2 = { width: e2.width, height: e2.height }, i2 = { x: e2.x, y: e2.y }, a2 = Math.abs(e2.opacity < 1e-3) ? 0 : e2.opacity, r2 = e2.title.length || e2.beforeBody.length || e2.body.length || e2.afterBody.length || e2.footer.length;
          this._options.enabled && r2 && (t2.save(), t2.globalAlpha = a2, this.drawBackground(i2, e2, t2, n2), i2.y += e2.yPadding, H.rtl.overrideTextDirection(t2, e2.textDirection), this.drawTitle(i2, e2, t2), this.drawBody(i2, e2, t2), this.drawFooter(i2, e2, t2), H.rtl.restoreTextDirection(t2, e2.textDirection), t2.restore());
        }
      }, handleEvent: function(t2) {
        var e2, n2 = this, i2 = n2._options;
        return n2._lastActive = n2._lastActive || [], "mouseout" === t2.type ? n2._active = [] : (n2._active = n2._chart.getElementsAtEventForMode(t2, i2.mode, i2), i2.reverse && n2._active.reverse()), (e2 = !H.arrayEquals(n2._active, n2._lastActive)) && (n2._lastActive = n2._active, (i2.enabled || i2.custom) && (n2._eventPosition = { x: t2.x, y: t2.y }, n2.update(true), n2.pivot())), e2;
      } }), Ue = Be, Ye = qe;
      Ye.positioners = Ue;
      var Ge = H.valueOrDefault;
      function Xe() {
        return H.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), { merger: function(t2, e2, n2, i2) {
          if ("xAxes" === t2 || "yAxes" === t2) {
            var a2, r2, o2, s2 = n2[t2].length;
            for (e2[t2] || (e2[t2] = []), a2 = 0; a2 < s2; ++a2) o2 = n2[t2][a2], r2 = Ge(o2.type, "xAxes" === t2 ? "category" : "linear"), a2 >= e2[t2].length && e2[t2].push({}), !e2[t2][a2].type || o2.type && o2.type !== e2[t2][a2].type ? H.merge(e2[t2][a2], [Re.getScaleDefaults(r2), o2]) : H.merge(e2[t2][a2], o2);
          } else H._merger(t2, e2, n2, i2);
        } });
      }
      function Ke() {
        return H.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), { merger: function(t2, e2, n2, i2) {
          var a2 = e2[t2] || /* @__PURE__ */ Object.create(null), r2 = n2[t2];
          "scales" === t2 ? e2[t2] = Xe(a2, r2) : "scale" === t2 ? e2[t2] = H.merge(a2, [Re.getScaleDefaults(r2.type), r2]) : H._merger(t2, e2, n2, i2);
        } });
      }
      function Ze(t2) {
        var e2 = t2.options;
        H.each(t2.scales, function(e3) {
          pe.removeBox(t2, e3);
        }), e2 = Ke(N.global, N[t2.config.type], e2), t2.options = t2.config.options = e2, t2.ensureScalesHaveIDs(), t2.buildOrUpdateScales(), t2.tooltip._options = e2.tooltips, t2.tooltip.initialize();
      }
      function $e(t2, e2, n2) {
        var i2, a2 = function(t3) {
          return t3.id === i2;
        };
        do {
          i2 = e2 + n2++;
        } while (H.findIndex(t2, a2) >= 0);
        return i2;
      }
      function Je(t2) {
        return "top" === t2 || "bottom" === t2;
      }
      function Qe(t2, e2) {
        return function(n2, i2) {
          return n2[t2] === i2[t2] ? n2[e2] - i2[e2] : n2[t2] - i2[t2];
        };
      }
      N._set("global", { elements: {}, events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"], hover: { onHover: null, mode: "nearest", intersect: true, animationDuration: 400 }, onClick: null, maintainAspectRatio: true, responsive: true, responsiveAnimationDuration: 0 });
      var tn = function(t2, e2) {
        return this.construct(t2, e2), this;
      };
      H.extend(tn.prototype, { construct: function(t2, e2) {
        var n2 = this;
        e2 = function(t3) {
          var e3 = (t3 = t3 || /* @__PURE__ */ Object.create(null)).data = t3.data || {};
          return e3.datasets = e3.datasets || [], e3.labels = e3.labels || [], t3.options = Ke(N.global, N[t3.type], t3.options || {}), t3;
        }(e2);
        var i2 = Oe.acquireContext(t2, e2), a2 = i2 && i2.canvas, r2 = a2 && a2.height, o2 = a2 && a2.width;
        n2.id = H.uid(), n2.ctx = i2, n2.canvas = a2, n2.config = e2, n2.width = o2, n2.height = r2, n2.aspectRatio = r2 ? o2 / r2 : null, n2.options = e2.options, n2._bufferedRender = false, n2._layers = [], n2.chart = n2, n2.controller = n2, tn.instances[n2.id] = n2, Object.defineProperty(n2, "data", { get: function() {
          return n2.config.data;
        }, set: function(t3) {
          n2.config.data = t3;
        } }), i2 && a2 ? (n2.initialize(), n2.update()) : console.error("Failed to create chart: can't acquire context from the given item");
      }, initialize: function() {
        var t2 = this;
        return Le.notify(t2, "beforeInit"), H.retinaScale(t2, t2.options.devicePixelRatio), t2.bindEvents(), t2.options.responsive && t2.resize(true), t2.initToolTip(), Le.notify(t2, "afterInit"), t2;
      }, clear: function() {
        return H.canvas.clear(this), this;
      }, stop: function() {
        return J.cancelAnimation(this), this;
      }, resize: function(t2) {
        var e2 = this, n2 = e2.options, i2 = e2.canvas, a2 = n2.maintainAspectRatio && e2.aspectRatio || null, r2 = Math.max(0, Math.floor(H.getMaximumWidth(i2))), o2 = Math.max(0, Math.floor(a2 ? r2 / a2 : H.getMaximumHeight(i2)));
        if ((e2.width !== r2 || e2.height !== o2) && (i2.width = e2.width = r2, i2.height = e2.height = o2, i2.style.width = r2 + "px", i2.style.height = o2 + "px", H.retinaScale(e2, n2.devicePixelRatio), !t2)) {
          var s2 = { width: r2, height: o2 };
          Le.notify(e2, "resize", [s2]), n2.onResize && n2.onResize(e2, s2), e2.stop(), e2.update({ duration: n2.responsiveAnimationDuration });
        }
      }, ensureScalesHaveIDs: function() {
        var t2 = this.options, e2 = t2.scales || {}, n2 = t2.scale;
        H.each(e2.xAxes, function(t3, n3) {
          t3.id || (t3.id = $e(e2.xAxes, "x-axis-", n3));
        }), H.each(e2.yAxes, function(t3, n3) {
          t3.id || (t3.id = $e(e2.yAxes, "y-axis-", n3));
        }), n2 && (n2.id = n2.id || "scale");
      }, buildOrUpdateScales: function() {
        var t2 = this, e2 = t2.options, n2 = t2.scales || {}, i2 = [], a2 = Object.keys(n2).reduce(function(t3, e3) {
          return t3[e3] = false, t3;
        }, {});
        e2.scales && (i2 = i2.concat((e2.scales.xAxes || []).map(function(t3) {
          return { options: t3, dtype: "category", dposition: "bottom" };
        }), (e2.scales.yAxes || []).map(function(t3) {
          return { options: t3, dtype: "linear", dposition: "left" };
        }))), e2.scale && i2.push({ options: e2.scale, dtype: "radialLinear", isDefault: true, dposition: "chartArea" }), H.each(i2, function(e3) {
          var i3 = e3.options, r2 = i3.id, o2 = Ge(i3.type, e3.dtype);
          Je(i3.position) !== Je(e3.dposition) && (i3.position = e3.dposition), a2[r2] = true;
          var s2 = null;
          if (r2 in n2 && n2[r2].type === o2) (s2 = n2[r2]).options = i3, s2.ctx = t2.ctx, s2.chart = t2;
          else {
            var l2 = Re.getScaleConstructor(o2);
            if (!l2) return;
            s2 = new l2({ id: r2, type: o2, options: i3, ctx: t2.ctx, chart: t2 }), n2[s2.id] = s2;
          }
          s2.mergeTicksOptions(), e3.isDefault && (t2.scale = s2);
        }), H.each(a2, function(t3, e3) {
          t3 || delete n2[e3];
        }), t2.scales = n2, Re.addScalesToLayout(this);
      }, buildOrUpdateControllers: function() {
        var t2, e2, n2 = this, i2 = [], a2 = n2.data.datasets;
        for (t2 = 0, e2 = a2.length; t2 < e2; t2++) {
          var r2 = a2[t2], o2 = n2.getDatasetMeta(t2), s2 = r2.type || n2.config.type;
          if (o2.type && o2.type !== s2 && (n2.destroyDatasetMeta(t2), o2 = n2.getDatasetMeta(t2)), o2.type = s2, o2.order = r2.order || 0, o2.index = t2, o2.controller) o2.controller.updateIndex(t2), o2.controller.linkScales();
          else {
            var l2 = Jt[o2.type];
            if (void 0 === l2) throw new Error('"' + o2.type + '" is not a chart type.');
            o2.controller = new l2(n2, t2), i2.push(o2.controller);
          }
        }
        return i2;
      }, resetElements: function() {
        var t2 = this;
        H.each(t2.data.datasets, function(e2, n2) {
          t2.getDatasetMeta(n2).controller.reset();
        }, t2);
      }, reset: function() {
        this.resetElements(), this.tooltip.initialize();
      }, update: function(t2) {
        var e2, n2, i2 = this;
        if (t2 && "object" == typeof t2 || (t2 = { duration: t2, lazy: arguments[1] }), Ze(i2), Le._invalidate(i2), false !== Le.notify(i2, "beforeUpdate")) {
          i2.tooltip._data = i2.data;
          var a2 = i2.buildOrUpdateControllers();
          for (e2 = 0, n2 = i2.data.datasets.length; e2 < n2; e2++) i2.getDatasetMeta(e2).controller.buildOrUpdateElements();
          i2.updateLayout(), i2.options.animation && i2.options.animation.duration && H.each(a2, function(t3) {
            t3.reset();
          }), i2.updateDatasets(), i2.tooltip.initialize(), i2.lastActive = [], Le.notify(i2, "afterUpdate"), i2._layers.sort(Qe("z", "_idx")), i2._bufferedRender ? i2._bufferedRequest = { duration: t2.duration, easing: t2.easing, lazy: t2.lazy } : i2.render(t2);
        }
      }, updateLayout: function() {
        var t2 = this;
        false !== Le.notify(t2, "beforeLayout") && (pe.update(this, this.width, this.height), t2._layers = [], H.each(t2.boxes, function(e2) {
          e2._configure && e2._configure(), t2._layers.push.apply(t2._layers, e2._layers());
        }, t2), t2._layers.forEach(function(t3, e2) {
          t3._idx = e2;
        }), Le.notify(t2, "afterScaleUpdate"), Le.notify(t2, "afterLayout"));
      }, updateDatasets: function() {
        if (false !== Le.notify(this, "beforeDatasetsUpdate")) {
          for (var t2 = 0, e2 = this.data.datasets.length; t2 < e2; ++t2) this.updateDataset(t2);
          Le.notify(this, "afterDatasetsUpdate");
        }
      }, updateDataset: function(t2) {
        var e2 = this.getDatasetMeta(t2), n2 = { meta: e2, index: t2 };
        false !== Le.notify(this, "beforeDatasetUpdate", [n2]) && (e2.controller._update(), Le.notify(this, "afterDatasetUpdate", [n2]));
      }, render: function(t2) {
        var e2 = this;
        t2 && "object" == typeof t2 || (t2 = { duration: t2, lazy: arguments[1] });
        var n2 = e2.options.animation, i2 = Ge(t2.duration, n2 && n2.duration), a2 = t2.lazy;
        if (false !== Le.notify(e2, "beforeRender")) {
          var r2 = function(t3) {
            Le.notify(e2, "afterRender"), H.callback(n2 && n2.onComplete, [t3], e2);
          };
          if (n2 && i2) {
            var o2 = new $({ numSteps: i2 / 16.66, easing: t2.easing || n2.easing, render: function(t3, e3) {
              var n3 = H.easing.effects[e3.easing], i3 = e3.currentStep, a3 = i3 / e3.numSteps;
              t3.draw(n3(a3), a3, i3);
            }, onAnimationProgress: n2.onProgress, onAnimationComplete: r2 });
            J.addAnimation(e2, o2, i2, a2);
          } else e2.draw(), r2(new $({ numSteps: 0, chart: e2 }));
          return e2;
        }
      }, draw: function(t2) {
        var e2, n2, i2 = this;
        if (i2.clear(), H.isNullOrUndef(t2) && (t2 = 1), i2.transition(t2), !(i2.width <= 0 || i2.height <= 0) && false !== Le.notify(i2, "beforeDraw", [t2])) {
          for (n2 = i2._layers, e2 = 0; e2 < n2.length && n2[e2].z <= 0; ++e2) n2[e2].draw(i2.chartArea);
          for (i2.drawDatasets(t2); e2 < n2.length; ++e2) n2[e2].draw(i2.chartArea);
          i2._drawTooltip(t2), Le.notify(i2, "afterDraw", [t2]);
        }
      }, transition: function(t2) {
        for (var e2 = 0, n2 = (this.data.datasets || []).length; e2 < n2; ++e2) this.isDatasetVisible(e2) && this.getDatasetMeta(e2).controller.transition(t2);
        this.tooltip.transition(t2);
      }, _getSortedDatasetMetas: function(t2) {
        var e2, n2, i2 = [];
        for (e2 = 0, n2 = (this.data.datasets || []).length; e2 < n2; ++e2) t2 && !this.isDatasetVisible(e2) || i2.push(this.getDatasetMeta(e2));
        return i2.sort(Qe("order", "index")), i2;
      }, _getSortedVisibleDatasetMetas: function() {
        return this._getSortedDatasetMetas(true);
      }, drawDatasets: function(t2) {
        var e2, n2;
        if (false !== Le.notify(this, "beforeDatasetsDraw", [t2])) {
          for (n2 = (e2 = this._getSortedVisibleDatasetMetas()).length - 1; n2 >= 0; --n2) this.drawDataset(e2[n2], t2);
          Le.notify(this, "afterDatasetsDraw", [t2]);
        }
      }, drawDataset: function(t2, e2) {
        var n2 = { meta: t2, index: t2.index, easingValue: e2 };
        false !== Le.notify(this, "beforeDatasetDraw", [n2]) && (t2.controller.draw(e2), Le.notify(this, "afterDatasetDraw", [n2]));
      }, _drawTooltip: function(t2) {
        var e2 = this.tooltip, n2 = { tooltip: e2, easingValue: t2 };
        false !== Le.notify(this, "beforeTooltipDraw", [n2]) && (e2.draw(), Le.notify(this, "afterTooltipDraw", [n2]));
      }, getElementAtEvent: function(t2) {
        return re.modes.single(this, t2);
      }, getElementsAtEvent: function(t2) {
        return re.modes.label(this, t2, { intersect: true });
      }, getElementsAtXAxis: function(t2) {
        return re.modes["x-axis"](this, t2, { intersect: true });
      }, getElementsAtEventForMode: function(t2, e2, n2) {
        var i2 = re.modes[e2];
        return "function" == typeof i2 ? i2(this, t2, n2) : [];
      }, getDatasetAtEvent: function(t2) {
        return re.modes.dataset(this, t2, { intersect: true });
      }, getDatasetMeta: function(t2) {
        var e2 = this.data.datasets[t2];
        e2._meta || (e2._meta = {});
        var n2 = e2._meta[this.id];
        return n2 || (n2 = e2._meta[this.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e2.order || 0, index: t2 }), n2;
      }, getVisibleDatasetCount: function() {
        for (var t2 = 0, e2 = 0, n2 = this.data.datasets.length; e2 < n2; ++e2) this.isDatasetVisible(e2) && t2++;
        return t2;
      }, isDatasetVisible: function(t2) {
        var e2 = this.getDatasetMeta(t2);
        return "boolean" == typeof e2.hidden ? !e2.hidden : !this.data.datasets[t2].hidden;
      }, generateLegend: function() {
        return this.options.legendCallback(this);
      }, destroyDatasetMeta: function(t2) {
        var e2 = this.id, n2 = this.data.datasets[t2], i2 = n2._meta && n2._meta[e2];
        i2 && (i2.controller.destroy(), delete n2._meta[e2]);
      }, destroy: function() {
        var t2, e2, n2 = this, i2 = n2.canvas;
        for (n2.stop(), t2 = 0, e2 = n2.data.datasets.length; t2 < e2; ++t2) n2.destroyDatasetMeta(t2);
        i2 && (n2.unbindEvents(), H.canvas.clear(n2), Oe.releaseContext(n2.ctx), n2.canvas = null, n2.ctx = null), Le.notify(n2, "destroy"), delete tn.instances[n2.id];
      }, toBase64Image: function() {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      }, initToolTip: function() {
        var t2 = this;
        t2.tooltip = new Ye({ _chart: t2, _chartInstance: t2, _data: t2.data, _options: t2.options.tooltips }, t2);
      }, bindEvents: function() {
        var t2 = this, e2 = t2._listeners = {}, n2 = function() {
          t2.eventHandler.apply(t2, arguments);
        };
        H.each(t2.options.events, function(i2) {
          Oe.addEventListener(t2, i2, n2), e2[i2] = n2;
        }), t2.options.responsive && (n2 = function() {
          t2.resize();
        }, Oe.addEventListener(t2, "resize", n2), e2.resize = n2);
      }, unbindEvents: function() {
        var t2 = this, e2 = t2._listeners;
        e2 && (delete t2._listeners, H.each(e2, function(e3, n2) {
          Oe.removeEventListener(t2, n2, e3);
        }));
      }, updateHoverStyle: function(t2, e2, n2) {
        var i2, a2, r2, o2 = n2 ? "set" : "remove";
        for (a2 = 0, r2 = t2.length; a2 < r2; ++a2) (i2 = t2[a2]) && this.getDatasetMeta(i2._datasetIndex).controller[o2 + "HoverStyle"](i2);
        "dataset" === e2 && this.getDatasetMeta(t2[0]._datasetIndex).controller["_" + o2 + "DatasetHoverStyle"]();
      }, eventHandler: function(t2) {
        var e2 = this, n2 = e2.tooltip;
        if (false !== Le.notify(e2, "beforeEvent", [t2])) {
          e2._bufferedRender = true, e2._bufferedRequest = null;
          var i2 = e2.handleEvent(t2);
          n2 && (i2 = n2._start ? n2.handleEvent(t2) : i2 | n2.handleEvent(t2)), Le.notify(e2, "afterEvent", [t2]);
          var a2 = e2._bufferedRequest;
          return a2 ? e2.render(a2) : i2 && !e2.animating && (e2.stop(), e2.render({ duration: e2.options.hover.animationDuration, lazy: true })), e2._bufferedRender = false, e2._bufferedRequest = null, e2;
        }
      }, handleEvent: function(t2) {
        var e2, n2 = this, i2 = n2.options || {}, a2 = i2.hover;
        return n2.lastActive = n2.lastActive || [], "mouseout" === t2.type ? n2.active = [] : n2.active = n2.getElementsAtEventForMode(t2, a2.mode, a2), H.callback(i2.onHover || i2.hover.onHover, [t2.native, n2.active], n2), "mouseup" !== t2.type && "click" !== t2.type || i2.onClick && i2.onClick.call(n2, t2.native, n2.active), n2.lastActive.length && n2.updateHoverStyle(n2.lastActive, a2.mode, false), n2.active.length && a2.mode && n2.updateHoverStyle(n2.active, a2.mode, true), e2 = !H.arrayEquals(n2.active, n2.lastActive), n2.lastActive = n2.active, e2;
      } }), tn.instances = {};
      var en = tn;
      tn.Controller = tn, tn.types = {}, H.configMerge = Ke, H.scaleMerge = Xe;
      function nn() {
        throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.");
      }
      function an(t2) {
        this.options = t2 || {};
      }
      H.extend(an.prototype, { formats: nn, parse: nn, format: nn, add: nn, diff: nn, startOf: nn, endOf: nn, _create: function(t2) {
        return t2;
      } }), an.override = function(t2) {
        H.extend(an.prototype, t2);
      };
      var rn = { _date: an }, on = { formatters: { values: function(t2) {
        return H.isArray(t2) ? t2 : "" + t2;
      }, linear: function(t2, e2, n2) {
        var i2 = n2.length > 3 ? n2[2] - n2[1] : n2[1] - n2[0];
        Math.abs(i2) > 1 && t2 !== Math.floor(t2) && (i2 = t2 - Math.floor(t2));
        var a2 = H.log10(Math.abs(i2)), r2 = "";
        if (0 !== t2) if (Math.max(Math.abs(n2[0]), Math.abs(n2[n2.length - 1])) < 1e-4) {
          var o2 = H.log10(Math.abs(t2)), s2 = Math.floor(o2) - Math.floor(a2);
          s2 = Math.max(Math.min(s2, 20), 0), r2 = t2.toExponential(s2);
        } else {
          var l2 = -1 * Math.floor(a2);
          l2 = Math.max(Math.min(l2, 20), 0), r2 = t2.toFixed(l2);
        }
        else r2 = "0";
        return r2;
      }, logarithmic: function(t2, e2, n2) {
        var i2 = t2 / Math.pow(10, Math.floor(H.log10(t2)));
        return 0 === t2 ? "0" : 1 === i2 || 2 === i2 || 5 === i2 || 0 === e2 || e2 === n2.length - 1 ? t2.toExponential() : "";
      } } }, sn = H.isArray, ln = H.isNullOrUndef, un = H.valueOrDefault, dn = H.valueAtIndexOrDefault;
      function hn(t2, e2, n2) {
        var i2, a2 = t2.getTicks().length, r2 = Math.min(e2, a2 - 1), o2 = t2.getPixelForTick(r2), s2 = t2._startPixel, l2 = t2._endPixel;
        if (!(n2 && (i2 = 1 === a2 ? Math.max(o2 - s2, l2 - o2) : 0 === e2 ? (t2.getPixelForTick(1) - o2) / 2 : (o2 - t2.getPixelForTick(r2 - 1)) / 2, (o2 += r2 < e2 ? i2 : -i2) < s2 - 1e-6 || o2 > l2 + 1e-6))) return o2;
      }
      function cn(t2, e2, n2, i2) {
        var a2, r2, o2, s2, l2, u2, d2, h2, c2, f2, g2, p2, m2, v2 = n2.length, b2 = [], x2 = [], y2 = [], _2 = 0, k2 = 0;
        for (a2 = 0; a2 < v2; ++a2) {
          if (s2 = n2[a2].label, l2 = n2[a2].major ? e2.major : e2.minor, t2.font = u2 = l2.string, d2 = i2[u2] = i2[u2] || { data: {}, gc: [] }, h2 = l2.lineHeight, c2 = f2 = 0, ln(s2) || sn(s2)) {
            if (sn(s2)) for (r2 = 0, o2 = s2.length; r2 < o2; ++r2) g2 = s2[r2], ln(g2) || sn(g2) || (c2 = H.measureText(t2, d2.data, d2.gc, c2, g2), f2 += h2);
          } else c2 = H.measureText(t2, d2.data, d2.gc, c2, s2), f2 = h2;
          b2.push(c2), x2.push(f2), y2.push(h2 / 2), _2 = Math.max(c2, _2), k2 = Math.max(f2, k2);
        }
        function w2(t3) {
          return { width: b2[t3] || 0, height: x2[t3] || 0, offset: y2[t3] || 0 };
        }
        return function(t3, e3) {
          H.each(t3, function(t4) {
            var n3, i3 = t4.gc, a3 = i3.length / 2;
            if (a3 > e3) {
              for (n3 = 0; n3 < a3; ++n3) delete t4.data[i3[n3]];
              i3.splice(0, a3);
            }
          });
        }(i2, v2), p2 = b2.indexOf(_2), m2 = x2.indexOf(k2), { first: w2(0), last: w2(v2 - 1), widest: w2(p2), highest: w2(m2) };
      }
      function fn(t2) {
        return t2.drawTicks ? t2.tickMarkLength : 0;
      }
      function gn(t2) {
        var e2, n2;
        return t2.display ? (e2 = H.options._parseFont(t2), n2 = H.options.toPadding(t2.padding), e2.lineHeight + n2.height) : 0;
      }
      function pn(t2, e2) {
        return H.extend(H.options._parseFont({ fontFamily: un(e2.fontFamily, t2.fontFamily), fontSize: un(e2.fontSize, t2.fontSize), fontStyle: un(e2.fontStyle, t2.fontStyle), lineHeight: un(e2.lineHeight, t2.lineHeight) }), { color: H.options.resolve([e2.fontColor, t2.fontColor, N.global.defaultFontColor]) });
      }
      function mn(t2) {
        var e2 = pn(t2, t2.minor);
        return { minor: e2, major: t2.major.enabled ? pn(t2, t2.major) : e2 };
      }
      function vn(t2) {
        var e2, n2, i2, a2 = [];
        for (n2 = 0, i2 = t2.length; n2 < i2; ++n2) void 0 !== (e2 = t2[n2])._index && a2.push(e2);
        return a2;
      }
      function bn(t2, e2, n2, i2) {
        var a2, r2, o2, s2, l2 = un(n2, 0), u2 = Math.min(un(i2, t2.length), t2.length), d2 = 0;
        for (e2 = Math.ceil(e2), i2 && (e2 = (a2 = i2 - n2) / Math.floor(a2 / e2)), s2 = l2; s2 < 0; ) d2++, s2 = Math.round(l2 + d2 * e2);
        for (r2 = Math.max(l2, 0); r2 < u2; r2++) o2 = t2[r2], r2 === s2 ? (o2._index = r2, d2++, s2 = Math.round(l2 + d2 * e2)) : delete o2.label;
      }
      N._set("scale", { display: true, position: "left", offset: false, gridLines: { display: true, color: "rgba(0,0,0,0.1)", lineWidth: 1, drawBorder: true, drawOnChartArea: true, drawTicks: true, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: false, borderDash: [], borderDashOffset: 0 }, scaleLabel: { display: false, labelString: "", padding: { top: 4, bottom: 4 } }, ticks: { beginAtZero: false, minRotation: 0, maxRotation: 50, mirror: false, padding: 0, reverse: false, display: true, autoSkip: true, autoSkipPadding: 0, labelOffset: 0, callback: on.formatters.values, minor: {}, major: {} } });
      var xn = K.extend({ zeroLineIndex: 0, getPadding: function() {
        return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 };
      }, getTicks: function() {
        return this._ticks;
      }, _getLabels: function() {
        var t2 = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? t2.xLabels : t2.yLabels) || t2.labels || [];
      }, mergeTicksOptions: function() {
      }, beforeUpdate: function() {
        H.callback(this.options.beforeUpdate, [this]);
      }, update: function(t2, e2, n2) {
        var i2, a2, r2, o2, s2, l2 = this, u2 = l2.options.ticks, d2 = u2.sampleSize;
        if (l2.beforeUpdate(), l2.maxWidth = t2, l2.maxHeight = e2, l2.margins = H.extend({ left: 0, right: 0, top: 0, bottom: 0 }, n2), l2._ticks = null, l2.ticks = null, l2._labelSizes = null, l2._maxLabelLines = 0, l2.longestLabelWidth = 0, l2.longestTextCache = l2.longestTextCache || {}, l2._gridLineItems = null, l2._labelItems = null, l2.beforeSetDimensions(), l2.setDimensions(), l2.afterSetDimensions(), l2.beforeDataLimits(), l2.determineDataLimits(), l2.afterDataLimits(), l2.beforeBuildTicks(), o2 = l2.buildTicks() || [], (!(o2 = l2.afterBuildTicks(o2) || o2) || !o2.length) && l2.ticks) for (o2 = [], i2 = 0, a2 = l2.ticks.length; i2 < a2; ++i2) o2.push({ value: l2.ticks[i2], major: false });
        return l2._ticks = o2, s2 = d2 < o2.length, r2 = l2._convertTicksToLabels(s2 ? function(t3, e3) {
          for (var n3 = [], i3 = t3.length / e3, a3 = 0, r3 = t3.length; a3 < r3; a3 += i3) n3.push(t3[Math.floor(a3)]);
          return n3;
        }(o2, d2) : o2), l2._configure(), l2.beforeCalculateTickRotation(), l2.calculateTickRotation(), l2.afterCalculateTickRotation(), l2.beforeFit(), l2.fit(), l2.afterFit(), l2._ticksToDraw = u2.display && (u2.autoSkip || "auto" === u2.source) ? l2._autoSkip(o2) : o2, s2 && (r2 = l2._convertTicksToLabels(l2._ticksToDraw)), l2.ticks = r2, l2.afterUpdate(), l2.minSize;
      }, _configure: function() {
        var t2, e2, n2 = this, i2 = n2.options.ticks.reverse;
        n2.isHorizontal() ? (t2 = n2.left, e2 = n2.right) : (t2 = n2.top, e2 = n2.bottom, i2 = !i2), n2._startPixel = t2, n2._endPixel = e2, n2._reversePixels = i2, n2._length = e2 - t2;
      }, afterUpdate: function() {
        H.callback(this.options.afterUpdate, [this]);
      }, beforeSetDimensions: function() {
        H.callback(this.options.beforeSetDimensions, [this]);
      }, setDimensions: function() {
        var t2 = this;
        t2.isHorizontal() ? (t2.width = t2.maxWidth, t2.left = 0, t2.right = t2.width) : (t2.height = t2.maxHeight, t2.top = 0, t2.bottom = t2.height), t2.paddingLeft = 0, t2.paddingTop = 0, t2.paddingRight = 0, t2.paddingBottom = 0;
      }, afterSetDimensions: function() {
        H.callback(this.options.afterSetDimensions, [this]);
      }, beforeDataLimits: function() {
        H.callback(this.options.beforeDataLimits, [this]);
      }, determineDataLimits: H.noop, afterDataLimits: function() {
        H.callback(this.options.afterDataLimits, [this]);
      }, beforeBuildTicks: function() {
        H.callback(this.options.beforeBuildTicks, [this]);
      }, buildTicks: H.noop, afterBuildTicks: function(t2) {
        var e2 = this;
        return sn(t2) && t2.length ? H.callback(e2.options.afterBuildTicks, [e2, t2]) : (e2.ticks = H.callback(e2.options.afterBuildTicks, [e2, e2.ticks]) || e2.ticks, t2);
      }, beforeTickToLabelConversion: function() {
        H.callback(this.options.beforeTickToLabelConversion, [this]);
      }, convertTicksToLabels: function() {
        var t2 = this.options.ticks;
        this.ticks = this.ticks.map(t2.userCallback || t2.callback, this);
      }, afterTickToLabelConversion: function() {
        H.callback(this.options.afterTickToLabelConversion, [this]);
      }, beforeCalculateTickRotation: function() {
        H.callback(this.options.beforeCalculateTickRotation, [this]);
      }, calculateTickRotation: function() {
        var t2, e2, n2, i2, a2, r2, o2, s2 = this, l2 = s2.options, u2 = l2.ticks, d2 = s2.getTicks().length, h2 = u2.minRotation || 0, c2 = u2.maxRotation, f2 = h2;
        !s2._isVisible() || !u2.display || h2 >= c2 || d2 <= 1 || !s2.isHorizontal() ? s2.labelRotation = h2 : (e2 = (t2 = s2._getLabelSizes()).widest.width, n2 = t2.highest.height - t2.highest.offset, i2 = Math.min(s2.maxWidth, s2.chart.width - e2), e2 + 6 > (a2 = l2.offset ? s2.maxWidth / d2 : i2 / (d2 - 1)) && (a2 = i2 / (d2 - (l2.offset ? 0.5 : 1)), r2 = s2.maxHeight - fn(l2.gridLines) - u2.padding - gn(l2.scaleLabel), o2 = Math.sqrt(e2 * e2 + n2 * n2), f2 = H.toDegrees(Math.min(Math.asin(Math.min((t2.highest.height + 6) / a2, 1)), Math.asin(Math.min(r2 / o2, 1)) - Math.asin(n2 / o2))), f2 = Math.max(h2, Math.min(c2, f2))), s2.labelRotation = f2);
      }, afterCalculateTickRotation: function() {
        H.callback(this.options.afterCalculateTickRotation, [this]);
      }, beforeFit: function() {
        H.callback(this.options.beforeFit, [this]);
      }, fit: function() {
        var t2 = this, e2 = t2.minSize = { width: 0, height: 0 }, n2 = t2.chart, i2 = t2.options, a2 = i2.ticks, r2 = i2.scaleLabel, o2 = i2.gridLines, s2 = t2._isVisible(), l2 = "bottom" === i2.position, u2 = t2.isHorizontal();
        if (u2 ? e2.width = t2.maxWidth : s2 && (e2.width = fn(o2) + gn(r2)), u2 ? s2 && (e2.height = fn(o2) + gn(r2)) : e2.height = t2.maxHeight, a2.display && s2) {
          var d2 = mn(a2), h2 = t2._getLabelSizes(), c2 = h2.first, f2 = h2.last, g2 = h2.widest, p2 = h2.highest, m2 = 0.4 * d2.minor.lineHeight, v2 = a2.padding;
          if (u2) {
            var b2 = 0 !== t2.labelRotation, x2 = H.toRadians(t2.labelRotation), y2 = Math.cos(x2), _2 = Math.sin(x2), k2 = _2 * g2.width + y2 * (p2.height - (b2 ? p2.offset : 0)) + (b2 ? 0 : m2);
            e2.height = Math.min(t2.maxHeight, e2.height + k2 + v2);
            var w2, M2, S2 = t2.getPixelForTick(0) - t2.left, C2 = t2.right - t2.getPixelForTick(t2.getTicks().length - 1);
            b2 ? (w2 = l2 ? y2 * c2.width + _2 * c2.offset : _2 * (c2.height - c2.offset), M2 = l2 ? _2 * (f2.height - f2.offset) : y2 * f2.width + _2 * f2.offset) : (w2 = c2.width / 2, M2 = f2.width / 2), t2.paddingLeft = Math.max((w2 - S2) * t2.width / (t2.width - S2), 0) + 3, t2.paddingRight = Math.max((M2 - C2) * t2.width / (t2.width - C2), 0) + 3;
          } else {
            var P2 = a2.mirror ? 0 : g2.width + v2 + m2;
            e2.width = Math.min(t2.maxWidth, e2.width + P2), t2.paddingTop = c2.height / 2, t2.paddingBottom = f2.height / 2;
          }
        }
        t2.handleMargins(), u2 ? (t2.width = t2._length = n2.width - t2.margins.left - t2.margins.right, t2.height = e2.height) : (t2.width = e2.width, t2.height = t2._length = n2.height - t2.margins.top - t2.margins.bottom);
      }, handleMargins: function() {
        var t2 = this;
        t2.margins && (t2.margins.left = Math.max(t2.paddingLeft, t2.margins.left), t2.margins.top = Math.max(t2.paddingTop, t2.margins.top), t2.margins.right = Math.max(t2.paddingRight, t2.margins.right), t2.margins.bottom = Math.max(t2.paddingBottom, t2.margins.bottom));
      }, afterFit: function() {
        H.callback(this.options.afterFit, [this]);
      }, isHorizontal: function() {
        var t2 = this.options.position;
        return "top" === t2 || "bottom" === t2;
      }, isFullWidth: function() {
        return this.options.fullWidth;
      }, getRightValue: function(t2) {
        if (ln(t2)) return NaN;
        if (("number" == typeof t2 || t2 instanceof Number) && !isFinite(t2)) return NaN;
        if (t2) {
          if (this.isHorizontal()) {
            if (void 0 !== t2.x) return this.getRightValue(t2.x);
          } else if (void 0 !== t2.y) return this.getRightValue(t2.y);
        }
        return t2;
      }, _convertTicksToLabels: function(t2) {
        var e2, n2, i2, a2 = this;
        for (a2.ticks = t2.map(function(t3) {
          return t3.value;
        }), a2.beforeTickToLabelConversion(), e2 = a2.convertTicksToLabels(t2) || a2.ticks, a2.afterTickToLabelConversion(), n2 = 0, i2 = t2.length; n2 < i2; ++n2) t2[n2].label = e2[n2];
        return e2;
      }, _getLabelSizes: function() {
        var t2 = this, e2 = t2._labelSizes;
        return e2 || (t2._labelSizes = e2 = cn(t2.ctx, mn(t2.options.ticks), t2.getTicks(), t2.longestTextCache), t2.longestLabelWidth = e2.widest.width), e2;
      }, _parseValue: function(t2) {
        var e2, n2, i2, a2;
        return sn(t2) ? (e2 = +this.getRightValue(t2[0]), n2 = +this.getRightValue(t2[1]), i2 = Math.min(e2, n2), a2 = Math.max(e2, n2)) : (e2 = void 0, n2 = t2 = +this.getRightValue(t2), i2 = t2, a2 = t2), { min: i2, max: a2, start: e2, end: n2 };
      }, _getScaleLabel: function(t2) {
        var e2 = this._parseValue(t2);
        return void 0 !== e2.start ? "[" + e2.start + ", " + e2.end + "]" : +this.getRightValue(t2);
      }, getLabelForIndex: H.noop, getPixelForValue: H.noop, getValueForPixel: H.noop, getPixelForTick: function(t2) {
        var e2 = this.options.offset, n2 = this._ticks.length, i2 = 1 / Math.max(n2 - (e2 ? 0 : 1), 1);
        return t2 < 0 || t2 > n2 - 1 ? null : this.getPixelForDecimal(t2 * i2 + (e2 ? i2 / 2 : 0));
      }, getPixelForDecimal: function(t2) {
        return this._reversePixels && (t2 = 1 - t2), this._startPixel + t2 * this._length;
      }, getDecimalForPixel: function(t2) {
        var e2 = (t2 - this._startPixel) / this._length;
        return this._reversePixels ? 1 - e2 : e2;
      }, getBasePixel: function() {
        return this.getPixelForValue(this.getBaseValue());
      }, getBaseValue: function() {
        var t2 = this.min, e2 = this.max;
        return this.beginAtZero ? 0 : t2 < 0 && e2 < 0 ? e2 : t2 > 0 && e2 > 0 ? t2 : 0;
      }, _autoSkip: function(t2) {
        var e2, n2, i2, a2, r2 = this.options.ticks, o2 = this._length, s2 = r2.maxTicksLimit || o2 / this._tickSize() + 1, l2 = r2.major.enabled ? function(t3) {
          var e3, n3, i3 = [];
          for (e3 = 0, n3 = t3.length; e3 < n3; e3++) t3[e3].major && i3.push(e3);
          return i3;
        }(t2) : [], u2 = l2.length, d2 = l2[0], h2 = l2[u2 - 1];
        if (u2 > s2) return function(t3, e3, n3) {
          var i3, a3, r3 = 0, o3 = e3[0];
          for (n3 = Math.ceil(n3), i3 = 0; i3 < t3.length; i3++) a3 = t3[i3], i3 === o3 ? (a3._index = i3, o3 = e3[++r3 * n3]) : delete a3.label;
        }(t2, l2, u2 / s2), vn(t2);
        if (i2 = function(t3, e3, n3, i3) {
          var a3, r3, o3, s3, l3 = function(t4) {
            var e4, n4, i4 = t4.length;
            if (i4 < 2) return false;
            for (n4 = t4[0], e4 = 1; e4 < i4; ++e4) if (t4[e4] - t4[e4 - 1] !== n4) return false;
            return n4;
          }(t3), u3 = (e3.length - 1) / i3;
          if (!l3) return Math.max(u3, 1);
          for (o3 = 0, s3 = (a3 = H.math._factorize(l3)).length - 1; o3 < s3; o3++) if ((r3 = a3[o3]) > u3) return r3;
          return Math.max(u3, 1);
        }(l2, t2, 0, s2), u2 > 0) {
          for (e2 = 0, n2 = u2 - 1; e2 < n2; e2++) bn(t2, i2, l2[e2], l2[e2 + 1]);
          return a2 = u2 > 1 ? (h2 - d2) / (u2 - 1) : null, bn(t2, i2, H.isNullOrUndef(a2) ? 0 : d2 - a2, d2), bn(t2, i2, h2, H.isNullOrUndef(a2) ? t2.length : h2 + a2), vn(t2);
        }
        return bn(t2, i2), vn(t2);
      }, _tickSize: function() {
        var t2 = this.options.ticks, e2 = H.toRadians(this.labelRotation), n2 = Math.abs(Math.cos(e2)), i2 = Math.abs(Math.sin(e2)), a2 = this._getLabelSizes(), r2 = t2.autoSkipPadding || 0, o2 = a2 ? a2.widest.width + r2 : 0, s2 = a2 ? a2.highest.height + r2 : 0;
        return this.isHorizontal() ? s2 * n2 > o2 * i2 ? o2 / n2 : s2 / i2 : s2 * i2 < o2 * n2 ? s2 / n2 : o2 / i2;
      }, _isVisible: function() {
        var t2, e2, n2, i2 = this.chart, a2 = this.options.display;
        if ("auto" !== a2) return !!a2;
        for (t2 = 0, e2 = i2.data.datasets.length; t2 < e2; ++t2) if (i2.isDatasetVisible(t2) && ((n2 = i2.getDatasetMeta(t2)).xAxisID === this.id || n2.yAxisID === this.id)) return true;
        return false;
      }, _computeGridLineItems: function(t2) {
        var e2, n2, i2, a2, r2, o2, s2, l2, u2, d2, h2, c2, f2, g2, p2, m2, v2, b2 = this, x2 = b2.chart, y2 = b2.options, _2 = y2.gridLines, k2 = y2.position, w2 = _2.offsetGridLines, M2 = b2.isHorizontal(), S2 = b2._ticksToDraw, C2 = S2.length + (w2 ? 1 : 0), P2 = fn(_2), A2 = [], D2 = _2.drawBorder ? dn(_2.lineWidth, 0, 0) : 0, T2 = D2 / 2, I2 = H._alignPixel, F2 = function(t3) {
          return I2(x2, t3, D2);
        };
        for ("top" === k2 ? (e2 = F2(b2.bottom), s2 = b2.bottom - P2, u2 = e2 - T2, h2 = F2(t2.top) + T2, f2 = t2.bottom) : "bottom" === k2 ? (e2 = F2(b2.top), h2 = t2.top, f2 = F2(t2.bottom) - T2, s2 = e2 + T2, u2 = b2.top + P2) : "left" === k2 ? (e2 = F2(b2.right), o2 = b2.right - P2, l2 = e2 - T2, d2 = F2(t2.left) + T2, c2 = t2.right) : (e2 = F2(b2.left), d2 = t2.left, c2 = F2(t2.right) - T2, o2 = e2 + T2, l2 = b2.left + P2), n2 = 0; n2 < C2; ++n2) i2 = S2[n2] || {}, ln(i2.label) && n2 < S2.length || (n2 === b2.zeroLineIndex && y2.offset === w2 ? (g2 = _2.zeroLineWidth, p2 = _2.zeroLineColor, m2 = _2.zeroLineBorderDash || [], v2 = _2.zeroLineBorderDashOffset || 0) : (g2 = dn(_2.lineWidth, n2, 1), p2 = dn(_2.color, n2, "rgba(0,0,0,0.1)"), m2 = _2.borderDash || [], v2 = _2.borderDashOffset || 0), void 0 !== (a2 = hn(b2, i2._index || n2, w2)) && (r2 = I2(x2, a2, g2), M2 ? o2 = l2 = d2 = c2 = r2 : s2 = u2 = h2 = f2 = r2, A2.push({ tx1: o2, ty1: s2, tx2: l2, ty2: u2, x1: d2, y1: h2, x2: c2, y2: f2, width: g2, color: p2, borderDash: m2, borderDashOffset: v2 })));
        return A2.ticksLength = C2, A2.borderValue = e2, A2;
      }, _computeLabelItems: function() {
        var t2, e2, n2, i2, a2, r2, o2, s2, l2, u2, d2, h2, c2 = this, f2 = c2.options, g2 = f2.ticks, p2 = f2.position, m2 = g2.mirror, v2 = c2.isHorizontal(), b2 = c2._ticksToDraw, x2 = mn(g2), y2 = g2.padding, _2 = fn(f2.gridLines), k2 = -H.toRadians(c2.labelRotation), w2 = [];
        for ("top" === p2 ? (r2 = c2.bottom - _2 - y2, o2 = k2 ? "left" : "center") : "bottom" === p2 ? (r2 = c2.top + _2 + y2, o2 = k2 ? "right" : "center") : "left" === p2 ? (a2 = c2.right - (m2 ? 0 : _2) - y2, o2 = m2 ? "left" : "right") : (a2 = c2.left + (m2 ? 0 : _2) + y2, o2 = m2 ? "right" : "left"), t2 = 0, e2 = b2.length; t2 < e2; ++t2) i2 = (n2 = b2[t2]).label, ln(i2) || (s2 = c2.getPixelForTick(n2._index || t2) + g2.labelOffset, u2 = (l2 = n2.major ? x2.major : x2.minor).lineHeight, d2 = sn(i2) ? i2.length : 1, v2 ? (a2 = s2, h2 = "top" === p2 ? ((k2 ? 1 : 0.5) - d2) * u2 : (k2 ? 0 : 0.5) * u2) : (r2 = s2, h2 = (1 - d2) * u2 / 2), w2.push({ x: a2, y: r2, rotation: k2, label: i2, font: l2, textOffset: h2, textAlign: o2 }));
        return w2;
      }, _drawGrid: function(t2) {
        var e2 = this, n2 = e2.options.gridLines;
        if (n2.display) {
          var i2, a2, r2, o2, s2, l2 = e2.ctx, u2 = e2.chart, d2 = H._alignPixel, h2 = n2.drawBorder ? dn(n2.lineWidth, 0, 0) : 0, c2 = e2._gridLineItems || (e2._gridLineItems = e2._computeGridLineItems(t2));
          for (r2 = 0, o2 = c2.length; r2 < o2; ++r2) i2 = (s2 = c2[r2]).width, a2 = s2.color, i2 && a2 && (l2.save(), l2.lineWidth = i2, l2.strokeStyle = a2, l2.setLineDash && (l2.setLineDash(s2.borderDash), l2.lineDashOffset = s2.borderDashOffset), l2.beginPath(), n2.drawTicks && (l2.moveTo(s2.tx1, s2.ty1), l2.lineTo(s2.tx2, s2.ty2)), n2.drawOnChartArea && (l2.moveTo(s2.x1, s2.y1), l2.lineTo(s2.x2, s2.y2)), l2.stroke(), l2.restore());
          if (h2) {
            var f2, g2, p2, m2, v2 = h2, b2 = dn(n2.lineWidth, c2.ticksLength - 1, 1), x2 = c2.borderValue;
            e2.isHorizontal() ? (f2 = d2(u2, e2.left, v2) - v2 / 2, g2 = d2(u2, e2.right, b2) + b2 / 2, p2 = m2 = x2) : (p2 = d2(u2, e2.top, v2) - v2 / 2, m2 = d2(u2, e2.bottom, b2) + b2 / 2, f2 = g2 = x2), l2.lineWidth = h2, l2.strokeStyle = dn(n2.color, 0), l2.beginPath(), l2.moveTo(f2, p2), l2.lineTo(g2, m2), l2.stroke();
          }
        }
      }, _drawLabels: function() {
        var t2 = this;
        if (t2.options.ticks.display) {
          var e2, n2, i2, a2, r2, o2, s2, l2, u2 = t2.ctx, d2 = t2._labelItems || (t2._labelItems = t2._computeLabelItems());
          for (e2 = 0, i2 = d2.length; e2 < i2; ++e2) {
            if (o2 = (r2 = d2[e2]).font, u2.save(), u2.translate(r2.x, r2.y), u2.rotate(r2.rotation), u2.font = o2.string, u2.fillStyle = o2.color, u2.textBaseline = "middle", u2.textAlign = r2.textAlign, s2 = r2.label, l2 = r2.textOffset, sn(s2)) for (n2 = 0, a2 = s2.length; n2 < a2; ++n2) u2.fillText("" + s2[n2], 0, l2), l2 += o2.lineHeight;
            else u2.fillText(s2, 0, l2);
            u2.restore();
          }
        }
      }, _drawTitle: function() {
        var t2 = this, e2 = t2.ctx, n2 = t2.options, i2 = n2.scaleLabel;
        if (i2.display) {
          var a2, r2, o2 = un(i2.fontColor, N.global.defaultFontColor), s2 = H.options._parseFont(i2), l2 = H.options.toPadding(i2.padding), u2 = s2.lineHeight / 2, d2 = n2.position, h2 = 0;
          if (t2.isHorizontal()) a2 = t2.left + t2.width / 2, r2 = "bottom" === d2 ? t2.bottom - u2 - l2.bottom : t2.top + u2 + l2.top;
          else {
            var c2 = "left" === d2;
            a2 = c2 ? t2.left + u2 + l2.top : t2.right - u2 - l2.top, r2 = t2.top + t2.height / 2, h2 = c2 ? -0.5 * Math.PI : 0.5 * Math.PI;
          }
          e2.save(), e2.translate(a2, r2), e2.rotate(h2), e2.textAlign = "center", e2.textBaseline = "middle", e2.fillStyle = o2, e2.font = s2.string, e2.fillText(i2.labelString, 0, 0), e2.restore();
        }
      }, draw: function(t2) {
        this._isVisible() && (this._drawGrid(t2), this._drawTitle(), this._drawLabels());
      }, _layers: function() {
        var t2 = this, e2 = t2.options, n2 = e2.ticks && e2.ticks.z || 0, i2 = e2.gridLines && e2.gridLines.z || 0;
        return t2._isVisible() && n2 !== i2 && t2.draw === t2._draw ? [{ z: i2, draw: function() {
          t2._drawGrid.apply(t2, arguments), t2._drawTitle.apply(t2, arguments);
        } }, { z: n2, draw: function() {
          t2._drawLabels.apply(t2, arguments);
        } }] : [{ z: n2, draw: function() {
          t2.draw.apply(t2, arguments);
        } }];
      }, _getMatchingVisibleMetas: function(t2) {
        var e2 = this, n2 = e2.isHorizontal();
        return e2.chart._getSortedVisibleDatasetMetas().filter(function(i2) {
          return (!t2 || i2.type === t2) && (n2 ? i2.xAxisID === e2.id : i2.yAxisID === e2.id);
        });
      } });
      xn.prototype._draw = xn.prototype.draw;
      var yn = xn, _n = H.isNullOrUndef, kn = yn.extend({ determineDataLimits: function() {
        var t2, e2 = this, n2 = e2._getLabels(), i2 = e2.options.ticks, a2 = i2.min, r2 = i2.max, o2 = 0, s2 = n2.length - 1;
        void 0 !== a2 && (t2 = n2.indexOf(a2)) >= 0 && (o2 = t2), void 0 !== r2 && (t2 = n2.indexOf(r2)) >= 0 && (s2 = t2), e2.minIndex = o2, e2.maxIndex = s2, e2.min = n2[o2], e2.max = n2[s2];
      }, buildTicks: function() {
        var t2 = this._getLabels(), e2 = this.minIndex, n2 = this.maxIndex;
        this.ticks = 0 === e2 && n2 === t2.length - 1 ? t2 : t2.slice(e2, n2 + 1);
      }, getLabelForIndex: function(t2, e2) {
        var n2 = this.chart;
        return n2.getDatasetMeta(e2).controller._getValueScaleId() === this.id ? this.getRightValue(n2.data.datasets[e2].data[t2]) : this._getLabels()[t2];
      }, _configure: function() {
        var t2 = this, e2 = t2.options.offset, n2 = t2.ticks;
        yn.prototype._configure.call(t2), t2.isHorizontal() || (t2._reversePixels = !t2._reversePixels), n2 && (t2._startValue = t2.minIndex - (e2 ? 0.5 : 0), t2._valueRange = Math.max(n2.length - (e2 ? 0 : 1), 1));
      }, getPixelForValue: function(t2, e2, n2) {
        var i2, a2, r2, o2 = this;
        return _n(e2) || _n(n2) || (t2 = o2.chart.data.datasets[n2].data[e2]), _n(t2) || (i2 = o2.isHorizontal() ? t2.x : t2.y), (void 0 !== i2 || void 0 !== t2 && isNaN(e2)) && (a2 = o2._getLabels(), t2 = H.valueOrDefault(i2, t2), e2 = -1 !== (r2 = a2.indexOf(t2)) ? r2 : e2, isNaN(e2) && (e2 = t2)), o2.getPixelForDecimal((e2 - o2._startValue) / o2._valueRange);
      }, getPixelForTick: function(t2) {
        var e2 = this.ticks;
        return t2 < 0 || t2 > e2.length - 1 ? null : this.getPixelForValue(e2[t2], t2 + this.minIndex);
      }, getValueForPixel: function(t2) {
        var e2 = Math.round(this._startValue + this.getDecimalForPixel(t2) * this._valueRange);
        return Math.min(Math.max(e2, 0), this.ticks.length - 1);
      }, getBasePixel: function() {
        return this.bottom;
      } }), wn = { position: "bottom" };
      kn._defaults = wn;
      var Mn = H.noop, Sn = H.isNullOrUndef;
      var Cn = yn.extend({ getRightValue: function(t2) {
        return "string" == typeof t2 ? +t2 : yn.prototype.getRightValue.call(this, t2);
      }, handleTickRangeOptions: function() {
        var t2 = this, e2 = t2.options.ticks;
        if (e2.beginAtZero) {
          var n2 = H.sign(t2.min), i2 = H.sign(t2.max);
          n2 < 0 && i2 < 0 ? t2.max = 0 : n2 > 0 && i2 > 0 && (t2.min = 0);
        }
        var a2 = void 0 !== e2.min || void 0 !== e2.suggestedMin, r2 = void 0 !== e2.max || void 0 !== e2.suggestedMax;
        void 0 !== e2.min ? t2.min = e2.min : void 0 !== e2.suggestedMin && (null === t2.min ? t2.min = e2.suggestedMin : t2.min = Math.min(t2.min, e2.suggestedMin)), void 0 !== e2.max ? t2.max = e2.max : void 0 !== e2.suggestedMax && (null === t2.max ? t2.max = e2.suggestedMax : t2.max = Math.max(t2.max, e2.suggestedMax)), a2 !== r2 && t2.min >= t2.max && (a2 ? t2.max = t2.min + 1 : t2.min = t2.max - 1), t2.min === t2.max && (t2.max++, e2.beginAtZero || t2.min--);
      }, getTickLimit: function() {
        var t2, e2 = this.options.ticks, n2 = e2.stepSize, i2 = e2.maxTicksLimit;
        return n2 ? t2 = Math.ceil(this.max / n2) - Math.floor(this.min / n2) + 1 : (t2 = this._computeTickLimit(), i2 = i2 || 11), i2 && (t2 = Math.min(i2, t2)), t2;
      }, _computeTickLimit: function() {
        return Number.POSITIVE_INFINITY;
      }, handleDirectionalChanges: Mn, buildTicks: function() {
        var t2 = this, e2 = t2.options.ticks, n2 = t2.getTickLimit(), i2 = { maxTicks: n2 = Math.max(2, n2), min: e2.min, max: e2.max, precision: e2.precision, stepSize: H.valueOrDefault(e2.fixedStepSize, e2.stepSize) }, a2 = t2.ticks = function(t3, e3) {
          var n3, i3, a3, r2, o2 = [], s2 = t3.stepSize, l2 = s2 || 1, u2 = t3.maxTicks - 1, d2 = t3.min, h2 = t3.max, c2 = t3.precision, f2 = e3.min, g2 = e3.max, p2 = H.niceNum((g2 - f2) / u2 / l2) * l2;
          if (p2 < 1e-14 && Sn(d2) && Sn(h2)) return [f2, g2];
          (r2 = Math.ceil(g2 / p2) - Math.floor(f2 / p2)) > u2 && (p2 = H.niceNum(r2 * p2 / u2 / l2) * l2), s2 || Sn(c2) ? n3 = Math.pow(10, H._decimalPlaces(p2)) : (n3 = Math.pow(10, c2), p2 = Math.ceil(p2 * n3) / n3), i3 = Math.floor(f2 / p2) * p2, a3 = Math.ceil(g2 / p2) * p2, s2 && (!Sn(d2) && H.almostWhole(d2 / p2, p2 / 1e3) && (i3 = d2), !Sn(h2) && H.almostWhole(h2 / p2, p2 / 1e3) && (a3 = h2)), r2 = (a3 - i3) / p2, r2 = H.almostEquals(r2, Math.round(r2), p2 / 1e3) ? Math.round(r2) : Math.ceil(r2), i3 = Math.round(i3 * n3) / n3, a3 = Math.round(a3 * n3) / n3, o2.push(Sn(d2) ? i3 : d2);
          for (var m2 = 1; m2 < r2; ++m2) o2.push(Math.round((i3 + m2 * p2) * n3) / n3);
          return o2.push(Sn(h2) ? a3 : h2), o2;
        }(i2, t2);
        t2.handleDirectionalChanges(), t2.max = H.max(a2), t2.min = H.min(a2), e2.reverse ? (a2.reverse(), t2.start = t2.max, t2.end = t2.min) : (t2.start = t2.min, t2.end = t2.max);
      }, convertTicksToLabels: function() {
        var t2 = this;
        t2.ticksAsNumbers = t2.ticks.slice(), t2.zeroLineIndex = t2.ticks.indexOf(0), yn.prototype.convertTicksToLabels.call(t2);
      }, _configure: function() {
        var t2, e2 = this, n2 = e2.getTicks(), i2 = e2.min, a2 = e2.max;
        yn.prototype._configure.call(e2), e2.options.offset && n2.length && (i2 -= t2 = (a2 - i2) / Math.max(n2.length - 1, 1) / 2, a2 += t2), e2._startValue = i2, e2._endValue = a2, e2._valueRange = a2 - i2;
      } }), Pn = { position: "left", ticks: { callback: on.formatters.linear } };
      function An(t2, e2, n2, i2) {
        var a2, r2, o2 = t2.options, s2 = function(t3, e3, n3) {
          var i3 = [n3.type, void 0 === e3 && void 0 === n3.stack ? n3.index : "", n3.stack].join(".");
          return void 0 === t3[i3] && (t3[i3] = { pos: [], neg: [] }), t3[i3];
        }(e2, o2.stacked, n2), l2 = s2.pos, u2 = s2.neg, d2 = i2.length;
        for (a2 = 0; a2 < d2; ++a2) r2 = t2._parseValue(i2[a2]), isNaN(r2.min) || isNaN(r2.max) || n2.data[a2].hidden || (l2[a2] = l2[a2] || 0, u2[a2] = u2[a2] || 0, o2.relativePoints ? l2[a2] = 100 : r2.min < 0 || r2.max < 0 ? u2[a2] += r2.min : l2[a2] += r2.max);
      }
      function Dn(t2, e2, n2) {
        var i2, a2, r2 = n2.length;
        for (i2 = 0; i2 < r2; ++i2) a2 = t2._parseValue(n2[i2]), isNaN(a2.min) || isNaN(a2.max) || e2.data[i2].hidden || (t2.min = Math.min(t2.min, a2.min), t2.max = Math.max(t2.max, a2.max));
      }
      var Tn = Cn.extend({ determineDataLimits: function() {
        var t2, e2, n2, i2, a2 = this, r2 = a2.options, o2 = a2.chart.data.datasets, s2 = a2._getMatchingVisibleMetas(), l2 = r2.stacked, u2 = {}, d2 = s2.length;
        if (a2.min = Number.POSITIVE_INFINITY, a2.max = Number.NEGATIVE_INFINITY, void 0 === l2) for (t2 = 0; !l2 && t2 < d2; ++t2) l2 = void 0 !== (e2 = s2[t2]).stack;
        for (t2 = 0; t2 < d2; ++t2) n2 = o2[(e2 = s2[t2]).index].data, l2 ? An(a2, u2, e2, n2) : Dn(a2, e2, n2);
        H.each(u2, function(t3) {
          i2 = t3.pos.concat(t3.neg), a2.min = Math.min(a2.min, H.min(i2)), a2.max = Math.max(a2.max, H.max(i2));
        }), a2.min = H.isFinite(a2.min) && !isNaN(a2.min) ? a2.min : 0, a2.max = H.isFinite(a2.max) && !isNaN(a2.max) ? a2.max : 1, a2.handleTickRangeOptions();
      }, _computeTickLimit: function() {
        var t2;
        return this.isHorizontal() ? Math.ceil(this.width / 40) : (t2 = H.options._parseFont(this.options.ticks), Math.ceil(this.height / t2.lineHeight));
      }, handleDirectionalChanges: function() {
        this.isHorizontal() || this.ticks.reverse();
      }, getLabelForIndex: function(t2, e2) {
        return this._getScaleLabel(this.chart.data.datasets[e2].data[t2]);
      }, getPixelForValue: function(t2) {
        return this.getPixelForDecimal((+this.getRightValue(t2) - this._startValue) / this._valueRange);
      }, getValueForPixel: function(t2) {
        return this._startValue + this.getDecimalForPixel(t2) * this._valueRange;
      }, getPixelForTick: function(t2) {
        var e2 = this.ticksAsNumbers;
        return t2 < 0 || t2 > e2.length - 1 ? null : this.getPixelForValue(e2[t2]);
      } }), In = Pn;
      Tn._defaults = In;
      var Fn = H.valueOrDefault, On = H.math.log10;
      var Ln = { position: "left", ticks: { callback: on.formatters.logarithmic } };
      function Rn(t2, e2) {
        return H.isFinite(t2) && t2 >= 0 ? t2 : e2;
      }
      var zn = yn.extend({ determineDataLimits: function() {
        var t2, e2, n2, i2, a2, r2, o2 = this, s2 = o2.options, l2 = o2.chart, u2 = l2.data.datasets, d2 = o2.isHorizontal();
        function h2(t3) {
          return d2 ? t3.xAxisID === o2.id : t3.yAxisID === o2.id;
        }
        o2.min = Number.POSITIVE_INFINITY, o2.max = Number.NEGATIVE_INFINITY, o2.minNotZero = Number.POSITIVE_INFINITY;
        var c2 = s2.stacked;
        if (void 0 === c2) {
          for (t2 = 0; t2 < u2.length; t2++) if (e2 = l2.getDatasetMeta(t2), l2.isDatasetVisible(t2) && h2(e2) && void 0 !== e2.stack) {
            c2 = true;
            break;
          }
        }
        if (s2.stacked || c2) {
          var f2 = {};
          for (t2 = 0; t2 < u2.length; t2++) {
            var g2 = [(e2 = l2.getDatasetMeta(t2)).type, void 0 === s2.stacked && void 0 === e2.stack ? t2 : "", e2.stack].join(".");
            if (l2.isDatasetVisible(t2) && h2(e2)) for (void 0 === f2[g2] && (f2[g2] = []), a2 = 0, r2 = (i2 = u2[t2].data).length; a2 < r2; a2++) {
              var p2 = f2[g2];
              n2 = o2._parseValue(i2[a2]), isNaN(n2.min) || isNaN(n2.max) || e2.data[a2].hidden || n2.min < 0 || n2.max < 0 || (p2[a2] = p2[a2] || 0, p2[a2] += n2.max);
            }
          }
          H.each(f2, function(t3) {
            if (t3.length > 0) {
              var e3 = H.min(t3), n3 = H.max(t3);
              o2.min = Math.min(o2.min, e3), o2.max = Math.max(o2.max, n3);
            }
          });
        } else for (t2 = 0; t2 < u2.length; t2++) if (e2 = l2.getDatasetMeta(t2), l2.isDatasetVisible(t2) && h2(e2)) for (a2 = 0, r2 = (i2 = u2[t2].data).length; a2 < r2; a2++) n2 = o2._parseValue(i2[a2]), isNaN(n2.min) || isNaN(n2.max) || e2.data[a2].hidden || n2.min < 0 || n2.max < 0 || (o2.min = Math.min(n2.min, o2.min), o2.max = Math.max(n2.max, o2.max), 0 !== n2.min && (o2.minNotZero = Math.min(n2.min, o2.minNotZero)));
        o2.min = H.isFinite(o2.min) ? o2.min : null, o2.max = H.isFinite(o2.max) ? o2.max : null, o2.minNotZero = H.isFinite(o2.minNotZero) ? o2.minNotZero : null, this.handleTickRangeOptions();
      }, handleTickRangeOptions: function() {
        var t2 = this, e2 = t2.options.ticks;
        t2.min = Rn(e2.min, t2.min), t2.max = Rn(e2.max, t2.max), t2.min === t2.max && (0 !== t2.min && null !== t2.min ? (t2.min = Math.pow(10, Math.floor(On(t2.min)) - 1), t2.max = Math.pow(10, Math.floor(On(t2.max)) + 1)) : (t2.min = 1, t2.max = 10)), null === t2.min && (t2.min = Math.pow(10, Math.floor(On(t2.max)) - 1)), null === t2.max && (t2.max = 0 !== t2.min ? Math.pow(10, Math.floor(On(t2.min)) + 1) : 10), null === t2.minNotZero && (t2.min > 0 ? t2.minNotZero = t2.min : t2.max < 1 ? t2.minNotZero = Math.pow(10, Math.floor(On(t2.max))) : t2.minNotZero = 1);
      }, buildTicks: function() {
        var t2 = this, e2 = t2.options.ticks, n2 = !t2.isHorizontal(), i2 = { min: Rn(e2.min), max: Rn(e2.max) }, a2 = t2.ticks = function(t3, e3) {
          var n3, i3, a3 = [], r2 = Fn(t3.min, Math.pow(10, Math.floor(On(e3.min)))), o2 = Math.floor(On(e3.max)), s2 = Math.ceil(e3.max / Math.pow(10, o2));
          0 === r2 ? (n3 = Math.floor(On(e3.minNotZero)), i3 = Math.floor(e3.minNotZero / Math.pow(10, n3)), a3.push(r2), r2 = i3 * Math.pow(10, n3)) : (n3 = Math.floor(On(r2)), i3 = Math.floor(r2 / Math.pow(10, n3)));
          var l2 = n3 < 0 ? Math.pow(10, Math.abs(n3)) : 1;
          do {
            a3.push(r2), 10 === ++i3 && (i3 = 1, l2 = ++n3 >= 0 ? 1 : l2), r2 = Math.round(i3 * Math.pow(10, n3) * l2) / l2;
          } while (n3 < o2 || n3 === o2 && i3 < s2);
          var u2 = Fn(t3.max, r2);
          return a3.push(u2), a3;
        }(i2, t2);
        t2.max = H.max(a2), t2.min = H.min(a2), e2.reverse ? (n2 = !n2, t2.start = t2.max, t2.end = t2.min) : (t2.start = t2.min, t2.end = t2.max), n2 && a2.reverse();
      }, convertTicksToLabels: function() {
        this.tickValues = this.ticks.slice(), yn.prototype.convertTicksToLabels.call(this);
      }, getLabelForIndex: function(t2, e2) {
        return this._getScaleLabel(this.chart.data.datasets[e2].data[t2]);
      }, getPixelForTick: function(t2) {
        var e2 = this.tickValues;
        return t2 < 0 || t2 > e2.length - 1 ? null : this.getPixelForValue(e2[t2]);
      }, _getFirstTickValue: function(t2) {
        var e2 = Math.floor(On(t2));
        return Math.floor(t2 / Math.pow(10, e2)) * Math.pow(10, e2);
      }, _configure: function() {
        var t2 = this, e2 = t2.min, n2 = 0;
        yn.prototype._configure.call(t2), 0 === e2 && (e2 = t2._getFirstTickValue(t2.minNotZero), n2 = Fn(t2.options.ticks.fontSize, N.global.defaultFontSize) / t2._length), t2._startValue = On(e2), t2._valueOffset = n2, t2._valueRange = (On(t2.max) - On(e2)) / (1 - n2);
      }, getPixelForValue: function(t2) {
        var e2 = this, n2 = 0;
        return (t2 = +e2.getRightValue(t2)) > e2.min && t2 > 0 && (n2 = (On(t2) - e2._startValue) / e2._valueRange + e2._valueOffset), e2.getPixelForDecimal(n2);
      }, getValueForPixel: function(t2) {
        var e2 = this, n2 = e2.getDecimalForPixel(t2);
        return 0 === n2 && 0 === e2.min ? 0 : Math.pow(10, e2._startValue + (n2 - e2._valueOffset) * e2._valueRange);
      } }), Nn = Ln;
      zn._defaults = Nn;
      var Bn = H.valueOrDefault, En = H.valueAtIndexOrDefault, Wn = H.options.resolve, Vn = { display: true, animate: true, position: "chartArea", angleLines: { display: true, color: "rgba(0,0,0,0.1)", lineWidth: 1, borderDash: [], borderDashOffset: 0 }, gridLines: { circular: false }, ticks: { showLabelBackdrop: true, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: on.formatters.linear }, pointLabels: { display: true, fontSize: 10, callback: function(t2) {
        return t2;
      } } };
      function Hn(t2) {
        var e2 = t2.ticks;
        return e2.display && t2.display ? Bn(e2.fontSize, N.global.defaultFontSize) + 2 * e2.backdropPaddingY : 0;
      }
      function jn(t2, e2, n2, i2, a2) {
        return t2 === i2 || t2 === a2 ? { start: e2 - n2 / 2, end: e2 + n2 / 2 } : t2 < i2 || t2 > a2 ? { start: e2 - n2, end: e2 } : { start: e2, end: e2 + n2 };
      }
      function qn(t2) {
        return 0 === t2 || 180 === t2 ? "center" : t2 < 180 ? "left" : "right";
      }
      function Un(t2, e2, n2, i2) {
        var a2, r2, o2 = n2.y + i2 / 2;
        if (H.isArray(e2)) for (a2 = 0, r2 = e2.length; a2 < r2; ++a2) t2.fillText(e2[a2], n2.x, o2), o2 += i2;
        else t2.fillText(e2, n2.x, o2);
      }
      function Yn(t2, e2, n2) {
        90 === t2 || 270 === t2 ? n2.y -= e2.h / 2 : (t2 > 270 || t2 < 90) && (n2.y -= e2.h);
      }
      function Gn(t2) {
        return H.isNumber(t2) ? t2 : 0;
      }
      var Xn = Cn.extend({ setDimensions: function() {
        var t2 = this;
        t2.width = t2.maxWidth, t2.height = t2.maxHeight, t2.paddingTop = Hn(t2.options) / 2, t2.xCenter = Math.floor(t2.width / 2), t2.yCenter = Math.floor((t2.height - t2.paddingTop) / 2), t2.drawingArea = Math.min(t2.height - t2.paddingTop, t2.width) / 2;
      }, determineDataLimits: function() {
        var t2 = this, e2 = t2.chart, n2 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY;
        H.each(e2.data.datasets, function(a2, r2) {
          if (e2.isDatasetVisible(r2)) {
            var o2 = e2.getDatasetMeta(r2);
            H.each(a2.data, function(e3, a3) {
              var r3 = +t2.getRightValue(e3);
              isNaN(r3) || o2.data[a3].hidden || (n2 = Math.min(r3, n2), i2 = Math.max(r3, i2));
            });
          }
        }), t2.min = n2 === Number.POSITIVE_INFINITY ? 0 : n2, t2.max = i2 === Number.NEGATIVE_INFINITY ? 0 : i2, t2.handleTickRangeOptions();
      }, _computeTickLimit: function() {
        return Math.ceil(this.drawingArea / Hn(this.options));
      }, convertTicksToLabels: function() {
        var t2 = this;
        Cn.prototype.convertTicksToLabels.call(t2), t2.pointLabels = t2.chart.data.labels.map(function() {
          var e2 = H.callback(t2.options.pointLabels.callback, arguments, t2);
          return e2 || 0 === e2 ? e2 : "";
        });
      }, getLabelForIndex: function(t2, e2) {
        return +this.getRightValue(this.chart.data.datasets[e2].data[t2]);
      }, fit: function() {
        var t2 = this.options;
        t2.display && t2.pointLabels.display ? function(t3) {
          var e2, n2, i2, a2 = H.options._parseFont(t3.options.pointLabels), r2 = { l: 0, r: t3.width, t: 0, b: t3.height - t3.paddingTop }, o2 = {};
          t3.ctx.font = a2.string, t3._pointLabelSizes = [];
          var s2, l2, u2, d2 = t3.chart.data.labels.length;
          for (e2 = 0; e2 < d2; e2++) {
            i2 = t3.getPointPosition(e2, t3.drawingArea + 5), s2 = t3.ctx, l2 = a2.lineHeight, u2 = t3.pointLabels[e2], n2 = H.isArray(u2) ? { w: H.longestText(s2, s2.font, u2), h: u2.length * l2 } : { w: s2.measureText(u2).width, h: l2 }, t3._pointLabelSizes[e2] = n2;
            var h2 = t3.getIndexAngle(e2), c2 = H.toDegrees(h2) % 360, f2 = jn(c2, i2.x, n2.w, 0, 180), g2 = jn(c2, i2.y, n2.h, 90, 270);
            f2.start < r2.l && (r2.l = f2.start, o2.l = h2), f2.end > r2.r && (r2.r = f2.end, o2.r = h2), g2.start < r2.t && (r2.t = g2.start, o2.t = h2), g2.end > r2.b && (r2.b = g2.end, o2.b = h2);
          }
          t3.setReductions(t3.drawingArea, r2, o2);
        }(this) : this.setCenterPoint(0, 0, 0, 0);
      }, setReductions: function(t2, e2, n2) {
        var i2 = this, a2 = e2.l / Math.sin(n2.l), r2 = Math.max(e2.r - i2.width, 0) / Math.sin(n2.r), o2 = -e2.t / Math.cos(n2.t), s2 = -Math.max(e2.b - (i2.height - i2.paddingTop), 0) / Math.cos(n2.b);
        a2 = Gn(a2), r2 = Gn(r2), o2 = Gn(o2), s2 = Gn(s2), i2.drawingArea = Math.min(Math.floor(t2 - (a2 + r2) / 2), Math.floor(t2 - (o2 + s2) / 2)), i2.setCenterPoint(a2, r2, o2, s2);
      }, setCenterPoint: function(t2, e2, n2, i2) {
        var a2 = this, r2 = a2.width - e2 - a2.drawingArea, o2 = t2 + a2.drawingArea, s2 = n2 + a2.drawingArea, l2 = a2.height - a2.paddingTop - i2 - a2.drawingArea;
        a2.xCenter = Math.floor((o2 + r2) / 2 + a2.left), a2.yCenter = Math.floor((s2 + l2) / 2 + a2.top + a2.paddingTop);
      }, getIndexAngle: function(t2) {
        var e2 = this.chart, n2 = (t2 * (360 / e2.data.labels.length) + ((e2.options || {}).startAngle || 0)) % 360;
        return (n2 < 0 ? n2 + 360 : n2) * Math.PI * 2 / 360;
      }, getDistanceFromCenterForValue: function(t2) {
        var e2 = this;
        if (H.isNullOrUndef(t2)) return NaN;
        var n2 = e2.drawingArea / (e2.max - e2.min);
        return e2.options.ticks.reverse ? (e2.max - t2) * n2 : (t2 - e2.min) * n2;
      }, getPointPosition: function(t2, e2) {
        var n2 = this.getIndexAngle(t2) - Math.PI / 2;
        return { x: Math.cos(n2) * e2 + this.xCenter, y: Math.sin(n2) * e2 + this.yCenter };
      }, getPointPositionForValue: function(t2, e2) {
        return this.getPointPosition(t2, this.getDistanceFromCenterForValue(e2));
      }, getBasePosition: function(t2) {
        var e2 = this.min, n2 = this.max;
        return this.getPointPositionForValue(t2 || 0, this.beginAtZero ? 0 : e2 < 0 && n2 < 0 ? n2 : e2 > 0 && n2 > 0 ? e2 : 0);
      }, _drawGrid: function() {
        var t2, e2, n2, i2 = this, a2 = i2.ctx, r2 = i2.options, o2 = r2.gridLines, s2 = r2.angleLines, l2 = Bn(s2.lineWidth, o2.lineWidth), u2 = Bn(s2.color, o2.color);
        if (r2.pointLabels.display && function(t3) {
          var e3 = t3.ctx, n3 = t3.options, i3 = n3.pointLabels, a3 = Hn(n3), r3 = t3.getDistanceFromCenterForValue(n3.ticks.reverse ? t3.min : t3.max), o3 = H.options._parseFont(i3);
          e3.save(), e3.font = o3.string, e3.textBaseline = "middle";
          for (var s3 = t3.chart.data.labels.length - 1; s3 >= 0; s3--) {
            var l3 = 0 === s3 ? a3 / 2 : 0, u3 = t3.getPointPosition(s3, r3 + l3 + 5), d2 = En(i3.fontColor, s3, N.global.defaultFontColor);
            e3.fillStyle = d2;
            var h2 = t3.getIndexAngle(s3), c2 = H.toDegrees(h2);
            e3.textAlign = qn(c2), Yn(c2, t3._pointLabelSizes[s3], u3), Un(e3, t3.pointLabels[s3], u3, o3.lineHeight);
          }
          e3.restore();
        }(i2), o2.display && H.each(i2.ticks, function(t3, n3) {
          0 !== n3 && (e2 = i2.getDistanceFromCenterForValue(i2.ticksAsNumbers[n3]), function(t4, e3, n4, i3) {
            var a3, r3 = t4.ctx, o3 = e3.circular, s3 = t4.chart.data.labels.length, l3 = En(e3.color, i3 - 1), u3 = En(e3.lineWidth, i3 - 1);
            if ((o3 || s3) && l3 && u3) {
              if (r3.save(), r3.strokeStyle = l3, r3.lineWidth = u3, r3.setLineDash && (r3.setLineDash(e3.borderDash || []), r3.lineDashOffset = e3.borderDashOffset || 0), r3.beginPath(), o3) r3.arc(t4.xCenter, t4.yCenter, n4, 0, 2 * Math.PI);
              else {
                a3 = t4.getPointPosition(0, n4), r3.moveTo(a3.x, a3.y);
                for (var d2 = 1; d2 < s3; d2++) a3 = t4.getPointPosition(d2, n4), r3.lineTo(a3.x, a3.y);
              }
              r3.closePath(), r3.stroke(), r3.restore();
            }
          }(i2, o2, e2, n3));
        }), s2.display && l2 && u2) {
          for (a2.save(), a2.lineWidth = l2, a2.strokeStyle = u2, a2.setLineDash && (a2.setLineDash(Wn([s2.borderDash, o2.borderDash, []])), a2.lineDashOffset = Wn([s2.borderDashOffset, o2.borderDashOffset, 0])), t2 = i2.chart.data.labels.length - 1; t2 >= 0; t2--) e2 = i2.getDistanceFromCenterForValue(r2.ticks.reverse ? i2.min : i2.max), n2 = i2.getPointPosition(t2, e2), a2.beginPath(), a2.moveTo(i2.xCenter, i2.yCenter), a2.lineTo(n2.x, n2.y), a2.stroke();
          a2.restore();
        }
      }, _drawLabels: function() {
        var t2 = this, e2 = t2.ctx, n2 = t2.options.ticks;
        if (n2.display) {
          var i2, a2, r2 = t2.getIndexAngle(0), o2 = H.options._parseFont(n2), s2 = Bn(n2.fontColor, N.global.defaultFontColor);
          e2.save(), e2.font = o2.string, e2.translate(t2.xCenter, t2.yCenter), e2.rotate(r2), e2.textAlign = "center", e2.textBaseline = "middle", H.each(t2.ticks, function(r3, l2) {
            (0 !== l2 || n2.reverse) && (i2 = t2.getDistanceFromCenterForValue(t2.ticksAsNumbers[l2]), n2.showLabelBackdrop && (a2 = e2.measureText(r3).width, e2.fillStyle = n2.backdropColor, e2.fillRect(-a2 / 2 - n2.backdropPaddingX, -i2 - o2.size / 2 - n2.backdropPaddingY, a2 + 2 * n2.backdropPaddingX, o2.size + 2 * n2.backdropPaddingY)), e2.fillStyle = s2, e2.fillText(r3, 0, -i2));
          }), e2.restore();
        }
      }, _drawTitle: H.noop }), Kn = Vn;
      Xn._defaults = Kn;
      var Zn = H._deprecated, $n = H.options.resolve, Jn = H.valueOrDefault, Qn = Number.MIN_SAFE_INTEGER || -9007199254740991, ti = Number.MAX_SAFE_INTEGER || 9007199254740991, ei = { millisecond: { common: true, size: 1, steps: 1e3 }, second: { common: true, size: 1e3, steps: 60 }, minute: { common: true, size: 6e4, steps: 60 }, hour: { common: true, size: 36e5, steps: 24 }, day: { common: true, size: 864e5, steps: 30 }, week: { common: false, size: 6048e5, steps: 4 }, month: { common: true, size: 2628e6, steps: 12 }, quarter: { common: false, size: 7884e6, steps: 4 }, year: { common: true, size: 3154e7 } }, ni = Object.keys(ei);
      function ii(t2, e2) {
        return t2 - e2;
      }
      function ai(t2) {
        return H.valueOrDefault(t2.time.min, t2.ticks.min);
      }
      function ri(t2) {
        return H.valueOrDefault(t2.time.max, t2.ticks.max);
      }
      function oi(t2, e2, n2, i2) {
        var a2 = function(t3, e3, n3) {
          for (var i3, a3, r3, o3 = 0, s3 = t3.length - 1; o3 >= 0 && o3 <= s3; ) {
            if (a3 = t3[(i3 = o3 + s3 >> 1) - 1] || null, r3 = t3[i3], !a3) return { lo: null, hi: r3 };
            if (r3[e3] < n3) o3 = i3 + 1;
            else {
              if (!(a3[e3] > n3)) return { lo: a3, hi: r3 };
              s3 = i3 - 1;
            }
          }
          return { lo: r3, hi: null };
        }(t2, e2, n2), r2 = a2.lo ? a2.hi ? a2.lo : t2[t2.length - 2] : t2[0], o2 = a2.lo ? a2.hi ? a2.hi : t2[t2.length - 1] : t2[1], s2 = o2[e2] - r2[e2], l2 = s2 ? (n2 - r2[e2]) / s2 : 0, u2 = (o2[i2] - r2[i2]) * l2;
        return r2[i2] + u2;
      }
      function si(t2, e2) {
        var n2 = t2._adapter, i2 = t2.options.time, a2 = i2.parser, r2 = a2 || i2.format, o2 = e2;
        return "function" == typeof a2 && (o2 = a2(o2)), H.isFinite(o2) || (o2 = "string" == typeof r2 ? n2.parse(o2, r2) : n2.parse(o2)), null !== o2 ? +o2 : (a2 || "function" != typeof r2 || (o2 = r2(e2), H.isFinite(o2) || (o2 = n2.parse(o2))), o2);
      }
      function li(t2, e2) {
        if (H.isNullOrUndef(e2)) return null;
        var n2 = t2.options.time, i2 = si(t2, t2.getRightValue(e2));
        return null === i2 ? i2 : (n2.round && (i2 = +t2._adapter.startOf(i2, n2.round)), i2);
      }
      function ui(t2, e2, n2, i2) {
        var a2, r2, o2, s2 = ni.length;
        for (a2 = ni.indexOf(t2); a2 < s2 - 1; ++a2) if (o2 = (r2 = ei[ni[a2]]).steps ? r2.steps : ti, r2.common && Math.ceil((n2 - e2) / (o2 * r2.size)) <= i2) return ni[a2];
        return ni[s2 - 1];
      }
      function di(t2, e2, n2) {
        var i2, a2, r2 = [], o2 = {}, s2 = e2.length;
        for (i2 = 0; i2 < s2; ++i2) o2[a2 = e2[i2]] = i2, r2.push({ value: a2, major: false });
        return 0 !== s2 && n2 ? function(t3, e3, n3, i3) {
          var a3, r3, o3 = t3._adapter, s3 = +o3.startOf(e3[0].value, i3), l2 = e3[e3.length - 1].value;
          for (a3 = s3; a3 <= l2; a3 = +o3.add(a3, 1, i3)) (r3 = n3[a3]) >= 0 && (e3[r3].major = true);
          return e3;
        }(t2, r2, o2, n2) : r2;
      }
      var hi = yn.extend({ initialize: function() {
        this.mergeTicksOptions(), yn.prototype.initialize.call(this);
      }, update: function() {
        var t2 = this, e2 = t2.options, n2 = e2.time || (e2.time = {}), i2 = t2._adapter = new rn._date(e2.adapters.date);
        return Zn("time scale", n2.format, "time.format", "time.parser"), Zn("time scale", n2.min, "time.min", "ticks.min"), Zn("time scale", n2.max, "time.max", "ticks.max"), H.mergeIf(n2.displayFormats, i2.formats()), yn.prototype.update.apply(t2, arguments);
      }, getRightValue: function(t2) {
        return t2 && void 0 !== t2.t && (t2 = t2.t), yn.prototype.getRightValue.call(this, t2);
      }, determineDataLimits: function() {
        var t2, e2, n2, i2, a2, r2, o2, s2 = this, l2 = s2.chart, u2 = s2._adapter, d2 = s2.options, h2 = d2.time.unit || "day", c2 = ti, f2 = Qn, g2 = [], p2 = [], m2 = [], v2 = s2._getLabels();
        for (t2 = 0, n2 = v2.length; t2 < n2; ++t2) m2.push(li(s2, v2[t2]));
        for (t2 = 0, n2 = (l2.data.datasets || []).length; t2 < n2; ++t2) if (l2.isDatasetVisible(t2)) if (a2 = l2.data.datasets[t2].data, H.isObject(a2[0])) for (p2[t2] = [], e2 = 0, i2 = a2.length; e2 < i2; ++e2) r2 = li(s2, a2[e2]), g2.push(r2), p2[t2][e2] = r2;
        else p2[t2] = m2.slice(0), o2 || (g2 = g2.concat(m2), o2 = true);
        else p2[t2] = [];
        m2.length && (c2 = Math.min(c2, m2[0]), f2 = Math.max(f2, m2[m2.length - 1])), g2.length && (g2 = n2 > 1 ? function(t3) {
          var e3, n3, i3, a3 = {}, r3 = [];
          for (e3 = 0, n3 = t3.length; e3 < n3; ++e3) a3[i3 = t3[e3]] || (a3[i3] = true, r3.push(i3));
          return r3;
        }(g2).sort(ii) : g2.sort(ii), c2 = Math.min(c2, g2[0]), f2 = Math.max(f2, g2[g2.length - 1])), c2 = li(s2, ai(d2)) || c2, f2 = li(s2, ri(d2)) || f2, c2 = c2 === ti ? +u2.startOf(Date.now(), h2) : c2, f2 = f2 === Qn ? +u2.endOf(Date.now(), h2) + 1 : f2, s2.min = Math.min(c2, f2), s2.max = Math.max(c2 + 1, f2), s2._table = [], s2._timestamps = { data: g2, datasets: p2, labels: m2 };
      }, buildTicks: function() {
        var t2, e2, n2, i2 = this, a2 = i2.min, r2 = i2.max, o2 = i2.options, s2 = o2.ticks, l2 = o2.time, u2 = i2._timestamps, d2 = [], h2 = i2.getLabelCapacity(a2), c2 = s2.source, f2 = o2.distribution;
        for (u2 = "data" === c2 || "auto" === c2 && "series" === f2 ? u2.data : "labels" === c2 ? u2.labels : function(t3, e3, n3, i3) {
          var a3, r3 = t3._adapter, o3 = t3.options, s3 = o3.time, l3 = s3.unit || ui(s3.minUnit, e3, n3, i3), u3 = $n([s3.stepSize, s3.unitStepSize, 1]), d3 = "week" === l3 && s3.isoWeekday, h3 = e3, c3 = [];
          if (d3 && (h3 = +r3.startOf(h3, "isoWeek", d3)), h3 = +r3.startOf(h3, d3 ? "day" : l3), r3.diff(n3, e3, l3) > 1e5 * u3) throw e3 + " and " + n3 + " are too far apart with stepSize of " + u3 + " " + l3;
          for (a3 = h3; a3 < n3; a3 = +r3.add(a3, u3, l3)) c3.push(a3);
          return a3 !== n3 && "ticks" !== o3.bounds || c3.push(a3), c3;
        }(i2, a2, r2, h2), "ticks" === o2.bounds && u2.length && (a2 = u2[0], r2 = u2[u2.length - 1]), a2 = li(i2, ai(o2)) || a2, r2 = li(i2, ri(o2)) || r2, t2 = 0, e2 = u2.length; t2 < e2; ++t2) (n2 = u2[t2]) >= a2 && n2 <= r2 && d2.push(n2);
        return i2.min = a2, i2.max = r2, i2._unit = l2.unit || (s2.autoSkip ? ui(l2.minUnit, i2.min, i2.max, h2) : function(t3, e3, n3, i3, a3) {
          var r3, o3;
          for (r3 = ni.length - 1; r3 >= ni.indexOf(n3); r3--) if (o3 = ni[r3], ei[o3].common && t3._adapter.diff(a3, i3, o3) >= e3 - 1) return o3;
          return ni[n3 ? ni.indexOf(n3) : 0];
        }(i2, d2.length, l2.minUnit, i2.min, i2.max)), i2._majorUnit = s2.major.enabled && "year" !== i2._unit ? function(t3) {
          for (var e3 = ni.indexOf(t3) + 1, n3 = ni.length; e3 < n3; ++e3) if (ei[ni[e3]].common) return ni[e3];
        }(i2._unit) : void 0, i2._table = function(t3, e3, n3, i3) {
          if ("linear" === i3 || !t3.length) return [{ time: e3, pos: 0 }, { time: n3, pos: 1 }];
          var a3, r3, o3, s3, l3, u3 = [], d3 = [e3];
          for (a3 = 0, r3 = t3.length; a3 < r3; ++a3) (s3 = t3[a3]) > e3 && s3 < n3 && d3.push(s3);
          for (d3.push(n3), a3 = 0, r3 = d3.length; a3 < r3; ++a3) l3 = d3[a3 + 1], o3 = d3[a3 - 1], s3 = d3[a3], void 0 !== o3 && void 0 !== l3 && Math.round((l3 + o3) / 2) === s3 || u3.push({ time: s3, pos: a3 / (r3 - 1) });
          return u3;
        }(i2._timestamps.data, a2, r2, f2), i2._offsets = function(t3, e3, n3, i3, a3) {
          var r3, o3, s3 = 0, l3 = 0;
          return a3.offset && e3.length && (r3 = oi(t3, "time", e3[0], "pos"), s3 = 1 === e3.length ? 1 - r3 : (oi(t3, "time", e3[1], "pos") - r3) / 2, o3 = oi(t3, "time", e3[e3.length - 1], "pos"), l3 = 1 === e3.length ? o3 : (o3 - oi(t3, "time", e3[e3.length - 2], "pos")) / 2), { start: s3, end: l3, factor: 1 / (s3 + 1 + l3) };
        }(i2._table, d2, 0, 0, o2), s2.reverse && d2.reverse(), di(i2, d2, i2._majorUnit);
      }, getLabelForIndex: function(t2, e2) {
        var n2 = this, i2 = n2._adapter, a2 = n2.chart.data, r2 = n2.options.time, o2 = a2.labels && t2 < a2.labels.length ? a2.labels[t2] : "", s2 = a2.datasets[e2].data[t2];
        return H.isObject(s2) && (o2 = n2.getRightValue(s2)), r2.tooltipFormat ? i2.format(si(n2, o2), r2.tooltipFormat) : "string" == typeof o2 ? o2 : i2.format(si(n2, o2), r2.displayFormats.datetime);
      }, tickFormatFunction: function(t2, e2, n2, i2) {
        var a2 = this._adapter, r2 = this.options, o2 = r2.time.displayFormats, s2 = o2[this._unit], l2 = this._majorUnit, u2 = o2[l2], d2 = n2[e2], h2 = r2.ticks, c2 = l2 && u2 && d2 && d2.major, f2 = a2.format(t2, i2 || (c2 ? u2 : s2)), g2 = c2 ? h2.major : h2.minor, p2 = $n([g2.callback, g2.userCallback, h2.callback, h2.userCallback]);
        return p2 ? p2(f2, e2, n2) : f2;
      }, convertTicksToLabels: function(t2) {
        var e2, n2, i2 = [];
        for (e2 = 0, n2 = t2.length; e2 < n2; ++e2) i2.push(this.tickFormatFunction(t2[e2].value, e2, t2));
        return i2;
      }, getPixelForOffset: function(t2) {
        var e2 = this._offsets, n2 = oi(this._table, "time", t2, "pos");
        return this.getPixelForDecimal((e2.start + n2) * e2.factor);
      }, getPixelForValue: function(t2, e2, n2) {
        var i2 = null;
        if (void 0 !== e2 && void 0 !== n2 && (i2 = this._timestamps.datasets[n2][e2]), null === i2 && (i2 = li(this, t2)), null !== i2) return this.getPixelForOffset(i2);
      }, getPixelForTick: function(t2) {
        var e2 = this.getTicks();
        return t2 >= 0 && t2 < e2.length ? this.getPixelForOffset(e2[t2].value) : null;
      }, getValueForPixel: function(t2) {
        var e2 = this._offsets, n2 = this.getDecimalForPixel(t2) / e2.factor - e2.end, i2 = oi(this._table, "pos", n2, "time");
        return this._adapter._create(i2);
      }, _getLabelSize: function(t2) {
        var e2 = this.options.ticks, n2 = this.ctx.measureText(t2).width, i2 = H.toRadians(this.isHorizontal() ? e2.maxRotation : e2.minRotation), a2 = Math.cos(i2), r2 = Math.sin(i2), o2 = Jn(e2.fontSize, N.global.defaultFontSize);
        return { w: n2 * a2 + o2 * r2, h: n2 * r2 + o2 * a2 };
      }, getLabelWidth: function(t2) {
        return this._getLabelSize(t2).w;
      }, getLabelCapacity: function(t2) {
        var e2 = this, n2 = e2.options.time, i2 = n2.displayFormats, a2 = i2[n2.unit] || i2.millisecond, r2 = e2.tickFormatFunction(t2, 0, di(e2, [t2], e2._majorUnit), a2), o2 = e2._getLabelSize(r2), s2 = Math.floor(e2.isHorizontal() ? e2.width / o2.w : e2.height / o2.h);
        return e2.options.offset && s2--, s2 > 0 ? s2 : 1;
      } }), ci = { position: "bottom", distribution: "linear", bounds: "data", adapters: {}, time: { parser: false, unit: false, round: false, displayFormat: false, isoWeekday: false, minUnit: "millisecond", displayFormats: {} }, ticks: { autoSkip: false, source: "auto", major: { enabled: false } } };
      hi._defaults = ci;
      var fi = { category: kn, linear: Tn, logarithmic: zn, radialLinear: Xn, time: hi }, gi = { datetime: "MMM D, YYYY, h:mm:ss a", millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" };
      rn._date.override("function" == typeof t ? { _id: "moment", formats: function() {
        return gi;
      }, parse: function(e2, n2) {
        return "string" == typeof e2 && "string" == typeof n2 ? e2 = t(e2, n2) : e2 instanceof t || (e2 = t(e2)), e2.isValid() ? e2.valueOf() : null;
      }, format: function(e2, n2) {
        return t(e2).format(n2);
      }, add: function(e2, n2, i2) {
        return t(e2).add(n2, i2).valueOf();
      }, diff: function(e2, n2, i2) {
        return t(e2).diff(t(n2), i2);
      }, startOf: function(e2, n2, i2) {
        return e2 = t(e2), "isoWeek" === n2 ? e2.isoWeekday(i2).valueOf() : e2.startOf(n2).valueOf();
      }, endOf: function(e2, n2) {
        return t(e2).endOf(n2).valueOf();
      }, _create: function(e2) {
        return t(e2);
      } } : {}), N._set("global", { plugins: { filler: { propagate: true } } });
      var pi = { dataset: function(t2) {
        var e2 = t2.fill, n2 = t2.chart, i2 = n2.getDatasetMeta(e2), a2 = i2 && n2.isDatasetVisible(e2) && i2.dataset._children || [], r2 = a2.length || 0;
        return r2 ? function(t3, e3) {
          return e3 < r2 && a2[e3]._view || null;
        } : null;
      }, boundary: function(t2) {
        var e2 = t2.boundary, n2 = e2 ? e2.x : null, i2 = e2 ? e2.y : null;
        return H.isArray(e2) ? function(t3, n3) {
          return e2[n3];
        } : function(t3) {
          return { x: null === n2 ? t3.x : n2, y: null === i2 ? t3.y : i2 };
        };
      } };
      function mi(t2, e2, n2) {
        var i2, a2 = t2._model || {}, r2 = a2.fill;
        if (void 0 === r2 && (r2 = !!a2.backgroundColor), false === r2 || null === r2) return false;
        if (true === r2) return "origin";
        if (i2 = parseFloat(r2, 10), isFinite(i2) && Math.floor(i2) === i2) return "-" !== r2[0] && "+" !== r2[0] || (i2 = e2 + i2), !(i2 === e2 || i2 < 0 || i2 >= n2) && i2;
        switch (r2) {
          case "bottom":
            return "start";
          case "top":
            return "end";
          case "zero":
            return "origin";
          case "origin":
          case "start":
          case "end":
            return r2;
          default:
            return false;
        }
      }
      function vi(t2) {
        return (t2.el._scale || {}).getPointPositionForValue ? function(t3) {
          var e2, n2, i2, a2, r2, o2 = t3.el._scale, s2 = o2.options, l2 = o2.chart.data.labels.length, u2 = t3.fill, d2 = [];
          if (!l2) return null;
          for (e2 = s2.ticks.reverse ? o2.max : o2.min, n2 = s2.ticks.reverse ? o2.min : o2.max, i2 = o2.getPointPositionForValue(0, e2), a2 = 0; a2 < l2; ++a2) r2 = "start" === u2 || "end" === u2 ? o2.getPointPositionForValue(a2, "start" === u2 ? e2 : n2) : o2.getBasePosition(a2), s2.gridLines.circular && (r2.cx = i2.x, r2.cy = i2.y, r2.angle = o2.getIndexAngle(a2) - Math.PI / 2), d2.push(r2);
          return d2;
        }(t2) : function(t3) {
          var e2, n2 = t3.el._model || {}, i2 = t3.el._scale || {}, a2 = t3.fill, r2 = null;
          if (isFinite(a2)) return null;
          if ("start" === a2 ? r2 = void 0 === n2.scaleBottom ? i2.bottom : n2.scaleBottom : "end" === a2 ? r2 = void 0 === n2.scaleTop ? i2.top : n2.scaleTop : void 0 !== n2.scaleZero ? r2 = n2.scaleZero : i2.getBasePixel && (r2 = i2.getBasePixel()), null != r2) {
            if (void 0 !== r2.x && void 0 !== r2.y) return r2;
            if (H.isFinite(r2)) return { x: (e2 = i2.isHorizontal()) ? r2 : null, y: e2 ? null : r2 };
          }
          return null;
        }(t2);
      }
      function bi(t2, e2, n2) {
        var i2, a2 = t2[e2].fill, r2 = [e2];
        if (!n2) return a2;
        for (; false !== a2 && -1 === r2.indexOf(a2); ) {
          if (!isFinite(a2)) return a2;
          if (!(i2 = t2[a2])) return false;
          if (i2.visible) return a2;
          r2.push(a2), a2 = i2.fill;
        }
        return false;
      }
      function xi(t2) {
        var e2 = t2.fill, n2 = "dataset";
        return false === e2 ? null : (isFinite(e2) || (n2 = "boundary"), pi[n2](t2));
      }
      function yi(t2) {
        return t2 && !t2.skip;
      }
      function _i(t2, e2, n2, i2, a2) {
        var r2, o2, s2, l2;
        if (i2 && a2) {
          for (t2.moveTo(e2[0].x, e2[0].y), r2 = 1; r2 < i2; ++r2) H.canvas.lineTo(t2, e2[r2 - 1], e2[r2]);
          if (void 0 === n2[0].angle) for (t2.lineTo(n2[a2 - 1].x, n2[a2 - 1].y), r2 = a2 - 1; r2 > 0; --r2) H.canvas.lineTo(t2, n2[r2], n2[r2 - 1], true);
          else for (o2 = n2[0].cx, s2 = n2[0].cy, l2 = Math.sqrt(Math.pow(n2[0].x - o2, 2) + Math.pow(n2[0].y - s2, 2)), r2 = a2 - 1; r2 > 0; --r2) t2.arc(o2, s2, l2, n2[r2].angle, n2[r2 - 1].angle, true);
        }
      }
      function ki(t2, e2, n2, i2, a2, r2) {
        var o2, s2, l2, u2, d2, h2, c2, f2, g2 = e2.length, p2 = i2.spanGaps, m2 = [], v2 = [], b2 = 0, x2 = 0;
        for (t2.beginPath(), o2 = 0, s2 = g2; o2 < s2; ++o2) d2 = n2(u2 = e2[l2 = o2 % g2]._view, l2, i2), h2 = yi(u2), c2 = yi(d2), r2 && void 0 === f2 && h2 && (s2 = g2 + (f2 = o2 + 1)), h2 && c2 ? (b2 = m2.push(u2), x2 = v2.push(d2)) : b2 && x2 && (p2 ? (h2 && m2.push(u2), c2 && v2.push(d2)) : (_i(t2, m2, v2, b2, x2), b2 = x2 = 0, m2 = [], v2 = []));
        _i(t2, m2, v2, b2, x2), t2.closePath(), t2.fillStyle = a2, t2.fill();
      }
      var wi = { id: "filler", afterDatasetsUpdate: function(t2, e2) {
        var n2, i2, a2, r2, o2 = (t2.data.datasets || []).length, s2 = e2.propagate, l2 = [];
        for (i2 = 0; i2 < o2; ++i2) r2 = null, (a2 = (n2 = t2.getDatasetMeta(i2)).dataset) && a2._model && a2 instanceof kt.Line && (r2 = { visible: t2.isDatasetVisible(i2), fill: mi(a2, i2, o2), chart: t2, el: a2 }), n2.$filler = r2, l2.push(r2);
        for (i2 = 0; i2 < o2; ++i2) (r2 = l2[i2]) && (r2.fill = bi(l2, i2, s2), r2.boundary = vi(r2), r2.mapper = xi(r2));
      }, beforeDatasetsDraw: function(t2) {
        var e2, n2, i2, a2, r2, o2, s2, l2 = t2._getSortedVisibleDatasetMetas(), u2 = t2.ctx;
        for (n2 = l2.length - 1; n2 >= 0; --n2) (e2 = l2[n2].$filler) && e2.visible && (a2 = (i2 = e2.el)._view, r2 = i2._children || [], o2 = e2.mapper, s2 = a2.backgroundColor || N.global.defaultColor, o2 && s2 && r2.length && (H.canvas.clipArea(u2, t2.chartArea), ki(u2, r2, o2, a2, s2, i2._loop), H.canvas.unclipArea(u2)));
      } }, Mi = H.rtl.getRtlAdapter, Si = H.noop, Ci = H.valueOrDefault;
      function Pi(t2, e2) {
        return t2.usePointStyle && t2.boxWidth > e2 ? e2 : t2.boxWidth;
      }
      N._set("global", { legend: { display: true, position: "top", align: "center", fullWidth: true, reverse: false, weight: 1e3, onClick: function(t2, e2) {
        var n2 = e2.datasetIndex, i2 = this.chart, a2 = i2.getDatasetMeta(n2);
        a2.hidden = null === a2.hidden ? !i2.data.datasets[n2].hidden : null, i2.update();
      }, onHover: null, onLeave: null, labels: { boxWidth: 40, padding: 10, generateLabels: function(t2) {
        var e2 = t2.data.datasets, n2 = t2.options.legend || {}, i2 = n2.labels && n2.labels.usePointStyle;
        return t2._getSortedDatasetMetas().map(function(n3) {
          var a2 = n3.controller.getStyle(i2 ? 0 : void 0);
          return { text: e2[n3.index].label, fillStyle: a2.backgroundColor, hidden: !t2.isDatasetVisible(n3.index), lineCap: a2.borderCapStyle, lineDash: a2.borderDash, lineDashOffset: a2.borderDashOffset, lineJoin: a2.borderJoinStyle, lineWidth: a2.borderWidth, strokeStyle: a2.borderColor, pointStyle: a2.pointStyle, rotation: a2.rotation, datasetIndex: n3.index };
        }, this);
      } } }, legendCallback: function(t2) {
        var e2, n2, i2, a2 = document.createElement("ul"), r2 = t2.data.datasets;
        for (a2.setAttribute("class", t2.id + "-legend"), e2 = 0, n2 = r2.length; e2 < n2; e2++) (i2 = a2.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = r2[e2].backgroundColor, r2[e2].label && i2.appendChild(document.createTextNode(r2[e2].label));
        return a2.outerHTML;
      } });
      var Ai = K.extend({ initialize: function(t2) {
        H.extend(this, t2), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false;
      }, beforeUpdate: Si, update: function(t2, e2, n2) {
        var i2 = this;
        return i2.beforeUpdate(), i2.maxWidth = t2, i2.maxHeight = e2, i2.margins = n2, i2.beforeSetDimensions(), i2.setDimensions(), i2.afterSetDimensions(), i2.beforeBuildLabels(), i2.buildLabels(), i2.afterBuildLabels(), i2.beforeFit(), i2.fit(), i2.afterFit(), i2.afterUpdate(), i2.minSize;
      }, afterUpdate: Si, beforeSetDimensions: Si, setDimensions: function() {
        var t2 = this;
        t2.isHorizontal() ? (t2.width = t2.maxWidth, t2.left = 0, t2.right = t2.width) : (t2.height = t2.maxHeight, t2.top = 0, t2.bottom = t2.height), t2.paddingLeft = 0, t2.paddingTop = 0, t2.paddingRight = 0, t2.paddingBottom = 0, t2.minSize = { width: 0, height: 0 };
      }, afterSetDimensions: Si, beforeBuildLabels: Si, buildLabels: function() {
        var t2 = this, e2 = t2.options.labels || {}, n2 = H.callback(e2.generateLabels, [t2.chart], t2) || [];
        e2.filter && (n2 = n2.filter(function(n3) {
          return e2.filter(n3, t2.chart.data);
        })), t2.options.reverse && n2.reverse(), t2.legendItems = n2;
      }, afterBuildLabels: Si, beforeFit: Si, fit: function() {
        var t2 = this, e2 = t2.options, n2 = e2.labels, i2 = e2.display, a2 = t2.ctx, r2 = H.options._parseFont(n2), o2 = r2.size, s2 = t2.legendHitBoxes = [], l2 = t2.minSize, u2 = t2.isHorizontal();
        if (u2 ? (l2.width = t2.maxWidth, l2.height = i2 ? 10 : 0) : (l2.width = i2 ? 10 : 0, l2.height = t2.maxHeight), i2) {
          if (a2.font = r2.string, u2) {
            var d2 = t2.lineWidths = [0], h2 = 0;
            a2.textAlign = "left", a2.textBaseline = "middle", H.each(t2.legendItems, function(t3, e3) {
              var i3 = Pi(n2, o2) + o2 / 2 + a2.measureText(t3.text).width;
              (0 === e3 || d2[d2.length - 1] + i3 + 2 * n2.padding > l2.width) && (h2 += o2 + n2.padding, d2[d2.length - (e3 > 0 ? 0 : 1)] = 0), s2[e3] = { left: 0, top: 0, width: i3, height: o2 }, d2[d2.length - 1] += i3 + n2.padding;
            }), l2.height += h2;
          } else {
            var c2 = n2.padding, f2 = t2.columnWidths = [], g2 = t2.columnHeights = [], p2 = n2.padding, m2 = 0, v2 = 0;
            H.each(t2.legendItems, function(t3, e3) {
              var i3 = Pi(n2, o2) + o2 / 2 + a2.measureText(t3.text).width;
              e3 > 0 && v2 + o2 + 2 * c2 > l2.height && (p2 += m2 + n2.padding, f2.push(m2), g2.push(v2), m2 = 0, v2 = 0), m2 = Math.max(m2, i3), v2 += o2 + c2, s2[e3] = { left: 0, top: 0, width: i3, height: o2 };
            }), p2 += m2, f2.push(m2), g2.push(v2), l2.width += p2;
          }
          t2.width = l2.width, t2.height = l2.height;
        } else t2.width = l2.width = t2.height = l2.height = 0;
      }, afterFit: Si, isHorizontal: function() {
        return "top" === this.options.position || "bottom" === this.options.position;
      }, draw: function() {
        var t2 = this, e2 = t2.options, n2 = e2.labels, i2 = N.global, a2 = i2.defaultColor, r2 = i2.elements.line, o2 = t2.height, s2 = t2.columnHeights, l2 = t2.width, u2 = t2.lineWidths;
        if (e2.display) {
          var d2, h2 = Mi(e2.rtl, t2.left, t2.minSize.width), c2 = t2.ctx, f2 = Ci(n2.fontColor, i2.defaultFontColor), g2 = H.options._parseFont(n2), p2 = g2.size;
          c2.textAlign = h2.textAlign("left"), c2.textBaseline = "middle", c2.lineWidth = 0.5, c2.strokeStyle = f2, c2.fillStyle = f2, c2.font = g2.string;
          var m2 = Pi(n2, p2), v2 = t2.legendHitBoxes, b2 = function(t3, i3) {
            switch (e2.align) {
              case "start":
                return n2.padding;
              case "end":
                return t3 - i3;
              default:
                return (t3 - i3 + n2.padding) / 2;
            }
          }, x2 = t2.isHorizontal();
          d2 = x2 ? { x: t2.left + b2(l2, u2[0]), y: t2.top + n2.padding, line: 0 } : { x: t2.left + n2.padding, y: t2.top + b2(o2, s2[0]), line: 0 }, H.rtl.overrideTextDirection(t2.ctx, e2.textDirection);
          var y2 = p2 + n2.padding;
          H.each(t2.legendItems, function(e3, i3) {
            var f3 = c2.measureText(e3.text).width, g3 = m2 + p2 / 2 + f3, _2 = d2.x, k2 = d2.y;
            h2.setWidth(t2.minSize.width), x2 ? i3 > 0 && _2 + g3 + n2.padding > t2.left + t2.minSize.width && (k2 = d2.y += y2, d2.line++, _2 = d2.x = t2.left + b2(l2, u2[d2.line])) : i3 > 0 && k2 + y2 > t2.top + t2.minSize.height && (_2 = d2.x = _2 + t2.columnWidths[d2.line] + n2.padding, d2.line++, k2 = d2.y = t2.top + b2(o2, s2[d2.line]));
            var w2 = h2.x(_2);
            !function(t3, e4, i4) {
              if (!(isNaN(m2) || m2 <= 0)) {
                c2.save();
                var o3 = Ci(i4.lineWidth, r2.borderWidth);
                if (c2.fillStyle = Ci(i4.fillStyle, a2), c2.lineCap = Ci(i4.lineCap, r2.borderCapStyle), c2.lineDashOffset = Ci(i4.lineDashOffset, r2.borderDashOffset), c2.lineJoin = Ci(i4.lineJoin, r2.borderJoinStyle), c2.lineWidth = o3, c2.strokeStyle = Ci(i4.strokeStyle, a2), c2.setLineDash && c2.setLineDash(Ci(i4.lineDash, r2.borderDash)), n2 && n2.usePointStyle) {
                  var s3 = m2 * Math.SQRT2 / 2, l3 = h2.xPlus(t3, m2 / 2), u3 = e4 + p2 / 2;
                  H.canvas.drawPoint(c2, i4.pointStyle, s3, l3, u3, i4.rotation);
                } else c2.fillRect(h2.leftForLtr(t3, m2), e4, m2, p2), 0 !== o3 && c2.strokeRect(h2.leftForLtr(t3, m2), e4, m2, p2);
                c2.restore();
              }
            }(w2, k2, e3), v2[i3].left = h2.leftForLtr(w2, v2[i3].width), v2[i3].top = k2, function(t3, e4, n3, i4) {
              var a3 = p2 / 2, r3 = h2.xPlus(t3, m2 + a3), o3 = e4 + a3;
              c2.fillText(n3.text, r3, o3), n3.hidden && (c2.beginPath(), c2.lineWidth = 2, c2.moveTo(r3, o3), c2.lineTo(h2.xPlus(r3, i4), o3), c2.stroke());
            }(w2, k2, e3, f3), x2 ? d2.x += g3 + n2.padding : d2.y += y2;
          }), H.rtl.restoreTextDirection(t2.ctx, e2.textDirection);
        }
      }, _getLegendItemAt: function(t2, e2) {
        var n2, i2, a2, r2 = this;
        if (t2 >= r2.left && t2 <= r2.right && e2 >= r2.top && e2 <= r2.bottom) {
          for (a2 = r2.legendHitBoxes, n2 = 0; n2 < a2.length; ++n2) if (t2 >= (i2 = a2[n2]).left && t2 <= i2.left + i2.width && e2 >= i2.top && e2 <= i2.top + i2.height) return r2.legendItems[n2];
        }
        return null;
      }, handleEvent: function(t2) {
        var e2, n2 = this, i2 = n2.options, a2 = "mouseup" === t2.type ? "click" : t2.type;
        if ("mousemove" === a2) {
          if (!i2.onHover && !i2.onLeave) return;
        } else {
          if ("click" !== a2) return;
          if (!i2.onClick) return;
        }
        e2 = n2._getLegendItemAt(t2.x, t2.y), "click" === a2 ? e2 && i2.onClick && i2.onClick.call(n2, t2.native, e2) : (i2.onLeave && e2 !== n2._hoveredItem && (n2._hoveredItem && i2.onLeave.call(n2, t2.native, n2._hoveredItem), n2._hoveredItem = e2), i2.onHover && e2 && i2.onHover.call(n2, t2.native, e2));
      } });
      function Di(t2, e2) {
        var n2 = new Ai({ ctx: t2.ctx, options: e2, chart: t2 });
        pe.configure(t2, n2, e2), pe.addBox(t2, n2), t2.legend = n2;
      }
      var Ti = { id: "legend", _element: Ai, beforeInit: function(t2) {
        var e2 = t2.options.legend;
        e2 && Di(t2, e2);
      }, beforeUpdate: function(t2) {
        var e2 = t2.options.legend, n2 = t2.legend;
        e2 ? (H.mergeIf(e2, N.global.legend), n2 ? (pe.configure(t2, n2, e2), n2.options = e2) : Di(t2, e2)) : n2 && (pe.removeBox(t2, n2), delete t2.legend);
      }, afterEvent: function(t2, e2) {
        var n2 = t2.legend;
        n2 && n2.handleEvent(e2);
      } }, Ii = H.noop;
      N._set("global", { title: { display: false, fontStyle: "bold", fullWidth: true, padding: 10, position: "top", text: "", weight: 2e3 } });
      var Fi = K.extend({ initialize: function(t2) {
        H.extend(this, t2), this.legendHitBoxes = [];
      }, beforeUpdate: Ii, update: function(t2, e2, n2) {
        var i2 = this;
        return i2.beforeUpdate(), i2.maxWidth = t2, i2.maxHeight = e2, i2.margins = n2, i2.beforeSetDimensions(), i2.setDimensions(), i2.afterSetDimensions(), i2.beforeBuildLabels(), i2.buildLabels(), i2.afterBuildLabels(), i2.beforeFit(), i2.fit(), i2.afterFit(), i2.afterUpdate(), i2.minSize;
      }, afterUpdate: Ii, beforeSetDimensions: Ii, setDimensions: function() {
        var t2 = this;
        t2.isHorizontal() ? (t2.width = t2.maxWidth, t2.left = 0, t2.right = t2.width) : (t2.height = t2.maxHeight, t2.top = 0, t2.bottom = t2.height), t2.paddingLeft = 0, t2.paddingTop = 0, t2.paddingRight = 0, t2.paddingBottom = 0, t2.minSize = { width: 0, height: 0 };
      }, afterSetDimensions: Ii, beforeBuildLabels: Ii, buildLabels: Ii, afterBuildLabels: Ii, beforeFit: Ii, fit: function() {
        var t2, e2 = this, n2 = e2.options, i2 = e2.minSize = {}, a2 = e2.isHorizontal();
        n2.display ? (t2 = (H.isArray(n2.text) ? n2.text.length : 1) * H.options._parseFont(n2).lineHeight + 2 * n2.padding, e2.width = i2.width = a2 ? e2.maxWidth : t2, e2.height = i2.height = a2 ? t2 : e2.maxHeight) : e2.width = i2.width = e2.height = i2.height = 0;
      }, afterFit: Ii, isHorizontal: function() {
        var t2 = this.options.position;
        return "top" === t2 || "bottom" === t2;
      }, draw: function() {
        var t2 = this, e2 = t2.ctx, n2 = t2.options;
        if (n2.display) {
          var i2, a2, r2, o2 = H.options._parseFont(n2), s2 = o2.lineHeight, l2 = s2 / 2 + n2.padding, u2 = 0, d2 = t2.top, h2 = t2.left, c2 = t2.bottom, f2 = t2.right;
          e2.fillStyle = H.valueOrDefault(n2.fontColor, N.global.defaultFontColor), e2.font = o2.string, t2.isHorizontal() ? (a2 = h2 + (f2 - h2) / 2, r2 = d2 + l2, i2 = f2 - h2) : (a2 = "left" === n2.position ? h2 + l2 : f2 - l2, r2 = d2 + (c2 - d2) / 2, i2 = c2 - d2, u2 = Math.PI * ("left" === n2.position ? -0.5 : 0.5)), e2.save(), e2.translate(a2, r2), e2.rotate(u2), e2.textAlign = "center", e2.textBaseline = "middle";
          var g2 = n2.text;
          if (H.isArray(g2)) for (var p2 = 0, m2 = 0; m2 < g2.length; ++m2) e2.fillText(g2[m2], 0, p2, i2), p2 += s2;
          else e2.fillText(g2, 0, 0, i2);
          e2.restore();
        }
      } });
      function Oi(t2, e2) {
        var n2 = new Fi({ ctx: t2.ctx, options: e2, chart: t2 });
        pe.configure(t2, n2, e2), pe.addBox(t2, n2), t2.titleBlock = n2;
      }
      var Li = {}, Ri = wi, zi = Ti, Ni = { id: "title", _element: Fi, beforeInit: function(t2) {
        var e2 = t2.options.title;
        e2 && Oi(t2, e2);
      }, beforeUpdate: function(t2) {
        var e2 = t2.options.title, n2 = t2.titleBlock;
        e2 ? (H.mergeIf(e2, N.global.title), n2 ? (pe.configure(t2, n2, e2), n2.options = e2) : Oi(t2, e2)) : n2 && (pe.removeBox(t2, n2), delete t2.titleBlock);
      } };
      for (var Bi in Li.filler = Ri, Li.legend = zi, Li.title = Ni, en.helpers = H, function() {
        function t2(t3, e3, n3) {
          var i2;
          return "string" == typeof t3 ? (i2 = parseInt(t3, 10), -1 !== t3.indexOf("%") && (i2 = i2 / 100 * e3.parentNode[n3])) : i2 = t3, i2;
        }
        function e2(t3) {
          return null != t3 && "none" !== t3;
        }
        function n2(n3, i2, a2) {
          var r2 = document.defaultView, o2 = H._getParentNode(n3), s2 = r2.getComputedStyle(n3)[i2], l2 = r2.getComputedStyle(o2)[i2], u2 = e2(s2), d2 = e2(l2), h2 = Number.POSITIVE_INFINITY;
          return u2 || d2 ? Math.min(u2 ? t2(s2, n3, a2) : h2, d2 ? t2(l2, o2, a2) : h2) : "none";
        }
        H.where = function(t3, e3) {
          if (H.isArray(t3) && Array.prototype.filter) return t3.filter(e3);
          var n3 = [];
          return H.each(t3, function(t4) {
            e3(t4) && n3.push(t4);
          }), n3;
        }, H.findIndex = Array.prototype.findIndex ? function(t3, e3, n3) {
          return t3.findIndex(e3, n3);
        } : function(t3, e3, n3) {
          n3 = void 0 === n3 ? t3 : n3;
          for (var i2 = 0, a2 = t3.length; i2 < a2; ++i2) if (e3.call(n3, t3[i2], i2, t3)) return i2;
          return -1;
        }, H.findNextWhere = function(t3, e3, n3) {
          H.isNullOrUndef(n3) && (n3 = -1);
          for (var i2 = n3 + 1; i2 < t3.length; i2++) {
            var a2 = t3[i2];
            if (e3(a2)) return a2;
          }
        }, H.findPreviousWhere = function(t3, e3, n3) {
          H.isNullOrUndef(n3) && (n3 = t3.length);
          for (var i2 = n3 - 1; i2 >= 0; i2--) {
            var a2 = t3[i2];
            if (e3(a2)) return a2;
          }
        }, H.isNumber = function(t3) {
          return !isNaN(parseFloat(t3)) && isFinite(t3);
        }, H.almostEquals = function(t3, e3, n3) {
          return Math.abs(t3 - e3) < n3;
        }, H.almostWhole = function(t3, e3) {
          var n3 = Math.round(t3);
          return n3 - e3 <= t3 && n3 + e3 >= t3;
        }, H.max = function(t3) {
          return t3.reduce(function(t4, e3) {
            return isNaN(e3) ? t4 : Math.max(t4, e3);
          }, Number.NEGATIVE_INFINITY);
        }, H.min = function(t3) {
          return t3.reduce(function(t4, e3) {
            return isNaN(e3) ? t4 : Math.min(t4, e3);
          }, Number.POSITIVE_INFINITY);
        }, H.sign = Math.sign ? function(t3) {
          return Math.sign(t3);
        } : function(t3) {
          return 0 === (t3 = +t3) || isNaN(t3) ? t3 : t3 > 0 ? 1 : -1;
        }, H.toRadians = function(t3) {
          return t3 * (Math.PI / 180);
        }, H.toDegrees = function(t3) {
          return t3 * (180 / Math.PI);
        }, H._decimalPlaces = function(t3) {
          if (H.isFinite(t3)) {
            for (var e3 = 1, n3 = 0; Math.round(t3 * e3) / e3 !== t3; ) e3 *= 10, n3++;
            return n3;
          }
        }, H.getAngleFromPoint = function(t3, e3) {
          var n3 = e3.x - t3.x, i2 = e3.y - t3.y, a2 = Math.sqrt(n3 * n3 + i2 * i2), r2 = Math.atan2(i2, n3);
          return r2 < -0.5 * Math.PI && (r2 += 2 * Math.PI), { angle: r2, distance: a2 };
        }, H.distanceBetweenPoints = function(t3, e3) {
          return Math.sqrt(Math.pow(e3.x - t3.x, 2) + Math.pow(e3.y - t3.y, 2));
        }, H.aliasPixel = function(t3) {
          return t3 % 2 == 0 ? 0 : 0.5;
        }, H._alignPixel = function(t3, e3, n3) {
          var i2 = t3.currentDevicePixelRatio, a2 = n3 / 2;
          return Math.round((e3 - a2) * i2) / i2 + a2;
        }, H.splineCurve = function(t3, e3, n3, i2) {
          var a2 = t3.skip ? e3 : t3, r2 = e3, o2 = n3.skip ? e3 : n3, s2 = Math.sqrt(Math.pow(r2.x - a2.x, 2) + Math.pow(r2.y - a2.y, 2)), l2 = Math.sqrt(Math.pow(o2.x - r2.x, 2) + Math.pow(o2.y - r2.y, 2)), u2 = s2 / (s2 + l2), d2 = l2 / (s2 + l2), h2 = i2 * (u2 = isNaN(u2) ? 0 : u2), c2 = i2 * (d2 = isNaN(d2) ? 0 : d2);
          return { previous: { x: r2.x - h2 * (o2.x - a2.x), y: r2.y - h2 * (o2.y - a2.y) }, next: { x: r2.x + c2 * (o2.x - a2.x), y: r2.y + c2 * (o2.y - a2.y) } };
        }, H.EPSILON = Number.EPSILON || 1e-14, H.splineCurveMonotone = function(t3) {
          var e3, n3, i2, a2, r2, o2, s2, l2, u2, d2 = (t3 || []).map(function(t4) {
            return { model: t4._model, deltaK: 0, mK: 0 };
          }), h2 = d2.length;
          for (e3 = 0; e3 < h2; ++e3) if (!(i2 = d2[e3]).model.skip) {
            if (n3 = e3 > 0 ? d2[e3 - 1] : null, (a2 = e3 < h2 - 1 ? d2[e3 + 1] : null) && !a2.model.skip) {
              var c2 = a2.model.x - i2.model.x;
              i2.deltaK = 0 !== c2 ? (a2.model.y - i2.model.y) / c2 : 0;
            }
            !n3 || n3.model.skip ? i2.mK = i2.deltaK : !a2 || a2.model.skip ? i2.mK = n3.deltaK : this.sign(n3.deltaK) !== this.sign(i2.deltaK) ? i2.mK = 0 : i2.mK = (n3.deltaK + i2.deltaK) / 2;
          }
          for (e3 = 0; e3 < h2 - 1; ++e3) i2 = d2[e3], a2 = d2[e3 + 1], i2.model.skip || a2.model.skip || (H.almostEquals(i2.deltaK, 0, this.EPSILON) ? i2.mK = a2.mK = 0 : (r2 = i2.mK / i2.deltaK, o2 = a2.mK / i2.deltaK, (l2 = Math.pow(r2, 2) + Math.pow(o2, 2)) <= 9 || (s2 = 3 / Math.sqrt(l2), i2.mK = r2 * s2 * i2.deltaK, a2.mK = o2 * s2 * i2.deltaK)));
          for (e3 = 0; e3 < h2; ++e3) (i2 = d2[e3]).model.skip || (n3 = e3 > 0 ? d2[e3 - 1] : null, a2 = e3 < h2 - 1 ? d2[e3 + 1] : null, n3 && !n3.model.skip && (u2 = (i2.model.x - n3.model.x) / 3, i2.model.controlPointPreviousX = i2.model.x - u2, i2.model.controlPointPreviousY = i2.model.y - u2 * i2.mK), a2 && !a2.model.skip && (u2 = (a2.model.x - i2.model.x) / 3, i2.model.controlPointNextX = i2.model.x + u2, i2.model.controlPointNextY = i2.model.y + u2 * i2.mK));
        }, H.nextItem = function(t3, e3, n3) {
          return n3 ? e3 >= t3.length - 1 ? t3[0] : t3[e3 + 1] : e3 >= t3.length - 1 ? t3[t3.length - 1] : t3[e3 + 1];
        }, H.previousItem = function(t3, e3, n3) {
          return n3 ? e3 <= 0 ? t3[t3.length - 1] : t3[e3 - 1] : e3 <= 0 ? t3[0] : t3[e3 - 1];
        }, H.niceNum = function(t3, e3) {
          var n3 = Math.floor(H.log10(t3)), i2 = t3 / Math.pow(10, n3);
          return (e3 ? i2 < 1.5 ? 1 : i2 < 3 ? 2 : i2 < 7 ? 5 : 10 : i2 <= 1 ? 1 : i2 <= 2 ? 2 : i2 <= 5 ? 5 : 10) * Math.pow(10, n3);
        }, H.requestAnimFrame = "undefined" == typeof window ? function(t3) {
          t3();
        } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t3) {
          return window.setTimeout(t3, 1e3 / 60);
        }, H.getRelativePosition = function(t3, e3) {
          var n3, i2, a2 = t3.originalEvent || t3, r2 = t3.target || t3.srcElement, o2 = r2.getBoundingClientRect(), s2 = a2.touches;
          s2 && s2.length > 0 ? (n3 = s2[0].clientX, i2 = s2[0].clientY) : (n3 = a2.clientX, i2 = a2.clientY);
          var l2 = parseFloat(H.getStyle(r2, "padding-left")), u2 = parseFloat(H.getStyle(r2, "padding-top")), d2 = parseFloat(H.getStyle(r2, "padding-right")), h2 = parseFloat(H.getStyle(r2, "padding-bottom")), c2 = o2.right - o2.left - l2 - d2, f2 = o2.bottom - o2.top - u2 - h2;
          return { x: n3 = Math.round((n3 - o2.left - l2) / c2 * r2.width / e3.currentDevicePixelRatio), y: i2 = Math.round((i2 - o2.top - u2) / f2 * r2.height / e3.currentDevicePixelRatio) };
        }, H.getConstraintWidth = function(t3) {
          return n2(t3, "max-width", "clientWidth");
        }, H.getConstraintHeight = function(t3) {
          return n2(t3, "max-height", "clientHeight");
        }, H._calculatePadding = function(t3, e3, n3) {
          return (e3 = H.getStyle(t3, e3)).indexOf("%") > -1 ? n3 * parseInt(e3, 10) / 100 : parseInt(e3, 10);
        }, H._getParentNode = function(t3) {
          var e3 = t3.parentNode;
          return e3 && "[object ShadowRoot]" === e3.toString() && (e3 = e3.host), e3;
        }, H.getMaximumWidth = function(t3) {
          var e3 = H._getParentNode(t3);
          if (!e3) return t3.clientWidth;
          var n3 = e3.clientWidth, i2 = n3 - H._calculatePadding(e3, "padding-left", n3) - H._calculatePadding(e3, "padding-right", n3), a2 = H.getConstraintWidth(t3);
          return isNaN(a2) ? i2 : Math.min(i2, a2);
        }, H.getMaximumHeight = function(t3) {
          var e3 = H._getParentNode(t3);
          if (!e3) return t3.clientHeight;
          var n3 = e3.clientHeight, i2 = n3 - H._calculatePadding(e3, "padding-top", n3) - H._calculatePadding(e3, "padding-bottom", n3), a2 = H.getConstraintHeight(t3);
          return isNaN(a2) ? i2 : Math.min(i2, a2);
        }, H.getStyle = function(t3, e3) {
          return t3.currentStyle ? t3.currentStyle[e3] : document.defaultView.getComputedStyle(t3, null).getPropertyValue(e3);
        }, H.retinaScale = function(t3, e3) {
          var n3 = t3.currentDevicePixelRatio = e3 || "undefined" != typeof window && window.devicePixelRatio || 1;
          if (1 !== n3) {
            var i2 = t3.canvas, a2 = t3.height, r2 = t3.width;
            i2.height = a2 * n3, i2.width = r2 * n3, t3.ctx.scale(n3, n3), i2.style.height || i2.style.width || (i2.style.height = a2 + "px", i2.style.width = r2 + "px");
          }
        }, H.fontString = function(t3, e3, n3) {
          return e3 + " " + t3 + "px " + n3;
        }, H.longestText = function(t3, e3, n3, i2) {
          var a2 = (i2 = i2 || {}).data = i2.data || {}, r2 = i2.garbageCollect = i2.garbageCollect || [];
          i2.font !== e3 && (a2 = i2.data = {}, r2 = i2.garbageCollect = [], i2.font = e3), t3.font = e3;
          var o2, s2, l2, u2, d2, h2 = 0, c2 = n3.length;
          for (o2 = 0; o2 < c2; o2++) if (null != (u2 = n3[o2]) && true !== H.isArray(u2)) h2 = H.measureText(t3, a2, r2, h2, u2);
          else if (H.isArray(u2)) for (s2 = 0, l2 = u2.length; s2 < l2; s2++) null == (d2 = u2[s2]) || H.isArray(d2) || (h2 = H.measureText(t3, a2, r2, h2, d2));
          var f2 = r2.length / 2;
          if (f2 > n3.length) {
            for (o2 = 0; o2 < f2; o2++) delete a2[r2[o2]];
            r2.splice(0, f2);
          }
          return h2;
        }, H.measureText = function(t3, e3, n3, i2, a2) {
          var r2 = e3[a2];
          return r2 || (r2 = e3[a2] = t3.measureText(a2).width, n3.push(a2)), r2 > i2 && (i2 = r2), i2;
        }, H.numberOfLabelLines = function(t3) {
          var e3 = 1;
          return H.each(t3, function(t4) {
            H.isArray(t4) && t4.length > e3 && (e3 = t4.length);
          }), e3;
        }, H.color = _ ? function(t3) {
          return t3 instanceof CanvasGradient && (t3 = N.global.defaultColor), _(t3);
        } : function(t3) {
          return console.error("Color.js not found!"), t3;
        }, H.getHoverColor = function(t3) {
          return t3 instanceof CanvasPattern || t3 instanceof CanvasGradient ? t3 : H.color(t3).saturate(0.5).darken(0.1).rgbString();
        };
      }(), en._adapters = rn, en.Animation = $, en.animationService = J, en.controllers = Jt, en.DatasetController = it, en.defaults = N, en.Element = K, en.elements = kt, en.Interaction = re, en.layouts = pe, en.platform = Oe, en.plugins = Le, en.Scale = yn, en.scaleService = Re, en.Ticks = on, en.Tooltip = Ye, en.helpers.each(fi, function(t2, e2) {
        en.scaleService.registerScaleType(e2, t2, t2._defaults);
      }), Li) Li.hasOwnProperty(Bi) && en.plugins.register(Li[Bi]);
      en.platform.initialize();
      var Ei = en;
      return "undefined" != typeof window && (window.Chart = en), en.Chart = en, en.Legend = Li.legend._element, en.Title = Li.title._element, en.pluginService = en.plugins, en.PluginBase = en.Element.extend({}), en.canvasHelpers = en.helpers.canvas, en.layoutService = en.layouts, en.LinearScaleBase = Cn, en.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], function(t2) {
        en[t2] = function(e2, n2) {
          return new en(e2, en.helpers.merge(n2 || {}, { type: t2.charAt(0).toLowerCase() + t2.slice(1) }));
        };
      }), Ei;
    });
  }
});

export {
  require_Chart_min
};
/*! Bundled license information:

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

admin-lte/plugins/chart.js/Chart.min.js:
  (*!
   * Chart.js v2.9.4
   * https://www.chartjs.org
   * (c) 2020 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=chunk-LBJZ773J.js.map
